# ğŸ“ Schemas Explained

> **Our Pydantic Schemas Folder**

---

## ğŸ“‹ Overview

The `app/schemas/` folder contains Pydantic models that define the shape of request and response data.

---

## ğŸ“ Directory Structure

```
app/schemas/
â”œâ”€â”€ __init__.py       # Exports all schemas
â”œâ”€â”€ base.py           # Base schema configurations
â”œâ”€â”€ user.py           # User-related schemas
â””â”€â”€ utils.py          # Validation utilities
```

---

## ğŸ“ Schema Files

### `__init__.py` - Exports

```python
"""Schemas Package - Central export for all Pydantic schemas."""

from app.schemas.user import (
    UserCreateSchema,
    UserLoginSchema,
    UserResponseSchema,
    UserUpdateSchema,
)

__all__ = [
    "UserCreateSchema",
    "UserLoginSchema",
    "UserResponseSchema",
    "UserUpdateSchema",
]
```

This allows clean imports:

```python
from app.schemas import UserCreateSchema, UserResponseSchema
```

---

## ğŸ‘¤ User Schemas

### UserCreateSchema (Registration)

```python
class UserCreateSchema(BaseModel):
    """Schema for user registration request."""

    model_config = ConfigDict(
        str_strip_whitespace=True,  # Trim whitespace
    )

    username: str = Field(
        ...,
        min_length=3,
        max_length=80,
        description="Unique username",
        examples=["john_doe"],
    )

    email: str = Field(
        ...,
        max_length=120,
        description="Email address",
        examples=["john@example.com"],
    )

    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Password (min 8 chars)",
        examples=["SecurePass123!"],
    )

    first_name: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="First name",
        examples=["John"],
    )

    middle_name: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Middle name (optional)",
    )

    last_name: Optional[str] = Field(
        default=None,
        max_length=50,
        description="Last name (optional)",
    )

    bio: Optional[str] = Field(
        default=None,
        max_length=500,
        description="Short bio",
    )

    # Custom validators
    @field_validator("email")
    @classmethod
    def validate_email(cls, v: str) -> str:
        """Validate email format."""
        pattern = r"^[\w\.-]+@[\w\.-]+\.\w+$"
        if not re.match(pattern, v):
            raise ValueError("Invalid email format")
        return v.lower()  # Normalize to lowercase

    @field_validator("password")
    @classmethod
    def validate_password(cls, v: str) -> str:
        """Validate password strength."""
        validate_password_strength(v)  # Raises ValueError if weak
        return v
```

### UserLoginSchema

```python
class UserLoginSchema(BaseModel):
    """Schema for login request."""

    username: str = Field(
        ...,
        min_length=1,
        description="Username or email",
        examples=["john_doe"],
    )

    password: str = Field(
        ...,
        min_length=1,
        description="Password",
        examples=["SecurePass123!"],
    )
```

### UserUpdateSchema

```python
class UserUpdateSchema(BaseModel):
    """Schema for updating user profile."""

    model_config = ConfigDict(
        str_strip_whitespace=True,
    )

    # All fields optional for partial updates
    first_name: Optional[str] = Field(
        default=None,
        min_length=1,
        max_length=50,
    )

    middle_name: Optional[str] = Field(
        default=None,
        max_length=50,
    )

    last_name: Optional[str] = Field(
        default=None,
        max_length=50,
    )

    bio: Optional[str] = Field(
        default=None,
        max_length=500,
    )

    @model_validator(mode="after")
    def at_least_one_field(self) -> "UserUpdateSchema":
        """Ensure at least one field is provided."""
        values = [
            self.first_name,
            self.middle_name,
            self.last_name,
            self.bio,
        ]
        if all(v is None for v in values):
            raise ValueError("At least one field must be provided")
        return self
```

### UserResponseSchema (Output)

```python
class UserResponseSchema(BaseModel):
    """Schema for user data in responses."""

    model_config = ConfigDict(
        from_attributes=True,  # Allow from ORM objects
    )

    id: int
    username: str
    email: str
    first_name: str
    middle_name: Optional[str] = None
    last_name: Optional[str] = None
    bio: Optional[str] = None
    is_active: bool
    created_at: datetime
    updated_at: datetime

    # Note: No password field!

    def to_dict(self) -> dict:
        """Convert to dictionary with serialized dates."""
        data = self.model_dump()
        data["created_at"] = self.created_at.isoformat()
        data["updated_at"] = self.updated_at.isoformat()
        return data
```

---

## ğŸ“Š Schema Types

### Input Schemas (Requests)

| Schema             | Used For        | Contains Password |
| ------------------ | --------------- | ----------------- |
| `UserCreateSchema` | Registration    | âœ… Yes            |
| `UserLoginSchema`  | Login           | âœ… Yes            |
| `UserUpdateSchema` | Profile updates | âŒ No             |

### Output Schemas (Responses)

| Schema               | Used For           | Contains Password |
| -------------------- | ------------------ | ----------------- |
| `UserResponseSchema` | All user responses | âŒ Never!         |

---

## ğŸ”§ model_config Options

```python
from pydantic import ConfigDict

class MySchema(BaseModel):
    model_config = ConfigDict(
        # Strip whitespace from strings
        str_strip_whitespace=True,

        # Allow creation from ORM objects
        from_attributes=True,

        # How to handle extra fields
        extra="forbid",    # Raise error (strict)
        # extra="ignore",  # Silently discard
        # extra="allow",   # Accept and store

        # Field alias handling
        populate_by_name=True,  # Accept both alias and name
    )
```

---

## ğŸ“Š Input vs Output Schema Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SCHEMA SEPARATION                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   REQUEST (Input)            RESPONSE (Output)                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”‚
â”‚                                                                  â”‚
â”‚   UserCreateSchema           UserResponseSchema                  â”‚
â”‚   â”œâ”€â”€ username               â”œâ”€â”€ id                              â”‚
â”‚   â”œâ”€â”€ email                  â”œâ”€â”€ username                        â”‚
â”‚   â”œâ”€â”€ password â†â”€â”€â”€â”€â”€â”€â”€â”€     â”œâ”€â”€ email (no password!)            â”‚
â”‚   â”œâ”€â”€ first_name      â”‚      â”œâ”€â”€ first_name                      â”‚
â”‚   â””â”€â”€ ...             â”‚      â”œâ”€â”€ created_at                      â”‚
â”‚                       â”‚      â””â”€â”€ ...                             â”‚
â”‚                       â”‚                                          â”‚
â”‚                       â””â”€â”€â”€ Password NEVER in response!           â”‚
â”‚                                                                  â”‚
â”‚   Why separate?                                                  â”‚
â”‚   1. Security: Never expose sensitive fields                     â”‚
â”‚   2. Flexibility: Different validation rules                     â”‚
â”‚   3. Documentation: Clear API contracts                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Using Schemas in Routes

### Request Validation

```python
@bp.post("/register")
def register(body: UserCreateSchema):
    # body is already validated!
    # If invalid, 422 returned automatically

    user = UserService.create(body)
    return success_response(data=user, status_code=201)
```

### Response Formatting

```python
@bp.get("/<int:user_id>")
def get_user(path: UserPath):
    user = UserService.get_by_id(path.user_id)

    # Convert ORM object to response schema
    response = UserResponseSchema.model_validate(user)

    return success_response(data=response.to_dict())
```

---

## ğŸ”§ Password Validation Helper

The `validate_password_strength` function (in `utils.py`):

```python
def validate_password_strength(password: str) -> None:
    """
    Validate password meets strength requirements.

    Requirements:
    - At least 8 characters
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one digit
    - At least one special character

    Raises:
        ValueError: If password doesn't meet requirements
    """
    errors = []

    if len(password) < 8:
        errors.append("Password must be at least 8 characters")

    if not any(c.isupper() for c in password):
        errors.append("Password must contain an uppercase letter")

    if not any(c.islower() for c in password):
        errors.append("Password must contain a lowercase letter")

    if not any(c.isdigit() for c in password):
        errors.append("Password must contain a digit")

    special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
    if not any(c in special_chars for c in password):
        errors.append("Password must contain a special character")

    if errors:
        raise ValueError("; ".join(errors))
```

---

## ğŸ†š Comparison with Joi

### Joi Schema

```javascript
const userCreateSchema = Joi.object({
    username: Joi.string().min(3).max(80).required(),
    email: Joi.string().email().required(),
    password: Joi.string()
        .min(8)
        .required()
        .custom((value, helpers) => {
            if (!/[A-Z]/.test(value)) {
                return helpers.error("password.uppercase");
            }
            return value;
        }),
});
```

### Pydantic Schema

```python
class UserCreateSchema(BaseModel):
    username: str = Field(..., min_length=3, max_length=80)
    email: str  # + validator
    password: str = Field(..., min_length=8)  # + validator

    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError("Must contain uppercase")
        return v
```

---

## ğŸ”œ Next Steps

Now let's understand the complete validation flow.

**Next: [4.9_validation_flow.md](./4.9_validation_flow.md)** - Request validation flow.
