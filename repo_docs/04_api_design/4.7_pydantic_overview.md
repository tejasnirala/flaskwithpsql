# ğŸ“ Pydantic Overview

> **Python's Answer to Joi and Zod**

---

## ğŸ“‹ What is Pydantic?

**Pydantic** is a data validation library for Python that uses type hints to define data schemas. It's similar to:

-   **Joi** (JavaScript/Node.js)
-   **Zod** (TypeScript)
-   **Yup** (JavaScript)

---

## ğŸ†š Comparison with Node.js Libraries

### Joi (Node.js)

```javascript
const Joi = require("joi");

const userSchema = Joi.object({
    username: Joi.string().min(3).max(80).required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(8).required(),
    age: Joi.number().integer().min(18).optional(),
});

// Validation
const { error, value } = userSchema.validate(req.body);
if (error) {
    return res.status(400).json({ error: error.details });
}
```

### Zod (TypeScript)

```typescript
import { z } from "zod";

const userSchema = z.object({
    username: z.string().min(3).max(80),
    email: z.string().email(),
    password: z.string().min(8),
    age: z.number().int().min(18).optional(),
});

// Validation
const result = userSchema.safeParse(req.body);
if (!result.success) {
    return res.status(400).json({ error: result.error });
}
```

### Pydantic (Python)

```python
from pydantic import BaseModel, Field, EmailStr

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=80)
    email: EmailStr
    password: str = Field(..., min_length=8)
    age: int | None = Field(default=None, ge=18)

# Validation (automatic in flask-openapi3)
user = UserCreate(**request_data)  # Raises ValidationError if invalid
```

---

## ğŸ“Š Feature Comparison

| Feature             | Joi           | Zod             | Pydantic            |
| ------------------- | ------------- | --------------- | ------------------- | ----- |
| Language            | JavaScript    | TypeScript      | Python              |
| Type Safety         | Runtime only  | Full TypeScript | Type hints          |
| Nested Objects      | âœ…            | âœ…              | âœ…                  |
| Custom Validators   | `.custom()`   | `.refine()`     | `@validator`        |
| Default Values      | `.default()`  | `.default()`    | `= Field(default=)` |
| Optional Fields     | `.optional()` | `.optional()`   | `                   | None` |
| Error Messages      | Customizable  | Customizable    | Customizable        |
| JSON Schema         | âŒ            | `.toJSON()`     | Built-in            |
| OpenAPI Integration | Manual        | Manual          | Native              |

---

## ğŸ”§ Pydantic V2 (What We Use)

We use **Pydantic V2**, which has significant improvements:

```python
from pydantic import BaseModel, Field, ConfigDict

class User(BaseModel):
    # V2 uses model_config instead of inner Config class
    model_config = ConfigDict(
        from_attributes=True,  # Allow ORM mode
        extra="forbid",        # Reject extra fields
    )

    username: str = Field(..., min_length=3)
    email: str
```

---

## ğŸ“Š Field Types

### Basic Types

```python
from pydantic import BaseModel

class Example(BaseModel):
    # Required fields (no default)
    name: str                   # Any string
    age: int                    # Integer
    score: float                # Float
    active: bool                # Boolean

    # Optional fields
    nickname: str | None = None  # String or None
    count: int = 0               # Integer with default
```

### Special Types

```python
from pydantic import BaseModel, EmailStr, HttpUrl
from datetime import datetime
from typing import List, Dict

class ComplexExample(BaseModel):
    email: EmailStr              # Validated email
    website: HttpUrl             # Validated URL
    created_at: datetime         # DateTime parsing
    tags: List[str]              # List of strings
    metadata: Dict[str, str]     # Dictionary
    data: dict                   # Any dictionary
```

---

## ğŸ”§ Field Constraints

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    # String constraints
    username: str = Field(
        ...,                    # Required (no default)
        min_length=3,           # Minimum 3 characters
        max_length=80,          # Maximum 80 characters
        pattern=r'^[a-z0-9_]+$' # Regex pattern
    )

    # Numeric constraints
    age: int = Field(
        ...,
        ge=0,                   # >= 0 (Greater or Equal)
        le=150,                 # <= 150 (Less or Equal)
    )

    score: float = Field(
        default=0.0,
        gt=0,                   # > 0 (Greater Than)
        lt=100,                 # < 100 (Less Than)
    )

    # Documentation
    email: str = Field(
        ...,
        description="User's email address",
        examples=["user@example.com"],
    )
```

---

## ğŸ“Š Validation Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PYDANTIC VALIDATION FLOW                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   1. DATA INPUT                                                  â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚      {                                                           â”‚
â”‚        "username": "john",                                       â”‚
â”‚        "email": "john@example.com",                              â”‚
â”‚        "age": 25                                                 â”‚
â”‚      }                                                           â”‚
â”‚                                                                  â”‚
â”‚   2. TYPE COERCION                                               â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚      - "25" â†’ 25 (string to int)                                 â”‚
â”‚      - "true" â†’ True (string to bool)                            â”‚
â”‚                                                                  â”‚
â”‚   3. VALIDATION                                                  â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
â”‚      For each field:                                             â”‚
â”‚      â”œâ”€â”€ Check type                                              â”‚
â”‚      â”œâ”€â”€ Check min_length, max_length                            â”‚
â”‚      â”œâ”€â”€ Check pattern (regex)                                   â”‚
â”‚      â”œâ”€â”€ Check ge, le, gt, lt                                    â”‚
â”‚      â””â”€â”€ Run custom validators                                   â”‚
â”‚                                                                  â”‚
â”‚   4. RESULT                                                      â”‚
â”‚      â”€â”€â”€â”€â”€â”€                                                      â”‚
â”‚              â”‚                    â”‚                              â”‚
â”‚         All Valid              Errors                            â”‚
â”‚              â”‚                    â”‚                              â”‚
â”‚              â–¼                    â–¼                              â”‚
â”‚      Return Model         ValidationError                        â”‚
â”‚      Instance             with details                           â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Custom Validators

### Field Validators

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    username: str
    password: str

    @field_validator('username')
    @classmethod
    def username_alphanumeric(cls, v: str) -> str:
        if not v.isalnum():
            raise ValueError('must be alphanumeric')
        return v.lower()  # Transform to lowercase

    @field_validator('password')
    @classmethod
    def password_strength(cls, v: str) -> str:
        if len(v) < 8:
            raise ValueError('must be at least 8 characters')
        if not any(c.isupper() for c in v):
            raise ValueError('must contain uppercase')
        if not any(c.isdigit() for c in v):
            raise ValueError('must contain a digit')
        return v
```

### Model Validators

```python
from pydantic import BaseModel, model_validator

class DateRange(BaseModel):
    start_date: datetime
    end_date: datetime

    @model_validator(mode='after')
    def check_dates(self) -> 'DateRange':
        if self.start_date > self.end_date:
            raise ValueError('start_date must be before end_date')
        return self
```

---

## ğŸ“Š Handling Validation Errors

```python
from pydantic import BaseModel, ValidationError

class User(BaseModel):
    username: str
    email: str
    age: int

# Invalid data
try:
    user = User(
        username="jo",      # Too short (if min_length=3)
        email="not-email",  # Invalid email
        age="not-a-number"  # Wrong type
    )
except ValidationError as e:
    print(e.errors())
    # [
    #   {
    #     "type": "string_too_short",
    #     "loc": ["username"],
    #     "msg": "String should have at least 3 characters",
    #     "input": "jo"
    #   },
    #   {
    #     "type": "value_error",
    #     "loc": ["email"],
    #     "msg": "value is not a valid email address"
    #   },
    #   ...
    # ]
```

---

## ğŸ”§ Integration with Flask-OpenAPI3

flask-openapi3 uses Pydantic schemas automatically:

```python
from flask_openapi3 import APIBlueprint
from pydantic import BaseModel, Field

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3)
    email: str

@bp.post("/users")
def create_user(body: UserCreate):
    # `body` is already validated!
    # If invalid, 422 response is returned automatically
    print(body.username)  # Safe to use
    print(body.email)
```

---

## ğŸ¯ Best Practices

### 1. Use Specific Types

```python
# âŒ BAD - Too generic
data: dict

# âœ… GOOD - Specific type
data: Dict[str, int]

# âœ… EVEN BETTER - Nested models
class Address(BaseModel):
    street: str
    city: str

class User(BaseModel):
    address: Address
```

### 2. Document Fields

```python
# âŒ BAD - No description
email: str

# âœ… GOOD - Documented
email: str = Field(
    ...,
    description="User's primary email address",
    examples=["user@example.com"],
)
```

### 3. Separate Input/Output Schemas

```python
# For creating users (includes password)
class UserCreate(BaseModel):
    username: str
    email: str
    password: str  # Input only!

# For responses (no password)
class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    # No password field!
```

---

## ğŸ”œ Next Steps

Now let's look at our actual schemas folder.

**Next: [4.8_schemas_explained.md](./4.8_schemas_explained.md)** - Our schemas folder.
