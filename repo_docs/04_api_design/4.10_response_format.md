# ðŸ“¨ Response Format

> **Standardized API Response Envelope**

---

## ðŸ“‹ Overview

We use a **response envelope** pattern for ALL API responses. This provides a consistent, predictable structure that frontends can rely on.

---

## ðŸ“Š Response Envelope Structure

### Success Response

```json
{
    "success": true,
    "data": {
        /* payload */
    },
    "error": null,
    "meta": {
        /* optional metadata */
    }
}
```

### Error Response

```json
{
    "success": false,
    "data": null,
    "error": {
        "code": "ERROR_CODE",
        "message": "Human-readable message",
        "details": {
            /* optional field-level errors */
        }
    },
    "meta": null
}
```

---

## ðŸ“Š Field Descriptions

| Field     | Type           | Description                            |
| --------- | -------------- | -------------------------------------- |
| `success` | boolean        | `true` for success, `false` for errors |
| `data`    | any \| null    | Payload on success, `null` on error    |
| `error`   | object \| null | Error details, `null` on success       |
| `meta`    | object \| null | Optional metadata (pagination, etc.)   |

---

## ðŸ”§ Response Helper Functions

### Success Response

```python
# app/utils/responses.py

def success_response(
    data: Optional[Any] = None,
    message: Optional[str] = None,
    meta: Optional[Dict[str, Any]] = None,
    status_code: int = 200,
) -> tuple[Response, int]:
    """Create a standardized success response."""

    # Handle Pydantic models
    if hasattr(data, "model_dump"):
        data = data.model_dump()
    elif hasattr(data, "to_dict"):
        data = data.to_dict()

    # Include message in data if provided
    if message and isinstance(data, dict):
        data = {"message": message, **data}
    elif message and data is None:
        data = {"message": message}

    response_body = {
        "success": True,
        "data": data,
        "error": None,
        "meta": meta,
    }

    return jsonify(response_body), status_code
```

### Error Response

```python
def error_response(
    code: Union[ErrorCode, str],
    message: str,
    details: Optional[Dict[str, Any]] = None,
    meta: Optional[Dict[str, Any]] = None,
    status_code: int = 400,
) -> tuple[Response, int]:
    """Create a standardized error response."""

    # Convert enum to string
    if isinstance(code, ErrorCode):
        code = code.value

    error_body = {
        "code": code,
        "message": message,
    }

    if details is not None:
        error_body["details"] = details

    response_body = {
        "success": False,
        "data": None,
        "error": error_body,
        "meta": meta,
    }

    return jsonify(response_body), status_code
```

---

## ðŸ“Š Usage Examples

### Simple Success

```python
return success_response(data={"id": 1, "name": "John"})
```

```json
{
    "success": true,
    "data": { "id": 1, "name": "John" },
    "error": null,
    "meta": null
}
```

### Success with Message

```python
return success_response(
    data=user.to_dict(),
    message="User created successfully",
    status_code=201
)
```

```json
{
    "success": true,
    "data": {
        "message": "User created successfully",
        "id": 1,
        "username": "john_doe",
        ...
    },
    "error": null,
    "meta": null
}
```

### List with Pagination

```python
return success_response(
    data=users_list,
    meta={
        "page": 1,
        "per_page": 10,
        "total": 42,
        "total_pages": 5
    }
)
```

```json
{
    "success": true,
    "data": [
        { "id": 1, "username": "john" },
        { "id": 2, "username": "jane" }
    ],
    "error": null,
    "meta": {
        "page": 1,
        "per_page": 10,
        "total": 42,
        "total_pages": 5
    }
}
```

### Simple Error

```python
return error_response(
    code=ErrorCode.RESOURCE_NOT_FOUND,
    message="User not found",
    status_code=404
)
```

```json
{
    "success": false,
    "data": null,
    "error": {
        "code": "RESOURCE_NOT_FOUND",
        "message": "User not found"
    },
    "meta": null
}
```

### Validation Error with Details

```python
return error_response(
    code=ErrorCode.VALIDATION_ERROR,
    message="Validation failed",
    details={
        "email": "Invalid email format",
        "password": "Must be at least 8 characters"
    },
    status_code=422
)
```

```json
{
    "success": false,
    "data": null,
    "error": {
        "code": "VALIDATION_ERROR",
        "message": "Validation failed",
        "details": {
            "email": "Invalid email format",
            "password": "Must be at least 8 characters"
        }
    },
    "meta": null
}
```

---

## ðŸ“Š Error Codes

```python
class ErrorCode(str, Enum):
    """Machine-readable error codes."""

    # General Errors
    INTERNAL_ERROR = "INTERNAL_ERROR"
    BAD_REQUEST = "BAD_REQUEST"
    NOT_FOUND = "NOT_FOUND"
    METHOD_NOT_ALLOWED = "METHOD_NOT_ALLOWED"
    CONFLICT = "CONFLICT"

    # Validation Errors
    VALIDATION_ERROR = "VALIDATION_ERROR"
    INVALID_INPUT = "INVALID_INPUT"
    MISSING_FIELD = "MISSING_FIELD"

    # Authentication/Authorization Errors
    UNAUTHORIZED = "UNAUTHORIZED"
    FORBIDDEN = "FORBIDDEN"
    INVALID_CREDENTIALS = "INVALID_CREDENTIALS"
    TOKEN_EXPIRED = "TOKEN_EXPIRED"
    TOKEN_INVALID = "TOKEN_INVALID"

    # Resource Errors
    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"
    RESOURCE_ALREADY_EXISTS = "RESOURCE_ALREADY_EXISTS"

    # Database Errors
    DATABASE_ERROR = "DATABASE_ERROR"

    # Rate Limiting
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"
```

---

## ðŸ“Š HTTP Status Codes Mapping

| Error Code              | HTTP Status |
| ----------------------- | ----------- |
| INTERNAL_ERROR          | 500         |
| BAD_REQUEST             | 400         |
| NOT_FOUND               | 404         |
| METHOD_NOT_ALLOWED      | 405         |
| CONFLICT                | 409         |
| VALIDATION_ERROR        | 422         |
| UNAUTHORIZED            | 401         |
| FORBIDDEN               | 403         |
| INVALID_CREDENTIALS     | 401         |
| TOKEN_EXPIRED           | 401         |
| RESOURCE_NOT_FOUND      | 404         |
| RESOURCE_ALREADY_EXISTS | 409         |
| RATE_LIMIT_EXCEEDED     | 429         |

---

## ðŸ†š Comparison with Express.js

### Express.js Response Pattern

```javascript
// Usually each developer does their own thing...
res.json({ user: userData });
res.json({ data: userData });
res.json({ success: true, data: userData });
res.status(404).json({ error: "Not found" });
res.status(404).json({ message: "Not found" });
```

### Our Standardized Pattern

```python
# Always consistent!
return success_response(data=user_data)
return success_response(data=user_data, status_code=201)
return error_response(
    code=ErrorCode.RESOURCE_NOT_FOUND,
    message="User not found",
    status_code=404
)
```

---

## ðŸ“Š Benefits of Standardization

### 1. Frontend Simplicity

```typescript
// Frontend code can have one handler
async function apiCall<T>(url: string): Promise<T> {
    const response = await fetch(url);
    const result = await response.json();

    if (!result.success) {
        throw new ApiError(result.error.code, result.error.message);
    }

    return result.data;
}
```

### 2. Error Handling

```typescript
try {
    const user = await apiCall("/api/v1/users/1");
} catch (error) {
    if (error.code === "VALIDATION_ERROR") {
        // Show field errors
        showFieldErrors(error.details);
    } else if (error.code === "UNAUTHORIZED") {
        // Redirect to login
        router.push("/login");
    } else {
        // Show generic error
        showError(error.message);
    }
}
```

### 3. Documentation

API consumers know exactly what to expect:

```
âœ… success is always present
âœ… data contains payload or null
âœ… error contains details or null
âœ… Consistent HTTP status codes
```

---

## ðŸ“Š OpenAPI Response Schemas

```python
class StandardSuccessResponse(BaseModel):
    """Standard success response schema."""

    success: bool = Field(default=True)
    data: Optional[Any] = Field(default=None)
    error: None = Field(default=None)
    meta: Optional[MetaInfo] = Field(default=None)


class StandardErrorResponse(BaseModel):
    """Standard error response schema."""

    success: bool = Field(default=False)
    data: None = Field(default=None)
    error: ErrorDetail = Field(...)
    meta: Optional[MetaInfo] = Field(default=None)
```

Used in route definitions:

```python
@bp.get(
    "/<int:user_id>",
    responses={
        200: UserDataResponse,         # Extends StandardSuccessResponse
        404: StandardErrorResponse,
    },
)
def get_user(path: UserPath):
    # ...
```

---

## ðŸ”œ Next Steps

Now let's look at centralized error handling.

**Next: [4.11_error_handling.md](./4.11_error_handling.md)** - Centralized error handlers.
