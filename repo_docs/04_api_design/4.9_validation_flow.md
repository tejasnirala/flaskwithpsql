# ğŸ”„ Validation Flow

> **How Request Validation Works**

---

## ğŸ“‹ Overview

This document explains the complete validation flow from HTTP request to validated data in your route handler.

---

## ğŸ“Š High-Level Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REQUEST VALIDATION FLOW                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   HTTP Request                                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚   POST /api/v1/auth/register                                     â”‚
â”‚   Content-Type: application/json                                 â”‚
â”‚   Body: {"username": "jo", "email": "bad", "password": "123"}    â”‚
â”‚                                                                  â”‚
â”‚              â”‚                                                   â”‚
â”‚              â–¼                                                   â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚            FLASK-OPENAPI3 VALIDATION                    â”‚    â”‚
â”‚   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚    â”‚
â”‚   â”‚   1. Parse JSON body                                    â”‚    â”‚
â”‚   â”‚   2. Identify schema from route: UserCreateSchema       â”‚    â”‚
â”‚   â”‚   3. Instantiate: UserCreateSchema(**body_data)         â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚              â”‚                                                   â”‚
â”‚              â–¼                                                   â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚            PYDANTIC VALIDATION                          â”‚    â”‚
â”‚   â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚    â”‚
â”‚   â”‚   For each field:                                       â”‚    â”‚
â”‚   â”‚   â”œâ”€â”€ Type coercion (str â†’ int if needed)               â”‚    â”‚
â”‚   â”‚   â”œâ”€â”€ Check Field constraints (min_length, etc.)        â”‚    â”‚
â”‚   â”‚   â””â”€â”€ Run @field_validator functions                    â”‚    â”‚
â”‚   â”‚                                                         â”‚    â”‚
â”‚   â”‚   Then run @model_validator (cross-field checks)        â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚              â”‚                    â”‚                              â”‚
â”‚         All Valid              Errors                            â”‚
â”‚              â”‚                    â”‚                              â”‚
â”‚              â–¼                    â–¼                              â”‚
â”‚                                                                  â”‚
â”‚   Route handler gets          422 Error Response                 â”‚
â”‚   validated `body` object     {                                  â”‚
â”‚                                 "success": false,                â”‚
â”‚   @bp.post("/register")         "data": null,                    â”‚
â”‚   def register(body: Schema):   "error": {                       â”‚
â”‚       # body is validated!        "code": "VALIDATION_ERROR",    â”‚
â”‚       print(body.username)        "message": "Validation failed",â”‚
â”‚                                   "details": {...}               â”‚
â”‚                                 }                                â”‚
â”‚                               }                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Step-by-Step Example

### Request

```http
POST /api/v1/auth/register
Content-Type: application/json

{
    "username": "jo",
    "email": "invalid-email",
    "password": "weak",
    "first_name": "John"
}
```

### Route Definition

```python
@auth_bp_v1.post("/register")
def register(body: UserCreateSchema):
    # This only runs if validation passes!
    user = UserService.create(body)
    return success_response(data=user, status_code=201)
```

### Validation Steps

1. **Parse JSON Body**

    ```python
    body_data = {
        "username": "jo",
        "email": "invalid-email",
        "password": "weak",
        "first_name": "John"
    }
    ```

2. **Attempt Schema Instantiation**

    ```python
    UserCreateSchema(**body_data)
    ```

3. **Field Validation**

    ```
    username: "jo"
    â””â”€â”€ min_length=3? NO! Error: "at least 3 characters"

    email: "invalid-email"
    â””â”€â”€ @field_validator? NO! Error: "Invalid email format"

    password: "weak"
    â””â”€â”€ min_length=8? NO! Error: "at least 8 characters"
    â””â”€â”€ @field_validator? Not checked (already failed)

    first_name: "John"
    â””â”€â”€ min_length=1? YES âœ“
    â””â”€â”€ max_length=50? YES âœ“
    ```

4. **Collect All Errors**

    ```python
    errors = [
        {"loc": ["username"], "msg": "String should have at least 3 characters"},
        {"loc": ["email"], "msg": "Invalid email format"},
        {"loc": ["password"], "msg": "String should have at least 8 characters"},
    ]
    ```

5. **Return 422 Response**
    ```json
    {
        "success": false,
        "data": null,
        "error": {
            "code": "VALIDATION_ERROR",
            "message": "Validation failed",
            "details": {
                "username": "String should have at least 3 characters",
                "email": "Invalid email format",
                "password": "String should have at least 8 characters"
            }
        },
        "meta": null
    }
    ```

---

## ğŸ“Š Validation Types

### 1. Type Validation

```python
class Example(BaseModel):
    count: int

# "5" â†’ 5 (coerced)
# "five" â†’ ValidationError
```

### 2. Constraint Validation

```python
class Example(BaseModel):
    name: str = Field(..., min_length=3, max_length=50)

# "Jo" â†’ ValidationError (too short)
# "John" â†’ Valid âœ“
```

### 3. Pattern Validation

```python
class Example(BaseModel):
    code: str = Field(..., pattern=r'^[A-Z]{3}$')

# "ABC" â†’ Valid âœ“
# "abc" â†’ ValidationError (lowercase)
# "ABCD" â†’ ValidationError (4 chars)
```

### 4. Custom Validators

```python
class Example(BaseModel):
    password: str

    @field_validator("password")
    @classmethod
    def check_password(cls, v: str) -> str:
        if not any(c.isupper() for c in v):
            raise ValueError("Must contain uppercase")
        return v
```

### 5. Model Validators (Cross-Field)

```python
class DateRange(BaseModel):
    start: date
    end: date

    @model_validator(mode="after")
    def check_dates(self) -> "DateRange":
        if self.start > self.end:
            raise ValueError("start must be before end")
        return self
```

---

## ğŸ“Š Validation Order

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VALIDATION ORDER                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   1. DEFAULT VALUES                                              â”‚
â”‚      Fill in missing optional fields with defaults               â”‚
â”‚                                                                  â”‚
â”‚   2. TYPE COERCION                                               â”‚
â”‚      Convert strings to ints, parse dates, etc.                  â”‚
â”‚                                                                  â”‚
â”‚   3. FIELD CONSTRAINTS                                           â”‚
â”‚      min_length, max_length, ge, le, pattern                     â”‚
â”‚                                                                  â”‚
â”‚   4. FIELD VALIDATORS                                            â”‚
â”‚      @field_validator decorated functions                        â”‚
â”‚                                                                  â”‚
â”‚   5. MODEL VALIDATORS                                            â”‚
â”‚      @model_validator for cross-field validation                 â”‚
â”‚                                                                  â”‚
â”‚   Note: If any step fails, validation stops for that field       â”‚
â”‚   but continues for other fields to collect all errors.          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Parameter Types in Routes

### Body Parameters

```python
@bp.post("/")
def create(body: UserCreateSchema):
    # body = parsed and validated request body
    pass
```

### Path Parameters

```python
class UserPath(BaseModel):
    user_id: int = Field(..., ge=1)

@bp.get("/<int:user_id>")
def get_user(path: UserPath):
    # path.user_id is validated
    pass
```

### Query Parameters

```python
class ListQuery(BaseModel):
    page: int = Field(default=1, ge=1)
    per_page: int = Field(default=20, le=100)

@bp.get("/")
def list_items(query: ListQuery):
    # query.page, query.per_page are validated
    pass
```

### Header Parameters

```python
class AuthHeader(BaseModel):
    authorization: str = Field(..., alias="Authorization")

@bp.get("/protected")
def protected(header: AuthHeader):
    # header.authorization is validated
    pass
```

---

## ğŸ†š Comparison with Express.js

### Express.js with Joi

```javascript
const validateBody = (schema) => (req, res, next) => {
    const { error, value } = schema.validate(req.body, { abortEarly: false });
    if (error) {
        return res.status(422).json({
            success: false,
            error: {
                code: "VALIDATION_ERROR",
                message: "Validation failed",
                details: error.details.map((d) => ({
                    field: d.path[0],
                    message: d.message,
                })),
            },
        });
    }
    req.validatedBody = value;
    next();
};

router.post("/register", validateBody(userCreateSchema), async (req, res) => {
    const userData = req.validatedBody;
    // ...
});
```

### Flask with Pydantic

```python
@bp.post("/register")
def register(body: UserCreateSchema):
    # Validation is automatic!
    # If invalid, 422 is returned automatically
    user = UserService.create(body)
    return success_response(data=user, status_code=201)
```

Flask-openapi3 handles:

-   Parsing request body
-   Validating against schema
-   Returning 422 errors
-   Passing validated object to handler

---

## ğŸ”§ Error Response Format

When validation fails:

```json
{
    "success": false,
    "data": null,
    "error": {
        "code": "VALIDATION_ERROR",
        "message": "Validation failed",
        "details": {
            "username": "String should have at least 3 characters",
            "email": "Invalid email format",
            "password": [
                "String should have at least 8 characters",
                "Must contain uppercase letter"
            ]
        }
    },
    "meta": null
}
```

---

## âš ï¸ Common Gotchas

### 1. Optional vs Required

```python
# Required (no default, must be provided)
name: str

# Optional with None default
name: str | None = None

# Optional with value default
name: str = "default_value"
```

### 2. Validators Must Return Value

```python
# âŒ BAD - Doesn't return
@field_validator("name")
@classmethod
def check_name(cls, v):
    if len(v) < 3:
        raise ValueError("too short")
    # Missing return!

# âœ… GOOD - Returns the value
@field_validator("name")
@classmethod
def check_name(cls, v):
    if len(v) < 3:
        raise ValueError("too short")
    return v  # Always return!
```

### 3. Classmethod Decorator

```python
# âŒ BAD - Missing @classmethod
@field_validator("name")
def check_name(cls, v):
    return v

# âœ… GOOD - Has @classmethod
@field_validator("name")
@classmethod
def check_name(cls, v):
    return v
```

---

## ğŸ”œ Next Steps

Now let's look at our standardized response format.

**Next: [4.10_response_format.md](./4.10_response_format.md)** - Standardized responses.
