# üõ°Ô∏è Protecting Routes

> **Using `@jwt_required()` to Secure Endpoints**

---

## üìã Overview

Once JWT is set up, protecting routes is simple - just add the `@jwt_required()` decorator.

---

## üîí Basic Usage

### Required Authentication

```python
from flask_jwt_extended import jwt_required
from app.auth import get_current_user

@users_bp.get('/<int:user_id>')
@jwt_required()  # ‚Üê Must be authenticated!
def get_user(path: UserPath):
    """Get user by ID - requires authentication."""
    user = get_current_user()  # Get the logged-in user
    ...
```

### Optional Authentication

```python
@users_bp.get('/public-or-private')
@jwt_required(optional=True)  # ‚Üê Token is optional
def get_content():
    """Works with or without token."""
    user = get_current_user()

    if user:
        return {'message': f'Hello, {user.username}!', 'premium': True}
    else:
        return {'message': 'Hello, guest!', 'premium': False}
```

---

## üìä Decorator Options

| Option      | Default | Description                                             |
| ----------- | ------- | ------------------------------------------------------- |
| `optional`  | `False` | If True, route works without token                      |
| `refresh`   | `False` | If True, requires refresh token instead of access token |
| `fresh`     | `False` | If True, requires fresh (recently issued) token         |
| `locations` | `None`  | Override where to look for token                        |

### Examples

```python
# Requires access token (default)
@jwt_required()

# Token is optional
@jwt_required(optional=True)

# Requires refresh token (for /refresh endpoint)
@jwt_required(refresh=True)

# Requires fresh token (for sensitive operations)
@jwt_required(fresh=True)
```

---

## üë§ Getting User in Protected Routes

### Method 1: `get_current_user()` - Full User Object

```python
from app.auth import get_current_user

@users_bp.put('/<int:user_id>')
@jwt_required()
def update_user(path: UserPath, body: UserUpdateSchema):
    user = get_current_user()  # Returns User model instance

    # Full access to user data
    print(user.id)
    print(user.username)
    print(user.email)

    # Can call model methods
    user.update_profile(body)
    db.session.commit()
```

### Method 2: `get_jwt_identity()` - Just the ID

```python
from flask_jwt_extended import get_jwt_identity

@users_bp.get('/my-id')
@jwt_required()
def get_my_id():
    user_id = get_jwt_identity()  # Returns just the ID (int)

    # Faster - no database query!
    return {'user_id': user_id}
```

### Method 3: `get_jwt()` - Full Token Claims

```python
from flask_jwt_extended import get_jwt

@users_bp.get('/token-info')
@jwt_required()
def get_token_info():
    jwt_data = get_jwt()  # Full token payload

    return {
        'user_id': jwt_data['sub'],
        'username': jwt_data.get('username'),
        'email': jwt_data.get('email'),
        'issued_at': jwt_data['iat'],
        'expires': jwt_data['exp'],
        'token_id': jwt_data['jti'],
    }
```

---

## üîí Authorization Pattern: User Can Only Edit Own Data

```python
from app.auth import get_current_user
from app.utils.responses import error_response, ErrorCode

@users_bp.put('/<int:user_id>')
@jwt_required()
def update_user(path: UserPath, body: UserUpdateSchema):
    """Update user - must be the same user."""

    current_user = get_current_user()

    # Authorization check: Can only edit yourself
    if current_user.id != path.user_id:
        return error_response(
            code=ErrorCode.FORBIDDEN,
            message="You can only update your own profile",
            status_code=403,
        )

    # Proceed with update
    updated_user = UserService.update_user(path.user_id, body)
    return success_response(data=updated_user.to_dict())
```

---

## üëë Admin-Only Routes

### Using a Custom Decorator

```python
# app/auth/__init__.py

from functools import wraps
from flask_jwt_extended import verify_jwt_in_request

def admin_required():
    """Decorator for admin-only routes."""
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            verify_jwt_in_request()
            user = get_current_user()

            if not user:
                return error_response(
                    code=ErrorCode.UNAUTHORIZED,
                    message="Authentication required",
                    status_code=401,
                )

            if not user.is_admin:  # Assuming User has is_admin field
                return error_response(
                    code=ErrorCode.FORBIDDEN,
                    message="Admin privileges required",
                    status_code=403,
                )

            return fn(*args, **kwargs)
        return wrapper
    return decorator
```

### Using the Admin Decorator

```python
from app.auth import admin_required

@admin_bp.delete('/users/<int:user_id>')
@admin_required()  # Only admins!
def delete_user(path: UserPath):
    """Delete a user - admin only."""
    UserService.delete_user(path.user_id)
    return success_response(message="User deleted")
```

---

## üìä Protection Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ROUTE PROTECTION FLOW                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                  ‚îÇ
‚îÇ   Client Request                                                 ‚îÇ
‚îÇ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                ‚îÇ
‚îÇ   GET /api/v1/users/1                                            ‚îÇ
‚îÇ   Authorization: Bearer eyJhbGci...                              ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ              ‚îÇ                                                   ‚îÇ
‚îÇ              ‚ñº                                                   ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ   ‚îÇ                @jwt_required() Decorator                 ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   1. Extract token from Authorization header             ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ No token? ‚Üí 401 "Token required"                ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   2. Verify signature                                    ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ Invalid? ‚Üí 401 "Invalid token"                  ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   3. Check expiration                                    ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ Expired? ‚Üí 401 "Token has expired"              ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   4. Check blacklist (token_in_blocklist_loader)         ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ Revoked? ‚Üí 401 "Token has been revoked"         ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   5. Load user (user_lookup_loader)                      ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ      ‚îî‚îÄ‚îÄ User deleted? ‚Üí 401 "User not found"            ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚úÖ All checks pass ‚Üí Continue to route handler         ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ                                                          ‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ              ‚îÇ                                                   ‚îÇ
‚îÇ              ‚ñº                                                   ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ   Route Handler                                                  ‚îÇ
‚îÇ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                  ‚îÇ
‚îÇ   def get_user(path):                                            ‚îÇ
‚îÇ       user = get_current_user()  # User is available!           ‚îÇ
‚îÇ       ...                                                        ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üÜö Express.js Comparison

### Express.js with Passport

```javascript
// Middleware
const requireAuth = passport.authenticate("jwt", { session: false });

// Protected route
router.get("/profile", requireAuth, (req, res) => {
    res.json({ user: req.user });
});
```

### Flask with Flask-JWT-Extended

```python
# Protected route
@users_bp.get('/profile')
@jwt_required()
def get_profile():
    user = get_current_user()
    return {'user': user.to_dict()}
```

**Very similar!** Flask uses decorators, Express uses middleware.

---

## üìã Common Patterns

### 1. Mixed Protection (Some routes public, some protected)

```python
# Public - no decorator
@users_bp.get('/')
def list_users():
    """Anyone can see user list."""
    return success_response(data=UserService.get_all())


# Protected - with decorator
@users_bp.get('/me')
@jwt_required()
def get_me():
    """Must be authenticated."""
    return success_response(data=get_current_user().to_dict())
```

### 2. Rate Limiting + Auth

```python
@users_bp.post('/')
@api_limit              # Rate limit first
@jwt_required()         # Then auth
def create_user(body):
    ...
```

**Order matters!** Rate limit should run before spending resources on auth.

### 3. OpenAPI Security Annotation

```python
@users_bp.put('/<int:user_id>')
@jwt_required()
def update_user(path: UserPath, body: UserUpdateSchema):
    ...

# In blueprint setup - automatically marks protected routes in Swagger
users_bp = APIBlueprint(
    'users',
    __name__,
    abp_security=[{"jwt": []}],  # All routes require JWT
)
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Decorator Order Matters!

```python
# ‚ùå WRONG - jwt_required sees no user
@jwt_required()
@users_bp.get('/me')
def get_me():
    ...

# ‚úÖ CORRECT - Route first, then protection
@users_bp.get('/me')
@jwt_required()
def get_me():
    ...
```

### 2. Forgetting to Check Authorization

```python
# ‚ùå BAD - Any logged-in user can update any user!
@users_bp.put('/<int:user_id>')
@jwt_required()
def update_user(path, body):
    user = UserService.get_by_id(path.user_id)
    # No check if current user owns this!
    UserService.update(user, body)

# ‚úÖ GOOD - Check ownership
@users_bp.put('/<int:user_id>')
@jwt_required()
def update_user(path, body):
    current = get_current_user()
    if current.id != path.user_id:
        return error_response(code=ErrorCode.FORBIDDEN, status_code=403)
    UserService.update(current, body)
```

### 3. Using Wrong Token Type

```python
# ‚ùå WRONG - Using access token for refresh
@auth_bp.post('/refresh')
@jwt_required()  # This expects access token!
def refresh():
    ...

# ‚úÖ CORRECT
@auth_bp.post('/refresh')
@jwt_required(refresh=True)  # This expects refresh token!
def refresh():
    ...
```

---

## üîú Next Steps

Now let's understand the token lifecycle in detail.

**Next: [5.6_token_lifecycle.md](./5.6_token_lifecycle.md)** - Token expiration, refresh, and blacklisting.
