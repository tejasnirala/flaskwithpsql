# üîê Password Security

> **Secure Password Hashing and Verification**

---

## üìã Overview

Password security is **critical**. A single data breach can expose millions of user passwords. We use industry-standard practices to protect passwords.

---

## ‚ö†Ô∏è Never Store Plain Text Passwords!

```python
# ‚ùå NEVER DO THIS - Plain text!
user.password = "mypassword123"

# ‚ùå NEVER DO THIS - Weak hashing!
import hashlib
user.password = hashlib.md5(password.encode()).hexdigest()

# ‚úÖ CORRECT - Werkzeug's secure hashing
from werkzeug.security import generate_password_hash
user.password_hash = generate_password_hash(password)
```

---

## üîß Our Password Hashing

We use **werkzeug.security** which provides:

-   **PBKDF2** (Password-Based Key Derivation Function 2)
-   **SHA-256** hashing algorithm
-   **Automatic salting**
-   **Configurable iterations** (currently 600,000)

### Hash Format

```
pbkdf2:sha256:600000$salt$hash
   ‚îÇ      ‚îÇ       ‚îÇ      ‚îÇ    ‚îÇ
   ‚îÇ      ‚îÇ       ‚îÇ      ‚îÇ    ‚îî‚îÄ‚îÄ The actual hash
   ‚îÇ      ‚îÇ       ‚îÇ      ‚îî‚îÄ‚îÄ Random salt (unique per password)
   ‚îÇ      ‚îÇ       ‚îî‚îÄ‚îÄ Number of iterations
   ‚îÇ      ‚îî‚îÄ‚îÄ Hash algorithm
   ‚îî‚îÄ‚îÄ Key derivation function
```

---

## üìÅ Our Implementation (`app/models/user.py`)

```python
from werkzeug.security import generate_password_hash, check_password_hash


class User(BaseModel):
    # Password is NEVER stored in plain text
    password_hash = Column(String(256), nullable=False)

    @staticmethod
    def hash_password(password: str) -> str:
        """
        Hash a password for storing using secure werkzeug functions.

        Uses PBKDF2 with SHA-256:
        - Slow by design (resistant to brute-force)
        - Automatically salted (resistant to rainbow tables)
        - Industry standard for password hashing

        Args:
            password: The plain text password to hash

        Returns:
            str: The hashed password (includes algorithm, salt, and hash)

        Example:
            >>> User.hash_password("MySecurePass123")
            'pbkdf2:sha256:600000$...$...'
        """
        return generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        """
        Verify a password against the stored hash.

        Uses werkzeug's secure comparison which is:
        - Timing-attack safe
        - Handles the salt extraction automatically

        Args:
            password: The plain text password to verify

        Returns:
            bool: True if password matches, False otherwise
        """
        return check_password_hash(self.password_hash, password)

    def set_password(self, password: str) -> None:
        """
        Set a new password for the user.

        Convenience method that hashes and stores the password.

        Args:
            password: The plain text password to set
        """
        self.password_hash = self.hash_password(password)
```

---

## üîÑ Password Verification Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  PASSWORD VERIFICATION FLOW                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                  ‚îÇ
‚îÇ   1. User submits: "MySecurePass123"                             ‚îÇ
‚îÇ                            ‚îÇ                                     ‚îÇ
‚îÇ                            ‚ñº                                     ‚îÇ
‚îÇ   2. Database lookup:                                            ‚îÇ
‚îÇ      user.password_hash = "pbkdf2:sha256:600000$abc123$xyz789"   ‚îÇ
‚îÇ                            ‚îÇ                                     ‚îÇ
‚îÇ                            ‚ñº                                     ‚îÇ
‚îÇ   3. check_password_hash():                                      ‚îÇ
‚îÇ      a. Extract algorithm: pbkdf2:sha256                         ‚îÇ
‚îÇ      b. Extract iterations: 600000                               ‚îÇ
‚îÇ      c. Extract salt: abc123                                     ‚îÇ
‚îÇ      d. Hash submitted password with same params                 ‚îÇ
‚îÇ      e. Compare result with stored hash                          ‚îÇ
‚îÇ                            ‚îÇ                                     ‚îÇ
‚îÇ                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                ‚îÇ                       ‚îÇ                         ‚îÇ
‚îÇ                ‚ñº                       ‚ñº                         ‚îÇ
‚îÇ           Match ‚úÖ                  No Match ‚ùå                   ‚îÇ
‚îÇ           ‚Üí Login success           ‚Üí 401 Invalid password       ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üõ°Ô∏è Why PBKDF2?

### Problem with Fast Hashes (MD5, SHA-1)

```
Password: "password123"

MD5 hash: 482c811da5d5b4bc6d497ffa98491e38
Time to compute: ~0.000001 seconds

Attacker can try: 100,000,000,000 passwords/second!
Time to crack "password123": ~0.00001 seconds
```

### Solution: Slow Hashes (PBKDF2, bcrypt, Argon2)

```
Password: "password123"

PBKDF2 hash: pbkdf2:sha256:600000$...
Time to compute: ~0.1 seconds (with 600k iterations)

Attacker can try: ~10 passwords/second
Time to crack "password123": Still fast (common password)
Time to crack "xK9#mP2$vL7@": ~1,000,000 years
```

---

## üÜö Node.js Comparison

### bcrypt in Node.js

```javascript
const bcrypt = require("bcrypt");

// Hash password
const saltRounds = 12;
const hash = await bcrypt.hash(password, saltRounds);

// Verify password
const isMatch = await bcrypt.compare(password, hash);
```

### werkzeug in Flask

```python
from werkzeug.security import generate_password_hash, check_password_hash

# Hash password
hash = generate_password_hash(password)

# Verify password
is_match = check_password_hash(hash, password)
```

**Both achieve the same goal!** Flask uses PBKDF2, Node.js typically uses bcrypt.

---

## üìä Security Features

### 1. Salting (Automatic)

Each password gets a unique random salt, making rainbow table attacks useless.

```python
# Same password, different hashes due to different salts
>>> generate_password_hash("password123")
'pbkdf2:sha256:600000$abc123$xyz789...'
>>> generate_password_hash("password123")
'pbkdf2:sha256:600000$def456$uvw012...'  # Different!
```

### 2. Key Stretching (600,000 iterations)

Makes each hash computation slow, deterring brute force attacks.

```python
# The :600000 in pbkdf2:sha256:600000$...
# means 600,000 rounds of hashing
```

### 3. Timing-Safe Comparison

```python
# ‚ùå Vulnerable to timing attacks
if stored_hash == computed_hash:
    return True

# ‚úÖ Werkzeug uses constant-time comparison
check_password_hash(stored_hash, password)  # Safe!
```

---

## üìù Password Requirements

In our Pydantic schema, we enforce password requirements:

```python
# app/schemas/user.py

class UserCreateSchema(BaseModel):
    password: str = Field(
        ...,
        min_length=8,
        max_length=128,
        description="Must contain uppercase, lowercase, and digit"
    )

    @field_validator('password')
    @classmethod
    def validate_password(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError('Must contain at least one uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('Must contain at least one lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Must contain at least one digit')
        return v
```

### Requirements Summary

| Requirement          | Reason                              |
| -------------------- | ----------------------------------- |
| Min 8 characters     | Prevent trivially short passwords   |
| Max 128 characters   | Prevent DoS via very long passwords |
| At least 1 uppercase | Increase complexity                 |
| At least 1 lowercase | Increase complexity                 |
| At least 1 digit     | Increase complexity                 |

---

## ‚ö†Ô∏è Common Mistakes to Avoid

### 1. Logging Passwords

```python
# ‚ùå NEVER DO THIS
logger.info(f"User {email} logging in with password {password}")

# ‚úÖ GOOD
logger.info(f"User {email} attempting login")
```

### 2. Returning Password Hash in API

```python
# ‚ùå BAD - Exposes hash
def to_dict(self):
    return {
        'id': self.id,
        'password_hash': self.password_hash,  # NEVER!
    }

# ‚úÖ GOOD - Exclude password
def to_dict(self):
    return {
        'id': self.id,
        'username': self.username,
        # password_hash is NOT included
    }
```

### 3. Comparing Passwords Directly

```python
# ‚ùå BAD - Vulnerable to timing attacks
if user.password_hash == some_computed_hash:
    ...

# ‚úÖ GOOD - Use werkzeug's safe comparison
if user.check_password(submitted_password):
    ...
```

### 4. Using Weak Hash Algorithms

```python
# ‚ùå BAD - Broken algorithms
import hashlib
hash = hashlib.md5(password.encode()).hexdigest()
hash = hashlib.sha1(password.encode()).hexdigest()

# ‚úÖ GOOD - Use werkzeug
from werkzeug.security import generate_password_hash
hash = generate_password_hash(password)
```

---

## üîß Changing Passwords

### Password Change Endpoint

```python
@users_bp.put('/me/password')
@jwt_required()
def change_password(body: PasswordChangeSchema):
    user = get_current_user()

    # Verify current password
    if not user.check_password(body.current_password):
        return error_response(
            code=ErrorCode.INVALID_CREDENTIALS,
            message="Current password is incorrect",
            status_code=401
        )

    # Set new password
    user.set_password(body.new_password)
    db.session.commit()

    # TODO: Revoke all existing tokens

    return success_response(message="Password changed successfully")
```

### Schema

```python
class PasswordChangeSchema(BaseModel):
    current_password: str
    new_password: str = Field(..., min_length=8)

    @field_validator('new_password')
    @classmethod
    def validate_new_password(cls, v):
        # Same validation as registration
        ...
```

---

## üìä Algorithm Comparison

| Algorithm  | Type      | Speed     | Security     | Our Choice    |
| ---------- | --------- | --------- | ------------ | ------------- |
| MD5        | Fast hash | Very fast | ‚ùå Broken    | No            |
| SHA-1      | Fast hash | Very fast | ‚ùå Broken    | No            |
| SHA-256    | Fast hash | Very fast | ‚ö†Ô∏è Too fast  | No            |
| **PBKDF2** | Slow hash | Slow      | ‚úÖ Good      | **Yes**       |
| bcrypt     | Slow hash | Slow      | ‚úÖ Excellent | Alternative   |
| Argon2     | Slow hash | Slow      | ‚úÖ Best      | Future option |

---

## üîú Section Complete!

You've completed the **05_authentication** section! You now understand:

1. ‚úÖ Authentication vs Authorization
2. ‚úÖ How JWT works
3. ‚úÖ Flask-JWT-Extended setup
4. ‚úÖ Auth routes (login, logout, refresh, me)
5. ‚úÖ Protecting routes with `@jwt_required()`
6. ‚úÖ Token lifecycle (expiration, refresh, blacklist)
7. ‚úÖ Secure password hashing

---

## üîú Next Section

Ready to learn about application architecture?

**Next: [../06_architecture/6.1_architecture_overview.md](../06_architecture/6.1_architecture_overview.md)** - Clean architecture principles.
