# 5.8 RBAC Architecture - Complete Design Guide

> **Understanding Role-Based Access Control from First Principles**

This document explains the **conceptual architecture** of our RBAC implementation. No code here—just the design decisions, data flow, and reasoning behind every choice.

---

## Table of Contents

1. [What Problem Does RBAC Solve?](#1-what-problem-does-rbac-solve)
2. [RBAC vs Other Access Control Models](#2-rbac-vs-other-access-control-models)
3. [Our Hybrid RBAC Architecture](#3-our-hybrid-rbac-architecture)
4. [Data Model Design](#4-data-model-design)
    - 4.1 [Database Tables Deep Dive](#41-database-tables-deep-dive)
5. [Permission Design](#5-permission-design)
6. [Role Inheritance](#6-role-inheritance)
7. [Direct Permissions (Hybrid Feature)](#7-direct-permissions-hybrid-feature)
8. [Effective Permissions Calculation](#8-effective-permissions-calculation)
9. [Component Architecture](#9-component-architecture)
10. [Request Flow Architecture](#10-request-flow-architecture)
11. [Security Considerations](#11-security-considerations)
12. [Trade-offs and Limitations](#12-trade-offs-and-limitations)
13. [Scalability Considerations](#13-scalability-considerations)

---

## 1. What Problem Does RBAC Solve?

### The Permission Management Problem

Imagine you have 1,000 users in your system. Without RBAC:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    WITHOUT RBAC: Direct Permission Assignment               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   User 1    ──→  [read, update, delete, create, export]                     │
│   User 2    ──→  [read, update, delete, create, export]                     │
│   User 3    ──→  [read, update, delete, create, export]                     │
│   ...                                                                        │
│   User 500  ──→  [read, update, delete, create, export]                     │
│   User 501  ──→  [read, update]                                             │
│   User 502  ──→  [read, update]                                             │
│   ...                                                                        │
│   User 800  ──→  [read, update]                                             │
│   User 801  ──→  [read]                                                     │
│   ...                                                                        │
│   User 1000 ──→  [read]                                                     │
│                                                                              │
│   PROBLEMS:                                                                  │
│   ─────────                                                                  │
│   • 1,000 individual permission sets to manage                              │
│   • Want to add "audit" permission to all admins?                           │
│     → Update 500 users individually!                                        │
│   • Want to revoke "delete" from all moderators?                            │
│     → Find and update 300 users individually!                               │
│   • Audit nightmare: "Who can delete users?" → Scan all 1,000 users         │
│   • Error-prone: Easy to miss a user or grant wrong permission              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### The RBAC Solution

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    WITH RBAC: Role-Based Assignment                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ROLES (defined once):                                                      │
│   ─────────────────────                                                      │
│   admin      ──→  [read, update, delete, create, export]                    │
│   moderator  ──→  [read, update]                                            │
│   user       ──→  [read]                                                    │
│                                                                              │
│   USERS (assigned to roles):                                                 │
│   ──────────────────────────                                                 │
│   User 1-500     ──→  admin                                                 │
│   User 501-800   ──→  moderator                                             │
│   User 801-1000  ──→  user                                                  │
│                                                                              │
│   BENEFITS:                                                                  │
│   ─────────                                                                  │
│   • 3 permission sets instead of 1,000                                      │
│   • Add "audit" to admins? Update 1 role, affects 500 users instantly       │
│   • Revoke "delete" from moderators? Update 1 role, done!                   │
│   • Easy audit: "Who can delete?" → Find roles with delete → List users     │
│   • Onboarding: New admin? Assign admin role. Done.                         │
│   • Offboarding: Remove all roles. User has no permissions.                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Why This Matters

| Aspect                          | Without RBAC              | With RBAC                 |
| ------------------------------- | ------------------------- | ------------------------- |
| **Add permission to 500 users** | 500 database updates      | 1 role update             |
| **Audit "who can delete"**      | Query all users           | Query roles + members     |
| **New employee onboarding**     | Copy permissions manually | Assign role               |
| **Policy change**               | Find and update each user | Update role definition    |
| **Compliance reporting**        | Complex per-user queries  | Simple role-based queries |

---

## 2. RBAC vs Other Access Control Models

### Access Control Models Comparison

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ACCESS CONTROL MODELS COMPARISON                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. DAC (Discretionary Access Control)                                      │
│   ─────────────────────────────────────                                      │
│   • Owner controls access to their resources                                 │
│   • Example: File system permissions (owner, group, others)                 │
│   • Pros: Simple, flexible for owners                                        │
│   • Cons: No central control, hard to enforce policies                      │
│                                                                              │
│   2. MAC (Mandatory Access Control)                                          │
│   ─────────────────────────────────                                          │
│   • System-enforced, users can't change                                      │
│   • Example: Military classification (Top Secret, Secret, Unclassified)     │
│   • Pros: Very secure, strictly enforced                                     │
│   • Cons: Inflexible, complex to manage                                      │
│                                                                              │
│   3. RBAC (Role-Based Access Control) ← WE USE THIS                         │
│   ──────────────────────────────────                                         │
│   • Permissions assigned to roles, roles assigned to users                  │
│   • Example: Admin, Moderator, User roles                                   │
│   • Pros: Scalable, easy to audit, industry standard                        │
│   • Cons: Role explosion if not designed well                               │
│                                                                              │
│   4. ABAC (Attribute-Based Access Control)                                   │
│   ────────────────────────────────────────                                   │
│   • Access based on attributes (user dept, time, location)                  │
│   • Example: "Managers can approve if amount < $10K and during business hrs"│
│   • Pros: Very flexible, fine-grained                                        │
│   • Cons: Complex to implement and debug                                     │
│                                                                              │
│   5. ReBAC (Relationship-Based Access Control)                               │
│   ────────────────────────────────────────────                               │
│   • Access based on relationships between entities                          │
│   • Example: "User can edit document if they're in the document's team"     │
│   • Pros: Natural for social/collaborative apps                             │
│   • Cons: Complex relationship graphs                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Why We Chose RBAC

| Factor                | Why RBAC Fits                              |
| --------------------- | ------------------------------------------ |
| **Application type**  | API backend with clear user roles          |
| **Team size**         | Manageable number of distinct roles needed |
| **Compliance**        | Easy to audit and report on                |
| **Industry standard** | Well-understood pattern, easy to explain   |
| **Tooling**           | Good library support                       |
| **Learning curve**    | Easy to understand and implement           |

---

## 3. Our Hybrid RBAC Architecture

### Standard RBAC vs Our Hybrid RBAC

We implemented **Hybrid RBAC** = Standard RBAC + Direct Permissions.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STANDARD RBAC vs HYBRID RBAC                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   STANDARD RBAC:                                                             │
│   ──────────────                                                             │
│                                                                              │
│         User ───has───▶ Role ───has───▶ Permission                         │
│                                                                              │
│   • Permissions ONLY come from roles                                         │
│   • Simple and clean                                                         │
│   • But: What if ONE user needs ONE extra permission temporarily?           │
│         → Create a new role just for them? Role explosion!                  │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   HYBRID RBAC (Our Implementation):                                          │
│   ──────────────────────────────────                                         │
│                                                                              │
│                    ┌───has───▶ Role ───has───▶ Permission                   │
│         User ─────┤                                                          │
│                    └───has(direct)────────────▶ Permission                  │
│                                                                              │
│   • Permissions come from roles (primary)                                    │
│   • PLUS: Individual users can have extra permissions (exceptions)          │
│   • Best of both worlds: Role-based + flexibility for edge cases            │
│                                                                              │
│   Example:                                                                   │
│   ─────────                                                                  │
│   User "alice" has role "moderator" which gives:                            │
│     ✓ users:read                                                             │
│     ✓ users:update                                                           │
│                                                                              │
│   Alice needs to delete ONE spam account (temporary need).                   │
│   Instead of creating "moderator_with_delete" role:                          │
│     → Grant alice direct permission: users:delete                            │
│     → Reason: "Cleanup spam account #12345"                                  │
│     → Revoke when done                                                       │
│                                                                              │
│   Alice's effective permissions:                                             │
│     users:read (from role) + users:update (from role) + users:delete (direct)│
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Why Hybrid?

| Scenario                | Pure RBAC Solution      | Hybrid RBAC Solution                |
| ----------------------- | ----------------------- | ----------------------------------- |
| Temp access for project | Create "project_x_role" | Grant direct permission with reason |
| One-off exception       | Create unique role      | Grant direct permission             |
| Testing feature         | Create "tester" role    | Grant direct permission             |
| Emergency access        | Create "emergency" role | Grant direct permission             |

**Rule of Thumb:**

-   If MANY users need a permission → Create a role
-   If ONE user needs it temporarily → Use direct permission

---

## 4. Data Model Design

### Entity Relationship Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         DATA MODEL ARCHITECTURE                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                        users.users                                   │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │  id              │ Primary Key                                      │   │
│   │  username        │ Unique identifier                                │   │
│   │  email           │ Unique email                                     │   │
│   │  password_hash   │ Hashed password                                  │   │
│   │  is_active       │ Account status                                   │   │
│   │  ...             │ Other user fields                                │   │
│   └────────┬─────────────────────────────┬──────────────────────────────┘   │
│            │                             │                                   │
│            │ Many-to-Many               │ Many-to-Many                      │
│            │ (via user_roles)           │ (via user_permissions)            │
│            ▼                             ▼                                   │
│   ┌─────────────────────┐       ┌─────────────────────┐                     │
│   │   rbac.user_roles   │       │ rbac.user_permissions│                     │
│   ├─────────────────────┤       ├─────────────────────┤                     │
│   │ user_id (FK)        │       │ user_id (FK)        │                     │
│   │ role_id (FK)        │       │ permission_id (FK)  │                     │
│   │ assigned_at         │       │ granted_at          │                     │
│   │ assigned_by (FK)    │       │ granted_by (FK)     │                     │
│   └────────┬────────────┘       │ reason              │  ← Audit trail      │
│            │                    └──────────┬──────────┘                     │
│            ▼                               │                                 │
│   ┌─────────────────────┐                  │                                 │
│   │    rbac.roles       │                  │                                 │
│   ├─────────────────────┤                  │                                 │
│   │ id                  │                  │                                 │
│   │ name                │ "admin"          │                                 │
│   │ display_name        │ "Administrator"  │                                 │
│   │ description         │                  │                                 │
│   │ is_system_role      │ Protection flag  │                                 │
│   │ parent_role_id (FK) │ ──┐ Self-ref     │                                 │
│   └────────┬────────────┘   │ (inheritance)│                                 │
│            │                │              │                                 │
│            │ Many-to-Many   │              │                                 │
│            ▼                ▼              ▼                                 │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                     rbac.permissions                                 │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │  id          │ Primary Key                                          │   │
│   │  name        │ "users:delete" (full permission string)              │   │
│   │  resource    │ "users" (for querying by resource)                   │   │
│   │  action      │ "delete" (for querying by action)                    │   │
│   │  description │ "Allows deleting user accounts"                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Why This Schema Design?

| Design Decision                         | Reasoning                                                                    |
| --------------------------------------- | ---------------------------------------------------------------------------- |
| **Separate `rbac` schema**              | Clean separation from user data; easy to backup/audit RBAC tables separately |
| **Junction tables with metadata**       | `assigned_at`, `assigned_by` enable audit trail                              |
| **`reason` column in user_permissions** | Documents WHY a direct permission was granted                                |
| **`is_system_role` flag**               | Prevents accidental deletion of critical roles                               |
| **`parent_role_id` self-reference**     | Enables role inheritance without complexity                                  |
| **Split `resource` and `action`**       | Enables queries like "all delete permissions"                                |

---

### 4.1 Database Tables Deep Dive

#### Overview: The 6 Tables

Our RBAC system uses **6 tables** organized across 2 schemas:

| # |        Table       | Schema | Type | Purpose |
|---|--------------------|--------|------|---------||
| 1 | `users`            | `users` | **Entity** | Stores user accounts |
| 2 | `roles`            | `rbac` | **Entity** | Stores role definitions |
| 3 | `permissions`      | `rbac` | **Entity** | Stores permission definitions |
| 4 | `user_roles`       | `rbac` | **Junction** | Links users ↔ roles |
| 5 | `role_permissions` | `rbac` | **Junction** | Links roles ↔ permissions |
| 6 | `user_permissions` | `rbac` | **Junction** | Links users ↔ permissions directly |

---

#### Table 1: `users` - Who Can Access the System?

```
┌─────────────────────────────────────────────────────────┐
│                         users                           │
├────────┬──────────────┬─────────────────────────────────┤
│   id   │   username   │          email                  │
├────────┼──────────────┼─────────────────────────────────┤
│   1    │   john_doe   │   john@example.com              │
│   2    │   jane_admin │   jane@example.com              │
│   3    │   bob_mod    │   bob@example.com               │
└────────┴──────────────┴─────────────────────────────────┘
```

**Purpose:** Store the people/accounts who want to access your system.

**Key Columns:**

-   `id` - Primary key
-   `username`, `email` - Unique identifiers
-   `password_hash` - Securely hashed password
-   `is_active` - Account status flag

---

#### Table 2: `roles` - What "Hats" Can Users Wear?

```
┌────────────────────────────────────────────────────────────────┐
│                           roles                                │
├────────┬────────────┬─────────────────┬────────────────────────┤
│   id   │    name    │  display_name   │  parent_role_id        │
├────────┼────────────┼─────────────────┼────────────────────────┤
│   1    │   user     │   Basic User    │        NULL            │
│   2    │  moderator │   Moderator     │          1             │  ← inherits from user
│   3    │   admin    │  Administrator  │          2             │  ← inherits from moderator
└────────┴────────────┴─────────────────┴────────────────────────┘
```

**Purpose:** Define the "job titles" or "access levels" in your system.

**Real-World Analogy:** In a company:

-   "Intern" → limited access
-   "Employee" → normal access
-   "Manager" → more access
-   "CEO" → full access

**Key Columns:**

-   `name` - Unique identifier used in code (e.g., `"admin"`)
-   `display_name` - Human-friendly name for UI
-   `parent_role_id` - Points to parent role for inheritance
-   `is_system_role` - Protection flag (can't delete if `True`)

---

#### Table 3: `permissions` - What Specific Actions Exist?

```
┌───────────────────────────────────────────────────────────────────┐
│                         permissions                               │
├────────┬─────────────────┬────────────┬────────────┬──────────────┤
│   id   │      name       │  resource  │   action   │  description │
├────────┼─────────────────┼────────────┼────────────┼──────────────┤
│   1    │  users:read     │   users    │    read    │ View users   │
│   2    │  users:create   │   users    │   create   │ Create users │
│   3    │  users:update   │   users    │   update   │ Edit users   │
│   4    │  users:delete   │   users    │   delete   │ Delete users │
│   5    │  posts:read     │   posts    │    read    │ View posts   │
└────────┴─────────────────┴────────────┴────────────┴──────────────┘
```

**Purpose:** Define every possible action in your system. Think of these as "capabilities" or "abilities".

**Format:** `resource:action` (e.g., `users:delete` means "can delete users")

**Key Columns:**

-   `name` - Full permission string (e.g., `"users:delete"`)
-   `resource` - What the permission acts on (e.g., `"users"`)
-   `action` - What action is allowed (e.g., `"delete"`)
-   `description` - Human-readable explanation

---

#### Table 4: `user_roles` (Junction Table) - Which Users Have Which Roles?

```
┌───────────────────────────────────────────────────────┐
│                     user_roles                        │
├───────────┬───────────┬──────────────┬────────────────┤
│  user_id  │  role_id  │ assigned_at  │  assigned_by   │
├───────────┼───────────┼──────────────┼────────────────┤
│     1     │     1     │  2026-01-01  │      NULL      │  ← john has "user" role
│     2     │     3     │  2026-01-01  │      NULL      │  ← jane has "admin" role
│     3     │     2     │  2026-01-05  │       2        │  ← bob has "moderator", assigned by jane
└───────────┴───────────┴──────────────┴────────────────┘
```

**Purpose:** Connect users to their roles. One user can have **multiple roles**!

**Key Columns:**

-   `user_id` (FK) - References the user
-   `role_id` (FK) - References the role
-   `assigned_at` - Audit: when the role was assigned
-   `assigned_by` (FK) - Audit: which admin assigned this role

**Why a Separate Table?**
Because this is a **many-to-many relationship**: One user can have many roles, and one role can be assigned to many users.

---

#### Table 5: `role_permissions` (Junction Table) - Which Roles Have Which Permissions?

```
┌────────────────────────────────────────────────────────┐
│                   role_permissions                     │
├───────────┬─────────────────┬──────────────────────────┤
│  role_id  │  permission_id  │       granted_at         │
├───────────┼─────────────────┼──────────────────────────┤
│     1     │        1        │  2026-01-01              │  ← "user" can read users
│     1     │        5        │  2026-01-01              │  ← "user" can read posts
│     2     │        3        │  2026-01-01              │  ← "moderator" can update users
│     3     │        2        │  2026-01-01              │  ← "admin" can create users
│     3     │        4        │  2026-01-01              │  ← "admin" can delete users
└───────────┴─────────────────┴──────────────────────────┘
```

**Purpose:** Define what each role is **allowed to do**.

**Key Columns:**

-   `role_id` (FK) - References the role
-   `permission_id` (FK) - References the permission
-   `granted_at` - Audit: when the permission was granted to this role

**Why a Separate Table?**
Because this is also a **many-to-many relationship**: One role can have many permissions, and one permission can belong to many roles.

---

#### Table 6: `user_permissions` (Junction Table) - Direct/Exception Permissions

```
┌─────────────────────────────────────────────────────────────────┐
│                      user_permissions                           │
├───────────┬─────────────────┬──────────────┬────────────────────┤
│  user_id  │  permission_id  │  granted_by  │       reason       │
├───────────┼─────────────────┼──────────────┼────────────────────┤
│     1     │        4        │      2       │ Temporary for audit│  ← john can delete (exception!)
└───────────┴─────────────────┴──────────────┴────────────────────┘
```

**Purpose:** Give specific users **extra permissions** that bypass their role. Used for:

-   Temporary elevated access
-   Exceptions that don't fit roles
-   Testing features with specific users

**Key Columns:**

-   `user_id` (FK) - The user getting the permission
-   `permission_id` (FK) - The permission being granted
-   `granted_by` (FK) - Which admin granted this
-   `granted_at` - When it was granted
-   `reason` - **Critical for audit**: Why was this exception granted?

---

#### How All 6 Tables Connect

```
                    ┌──────────────────┐
                    │      USERS       │
                    │   (john, jane)   │
                    └────────┬─────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
            ▼                │                ▼
   ┌────────────────┐        │       ┌────────────────────┐
   │   user_roles   │        │       │  user_permissions  │
   │  (junction)    │        │       │    (junction)      │
   └───────┬────────┘        │       └─────────┬──────────┘
           │                 │                 │
           ▼                 │                 │
   ┌────────────────┐        │                 │
   │     ROLES      │        │                 │
   │ (admin, user)  │        │                 │
   └───────┬────────┘        │                 │
           │                 │                 │
           ▼                 │                 │
   ┌────────────────┐        │                 │
   │role_permissions│        │                 │
   │  (junction)    │        │                 │
   └───────┬────────┘        │                 │
           │                 │                 │
           ▼                 ▼                 ▼
   ┌─────────────────────────────────────────────┐
   │               PERMISSIONS                   │
   │     (users:read, users:delete, etc.)        │
   └─────────────────────────────────────────────┘
```

**To check if john can delete users:**

1. **Path 1:** john → `user_roles` → `roles` → `role_permissions` → `permissions` ✓
2. **Path 2:** john → `user_permissions` → `permissions` ✓ (direct exception)

---

#### Could We Use Fewer Tables?

Great question! Let's explore the alternatives:

##### Alternative 1: Store Permissions Directly on User (2 tables)

```python
# users table
users = {
    "id": 1,
    "username": "john",
    "permissions": ["users:read", "users:delete", "posts:read"]  # JSON array
}
```

**Problems:**

| Issue                 | Explanation                                                 |
| --------------------- | ----------------------------------------------------------- |
| ❌ **Duplication**    | If 1000 users need `users:read`, you store it 1000 times    |
| ❌ **No grouping**    | Can't say "all moderators can do X" - must update each user |
| ❌ **Hard to audit**  | "Who has delete permission?" requires scanning all users    |
| ❌ **No inheritance** | No role hierarchy (admin inherits moderator permissions)    |

---

##### Alternative 2: Store Roles on User, Permissions in Role (3 tables)

```python
# users table
users = {
    "id": 1,
    "username": "john",
    "role": "admin"  # Just one role
}

# roles table
roles = {
    "name": "admin",
    "permissions": ["users:read", "users:create", ...]  # JSON array
}
```

**Problems:**

| Issue                         | Explanation                                                    |
| ----------------------------- | -------------------------------------------------------------- |
| ❌ **One role per user**      | In real apps, one user might be both "moderator" AND "support" |
| ❌ **Permission duplication** | Same permission in multiple roles = stored multiple times      |
| ❌ **Hard to query**          | "Which roles have delete permission?" requires JSON parsing    |

---

##### Alternative 3: Many-to-Many but No Direct Permissions (5 tables)

Remove `user_permissions` table. Users can ONLY get permissions through roles.

```
users  ──── user_roles ──── roles ──── role_permissions ──── permissions
```

**This actually works for most apps!**

But you lose flexibility:

| Scenario                          | With `user_permissions`          | Without                            |
| --------------------------------- | -------------------------------- | ---------------------------------- |
| Give john temporary delete access | ✅ Add row to `user_permissions` | ❌ Create a new role just for john |
| Remove the exception later        | ✅ Delete the row                | ❌ Delete the role                 |
| Audit why john has delete access  | ✅ Check `reason` column         | ❌ Confusing role names            |

---

#### Why 6 Tables is the Right Design

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        WHY THIS DESIGN IS OPTIMAL                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. NORMALIZATION (No Duplication)                                          │
│     └── Each permission defined ONCE, referenced many times                 │
│                                                                             │
│  2. FLEXIBILITY                                                             │
│     ├── User can have multiple roles (developer + team-lead)                │
│     ├── Roles can have multiple permissions                                 │
│     └── Direct permissions for exceptions                                   │
│                                                                             │
│  3. SCALABILITY                                                             │
│     └── Adding a permission to "admin" role instantly affects all admins    │
│                                                                             │
│  4. AUDITABILITY                                                            │
│     ├── assigned_by: WHO gave this role?                                    │
│     ├── assigned_at: WHEN was it assigned?                                  │
│     └── reason: WHY was this exception granted?                             │
│                                                                             │
│  5. ROLE HIERARCHY                                                          │
│     └── parent_role_id enables: user → moderator → admin → super_admin      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### Summary: Table Count Trade-offs

| Tables | Design                     | Real-World Usability | Flexibility         | Recommended?            |
| ------ | -------------------------- | -------------------- | ------------------- | ----------------------- |
| 2      | Permissions in User        | ⭐ Poor              | ⭐ None             | ❌ No                   |
| 3      | Permissions in Role (JSON) | ⭐⭐ Basic           | ⭐⭐ Limited        | ❌ No                   |
| 5      | No direct permissions      | ⭐⭐⭐⭐ Good        | ⭐⭐⭐ Good         | ✅ Yes (simpler)        |
| **6**  | **Full RBAC**              | ⭐⭐⭐⭐⭐ **Best**  | ⭐⭐⭐⭐⭐ **Full** | ✅ **Yes (production)** |

**Bottom Line:**

-   **Could you use fewer tables?** Yes, you could use 5 (drop `user_permissions`) for simpler apps.
-   **Should you?** For production systems, the 6-table design gives you the flexibility to handle real-world scenarios like:
    -   "Give this intern temporary admin access for 2 hours"
    -   "Why does this user have delete permission?"
    -   "Revoke all moderator permissions from everyone"

The extra complexity pays off when managing a system with thousands of users and complex permission requirements.

---

## 5. Permission Design

### Naming Convention

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       PERMISSION NAMING CONVENTION                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Format:  {resource}:{action}                                               │
│                                                                              │
│   ┌──────────────────┬─────────────────┬───────────────────────────────────┐│
│   │    Resource      │     Action      │          Full Permission          ││
│   ├──────────────────┼─────────────────┼───────────────────────────────────┤│
│   │    users         │     read        │          users:read               ││
│   │    users         │     create      │          users:create             ││
│   │    users         │     update      │          users:update             ││
│   │    users         │     delete      │          users:delete             ││
│   │    users         │     list        │          users:list               ││
│   │    roles         │     read        │          roles:read               ││
│   │    roles         │     assign      │          roles:assign             ││
│   │    roles         │     revoke      │          roles:revoke             ││
│   │    *             │     *           │          *:* (super admin)        ││
│   │    users         │     *           │          users:* (all on users)   ││
│   └──────────────────┴─────────────────┴───────────────────────────────────┘│
│                                                                              │
│   WHY THIS FORMAT:                                                           │
│   ─────────────────                                                          │
│   ✓ Human readable: "users:delete" obviously means "delete users"           │
│   ✓ Consistent: Same pattern for all permissions                            │
│   ✓ Queryable: Find all "delete" actions across resources                   │
│   ✓ Groupable: Find all permissions on "users" resource                     │
│   ✓ Wildcard support: "*:*" matches everything                              │
│                                                                              │
│   INDUSTRY STANDARD:                                                         │
│   ──────────────────                                                         │
│   Similar to AWS IAM: "s3:GetObject", "ec2:StartInstances"                  │
│   Similar to Google Cloud: "storage.objects.get"                            │
│   Similar to Kubernetes: "pods.list", "deployments.create"                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Permission Hierarchy (Wildcards)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         WILDCARD PERMISSION MATCHING                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Check: Does user have "users:delete"?                                      │
│                                                                              │
│   Match Order (first match wins):                                            │
│   ───────────────────────────────                                            │
│                                                                              │
│   1. Exact match: "users:delete"                                             │
│      → Does user have this exact permission? ✓ or continue                  │
│                                                                              │
│   2. Super wildcard: "*:*"                                                   │
│      → Does user have the god mode? ✓ or continue                           │
│                                                                              │
│   3. Resource wildcard: "users:*"                                            │
│      → Does user have all permissions on users? ✓ or fail                   │
│                                                                              │
│   Permission Hierarchy Visualization:                                        │
│   ────────────────────────────────────                                       │
│                                                                              │
│                              *:*                                             │
│                        (matches ALL)                                         │
│                              │                                               │
│            ┌─────────────────┼─────────────────┐                            │
│            │                 │                 │                            │
│         users:*           roles:*         permissions:*                     │
│      (all on users)    (all on roles)   (all on permissions)                │
│            │                                                                 │
│    ┌───────┼───────┬───────┬───────┐                                        │
│    │       │       │       │       │                                        │
│ users:  users:  users:  users:  users:                                      │
│ read   create  update  delete   list                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 6. Role Inheritance

### How Role Inheritance Works

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ROLE INHERITANCE MODEL                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   INHERITANCE CHAIN:                                                         │
│   ──────────────────                                                         │
│                                                                              │
│   ┌──────────────────────────────────────────────────────────────────┐      │
│   │                        super_admin                                │      │
│   │                    permissions: [*:*]                             │      │
│   │                    parent: none                                   │      │
│   └────────────────────────────────────────────────────────────────────┘      │
│                                  │                                           │
│                                  │ inherits from                             │
│                                  ▼                                           │
│   ┌──────────────────────────────────────────────────────────────────┐      │
│   │                          admin                                    │      │
│   │        permissions: [users:*, roles:read, roles:assign]          │      │
│   │                    parent: none (standalone)                      │      │
│   └────────────────────────────────────────────────────────────────────┘      │
│                                  │                                           │
│                                  │ inherits from                             │
│                                  ▼                                           │
│   ┌──────────────────────────────────────────────────────────────────┐      │
│   │                        moderator                                  │      │
│   │            permissions: [users:update]                            │      │
│   │                    parent: user                                   │      │
│   └────────────────────────────────────────────────────────────────────┘      │
│                                  │                                           │
│                                  │ inherits from                             │
│                                  ▼                                           │
│   ┌──────────────────────────────────────────────────────────────────┐      │
│   │                           user                                    │      │
│   │                permissions: [users:read]                          │      │
│   │                    parent: none (base role)                       │      │
│   └────────────────────────────────────────────────────────────────────┘      │
│                                                                              │
│   EFFECTIVE PERMISSIONS CALCULATION:                                         │
│   ───────────────────────────────────                                        │
│                                                                              │
│   User with "moderator" role gets:                                           │
│     • users:update (from moderator directly)                                 │
│     • users:read   (inherited from user via parent_role)                    │
│                                                                              │
│   User with "admin" role gets:                                               │
│     • users:*        (from admin directly)                                   │
│     • roles:read     (from admin directly)                                   │
│     • roles:assign   (from admin directly)                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Why Role Inheritance?

| Benefit               | Explanation                                  |
| --------------------- | -------------------------------------------- |
| **DRY**               | Common permissions defined once in base role |
| **Clear hierarchy**   | Easy to understand who has what              |
| **Easy updates**      | Change base role, all children get update    |
| **Logical structure** | Mirrors organizational hierarchies           |

---

## 7. Direct Permissions (Hybrid Feature)

### When to Use Direct Permissions

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DIRECT PERMISSIONS: WHEN TO USE                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ✅ GOOD USE CASES:                                                         │
│   ─────────────────                                                          │
│                                                                              │
│   1. TEMPORARY ACCESS                                                        │
│      Scenario: Developer needs prod DB access for 1 day to fix bug          │
│      Solution: Grant direct "database:admin" permission                      │
│      Reason: "Hotfix for issue #4521, expires 2024-01-15"                   │
│      Action: Revoke after task complete                                      │
│                                                                              │
│   2. ONE-OFF EXCEPTION                                                       │
│      Scenario: Support agent needs to delete ONE spam account               │
│      Solution: Grant direct "users:delete" permission                        │
│      Reason: "Cleanup spam account ID 12345"                                │
│      Action: Revoke after cleanup                                           │
│                                                                              │
│   3. BETA FEATURE TESTING                                                    │
│      Scenario: 5 users testing new analytics dashboard                      │
│      Solution: Grant direct "analytics:beta" permission                      │
│      Reason: "Beta testers for v2.0 analytics"                              │
│      Action: Remove when feature goes public                                 │
│                                                                              │
│   ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│   ❌ BAD USE CASES (Create a Role Instead):                                  │
│   ─────────────────────────────────────────                                  │
│                                                                              │
│   1. MANY USERS NEED SAME PERMISSION                                         │
│      Bad: 20 users each have direct "reports:export"                        │
│      Good: Create "report_exporter" role, assign to 20 users                │
│                                                                              │
│   2. PERMANENT ACCESS                                                        │
│      Bad: User has direct "billing:admin" forever                           │
│      Good: Create "billing_admin" role, assign to user                      │
│                                                                              │
│   3. COMPLEX PERMISSION SET                                                  │
│      Bad: User has 10 direct permissions                                    │
│      Good: Create role with those 10 permissions                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Audit Trail for Direct Permissions

Every direct permission includes:

-   **granted_at**: When it was granted
-   **granted_by**: Who granted it (admin user ID)
-   **reason**: Why it was granted (audit documentation)

This enables:

-   Security reviews: "List all direct permissions granted this month"
-   Cleanup: "Find permissions granted > 30 days ago"
-   Accountability: "Who granted this access?"

---

## 8. Effective Permissions Calculation

### The Algorithm

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   EFFECTIVE PERMISSIONS CALCULATION                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Given: User "alice"                                                        │
│                                                                              │
│   Step 1: Initialize empty permissions set                                   │
│   ─────────────────────────────────────────                                  │
│   effective_permissions = {}                                                 │
│                                                                              │
│   Step 2: Get all roles assigned to user                                     │
│   ───────────────────────────────────────                                    │
│   alice.roles = [moderator, support]                                         │
│                                                                              │
│   Step 3: For each role, get permissions (including inherited)               │
│   ──────────────────────────────────────────────────────────                 │
│                                                                              │
│   Role: moderator                                                            │
│   ├── Direct permissions: [users:update]                                     │
│   └── Parent: user                                                           │
│       └── Permissions: [users:read]                                          │
│                                                                              │
│   Add to set: {users:update, users:read}                                     │
│                                                                              │
│   Role: support                                                              │
│   ├── Direct permissions: [tickets:read, tickets:update]                    │
│   └── Parent: none                                                           │
│                                                                              │
│   Add to set: {users:update, users:read, tickets:read, tickets:update}      │
│                                                                              │
│   Step 4: Get direct permissions                                             │
│   ───────────────────────────────                                            │
│   alice.direct_permissions = [users:delete]  (granted for cleanup)          │
│                                                                              │
│   Add to set: {users:update, users:read, tickets:read,                      │
│                tickets:update, users:delete}                                 │
│                                                                              │
│   Step 5: Return combined set                                                │
│   ────────────────────────────                                               │
│                                                                              │
│   Final effective_permissions = {                                            │
│       "users:read",       ← from role inheritance (user → moderator)        │
│       "users:update",     ← from moderator role                             │
│       "users:delete",     ← DIRECT PERMISSION                               │
│       "tickets:read",     ← from support role                               │
│       "tickets:update"    ← from support role                               │
│   }                                                                          │
│                                                                              │
│   Now: Does alice have "users:delete"?                                       │
│   Answer: YES (from direct permission)                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Visual Representation

```
                         ┌─────────────────────────────────┐
                         │           User: Alice           │
                         └────────────────┬────────────────┘
                                          │
                    ┌─────────────────────┼─────────────────────┐
                    │                     │                     │
                    ▼                     ▼                     ▼
         ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
         │  Role: moderator │  │  Role: support   │  │ Direct Perms     │
         └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘
                  │                     │                     │
                  ▼                     ▼                     ▼
         ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
         │ users:update     │  │ tickets:read     │  │ users:delete     │
         │ + inherited:     │  │ tickets:update   │  │ (reason: cleanup)│
         │   users:read     │  │                  │  │                  │
         └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘
                  │                     │                     │
                  └─────────────────────┼─────────────────────┘
                                        │
                                        ▼
                         ┌─────────────────────────────────┐
                         │     EFFECTIVE PERMISSIONS       │
                         │  ───────────────────────────── │
                         │  • users:read                   │
                         │  • users:update                 │
                         │  • users:delete                 │
                         │  • tickets:read                 │
                         │  • tickets:update               │
                         └─────────────────────────────────┘
```

---

## 9. Component Architecture

### Layered Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       RBAC COMPONENT ARCHITECTURE                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                        PRESENTATION LAYER                            │   │
│   │                         (API Routes)                                 │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │                                                                      │   │
│   │   app/routes/v1/admin/                                               │   │
│   │   ├── roles.py          # Role CRUD endpoints                       │   │
│   │   └── permissions.py    # Permission endpoints                       │   │
│   │                                                                      │   │
│   │   These routes are THIN - they:                                      │   │
│   │   • Validate input (via Pydantic schemas)                           │   │
│   │   • Call service methods                                             │   │
│   │   • Format and return responses                                      │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                       │
│                                      ▼                                       │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                         DECORATOR LAYER                              │   │
│   │                      (Route Protection)                              │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │                                                                      │   │
│   │   app/rbac/decorators.py                                             │   │
│   │   ├── @permission_required()   # Check specific permissions         │   │
│   │   ├── @role_required()         # Check specific roles               │   │
│   │   ├── @admin_required()        # Shortcut for admin check           │   │
│   │   └── check_permission()       # Programmatic check                 │   │
│   │                                                                      │   │
│   │   These decorators:                                                  │   │
│   │   • Verify JWT token                                                 │   │
│   │   • Get current user                                                 │   │
│   │   • Check permissions via RBACService                                │   │
│   │   • Return 403 if denied                                             │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                       │
│                                      ▼                                       │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                          SERVICE LAYER                               │   │
│   │                       (Business Logic)                               │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │                                                                      │   │
│   │   app/rbac/services.py - RBACService                                 │   │
│   │   ├── user_has_permission()     # Core permission check             │   │
│   │   ├── get_user_permissions()    # Get all effective permissions     │   │
│   │   ├── assign_role_to_user()     # Assign a role                     │   │
│   │   ├── revoke_role_from_user()   # Revoke a role                     │   │
│   │   ├── grant_direct_permission() # Grant direct permission           │   │
│   │   ├── revoke_direct_permission()# Revoke direct permission          │   │
│   │   ├── seed_permissions()        # Seed from registry                │   │
│   │   └── seed_roles()              # Seed default roles                │   │
│   │                                                                      │   │
│   │   Service is STATELESS - all methods are static                      │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                       │
│                                      ▼                                       │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                           MODEL LAYER                                │   │
│   │                         (Data Access)                                │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │                                                                      │   │
│   │   app/models/                                                        │   │
│   │   ├── permission.py     # Permission entity                         │   │
│   │   ├── role.py           # Role entity with inheritance              │   │
│   │   ├── associations.py   # Junction tables                           │   │
│   │   └── user.py           # User with RBAC relationships              │   │
│   │                                                                      │   │
│   │   Models provide:                                                    │   │
│   │   • ORM mappings to database                                         │   │
│   │   • Relationship definitions                                         │   │
│   │   • Helper methods (has_permission, get_all_permissions)            │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                       │
│                                      ▼                                       │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                        CONFIGURATION LAYER                           │   │
│   │                      (Permission Registry)                           │   │
│   ├─────────────────────────────────────────────────────────────────────┤   │
│   │                                                                      │   │
│   │   app/rbac/permissions.py - PermissionRegistry                       │   │
│   │   ├── PERMISSIONS dict        # All valid permissions               │   │
│   │   ├── DEFAULT_ROLES dict      # Default role definitions            │   │
│   │   ├── all_permissions()       # Get all permission names            │   │
│   │   └── is_valid_permission()   # Validate permission string          │   │
│   │                                                                      │   │
│   │   This is the SINGLE SOURCE OF TRUTH for permissions                 │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Component Responsibilities (Single Responsibility Principle)

| Component              | Responsibility                     | Does NOT Do               |
| ---------------------- | ---------------------------------- | ------------------------- |
| **Routes**             | HTTP handling, request/response    | Business logic            |
| **Decorators**         | Wrap routes with auth checks       | Complex permission logic  |
| **RBACService**        | Permission checking logic          | Database queries directly |
| **Models**             | Data representation, relationships | Business rules            |
| **PermissionRegistry** | Define valid permissions           | Store permissions in DB   |

---

## 10. Request Flow Architecture

### Complete RBAC Request Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      COMPLETE RBAC REQUEST FLOW                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   1. HTTP REQUEST ARRIVES                                                    │
│   ──────────────────────────────────────────────────────────────────────     │
│                                                                              │
│   DELETE /api/v1/users/123                                                   │
│   Authorization: Bearer eyJhbGciOiJIUzI1NiIs...                              │
│                                                                              │
│                              │                                               │
│                              ▼                                               │
│                                                                              │
│   2. FLASK ROUTING                                                           │
│   ─────────────────                                                          │
│                                                                              │
│   Flask matches URL to route:                                                │
│   @users_bp.delete("/<int:user_id>")                                        │
│   @permission_required("users:delete")  ← Decorator intercepts              │
│   def delete_user(path: UserPath):                                          │
│       ...                                                                    │
│                                                                              │
│                              │                                               │
│                              ▼                                               │
│                                                                              │
│   3. DECORATOR EXECUTION (@permission_required)                              │
│   ───────────────────────────────────────────────                            │
│                                                                              │
│   ┌───────────────────────────────────────────────────────────────────┐     │
│   │   def permission_required(*permissions):                          │     │
│   │       def decorator(fn):                                          │     │
│   │           def wrapper(*args, **kwargs):                           │     │
│   │               ┌─────────────────────────────────────────────────┐│     │
│   │               │ Step 3a: Verify JWT                              ││     │
│   │               │ verify_jwt_in_request()                          ││     │
│   │               │ ├── Valid token? Continue                        ││     │
│   │               │ └── Invalid/missing? → 401 Unauthorized          ││     │
│   │               └─────────────────────────────────────────────────┘│     │
│   │                                    │                              │     │
│   │                                    ▼                              │     │
│   │               ┌─────────────────────────────────────────────────┐│     │
│   │               │ Step 3b: Get Current User                        ││     │
│   │               │ user = get_current_user()                        ││     │
│   │               │ ├── User found? Continue                         ││     │
│   │               │ └── Not found? → 401 Unauthorized                ││     │
│   │               └─────────────────────────────────────────────────┘│     │
│   │                                    │                              │     │
│   │                                    ▼                              │     │
│   │               ┌─────────────────────────────────────────────────┐│     │
│   │               │ Step 3c: Check User Active                       ││     │
│   │               │ if not user.is_active:                           ││     │
│   │               │     → 403 Forbidden (deactivated)                ││     │
│   │               └─────────────────────────────────────────────────┘│     │
│   │                                    │                              │     │
│   │                                    ▼                              │     │
│   │               ┌─────────────────────────────────────────────────┐│     │
│   │               │ Step 3d: Check Permission                        ││     │
│   │               │ RBACService.user_has_permission(user, perm)      ││     │
│   │               │ ├── Has permission? → Execute route              ││     │
│   │               │ └── No permission? → 403 Forbidden               ││     │
│   │               └─────────────────────────────────────────────────┘│     │
│   │           return wrapper                                          │     │
│   │       return decorator                                            │     │
│   └───────────────────────────────────────────────────────────────────┘     │
│                                                                              │
│                              │                                               │
│                              ▼                                               │
│                                                                              │
│   4. PERMISSION CHECK (RBACService.user_has_permission)                      │
│   ─────────────────────────────────────────────────────                      │
│                                                                              │
│   ┌────────────────────────────────────────────────────────────────────┐    │
│   │  Input: user object, permission = "users:delete"                   │    │
│   │                                                                     │    │
│   │  1. Get user's effective permissions:                               │    │
│   │     all_perms = user.get_all_permissions()                          │    │
│   │     → {users:read, users:update, users:delete}                      │    │
│   │                                                                     │    │
│   │  2. Check exact match:                                              │    │
│   │     "users:delete" in all_perms? → YES → return True               │    │
│   │                                                                     │    │
│   │  3. Check super wildcard (if no match):                             │    │
│   │     "*:*" in all_perms? → return True                              │    │
│   │                                                                     │    │
│   │  4. Check resource wildcard (if no match):                          │    │
│   │     "users:*" in all_perms? → return True                          │    │
│   │                                                                     │    │
│   │  5. No match:                                                       │    │
│   │     → return False                                                  │    │
│   └────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│                              │                                               │
│                    ┌─────────┴─────────┐                                    │
│                    │                   │                                    │
│                 GRANTED             DENIED                                  │
│                    │                   │                                    │
│                    ▼                   ▼                                    │
│                                                                              │
│   5a. ROUTE EXECUTION                5b. ERROR RESPONSE                      │
│   ────────────────────               ────────────────────                    │
│                                                                              │
│   def delete_user():                 {                                       │
│       user = User.query.get(id)        "success": false,                    │
│       user.soft_delete()               "data": null,                        │
│       return success_response()        "error": {                           │
│                                          "code": "FORBIDDEN",               │
│                                          "message": "Insufficient perms",   │
│                                          "details": {                       │
│                                            "required": ["users:delete"]    │
│                                          }                                  │
│                                        }                                    │
│                                      }                                      │
│                                      HTTP 403                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 11. Security Considerations

### Defense in Depth

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       SECURITY LAYERS                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Layer 1: AUTHENTICATION (JWT)                                              │
│   ─────────────────────────────                                              │
│   • Is the user who they claim to be?                                        │
│   • Valid token? Not expired? Not blacklisted?                              │
│   • If fails → 401 Unauthorized                                              │
│                                                                              │
│   Layer 2: ACCOUNT STATUS                                                    │
│   ────────────────────────                                                   │
│   • Is the account active?                                                   │
│   • Not deleted? Not suspended?                                              │
│   • If fails → 403 Forbidden                                                 │
│                                                                              │
│   Layer 3: AUTHORIZATION (RBAC)                                              │
│   ─────────────────────────────                                              │
│   • Does the user have permission for this action?                          │
│   • Check roles + direct permissions                                         │
│   • If fails → 403 Forbidden                                                 │
│                                                                              │
│   Layer 4: RESOURCE OWNERSHIP (optional, per-route)                         │
│   ─────────────────────────────────────────────────                         │
│   • Can this user access THIS specific resource?                            │
│   • Example: User can only edit their own profile                           │
│   • Implemented in route logic                                               │
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                                                                      │   │
│   │   Request → [Auth] → [Status] → [RBAC] → [Ownership] → Execute      │   │
│   │               │          │         │          │                      │   │
│   │              401        403       403        403/404                 │   │
│   │                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Security Best Practices Implemented

| Practice                         | Implementation                                     |
| -------------------------------- | -------------------------------------------------- |
| **Principle of Least Privilege** | Users start with minimal permissions               |
| **Default Deny**                 | No permission = access denied                      |
| **Audit Trail**                  | All role/permission changes logged                 |
| **System Role Protection**       | Critical roles can't be deleted                    |
| **Token Verification First**     | Auth checked before any permission check           |
| **No Permission Leakage**        | Error messages don't reveal what permissions exist |

---

## 12. Trade-offs and Limitations

### What We Gained

| Benefit             | Details                           |
| ------------------- | --------------------------------- |
| **Scalability**     | Add 1000 users? Just assign roles |
| **Auditability**    | Clear trail of who has what       |
| **Maintainability** | Change role = affects all members |
| **Security**        | Centralized access control        |
| **Flexibility**     | Hybrid allows exceptions          |

### What We Trade Off

| Trade-off                   | Mitigation                        |
| --------------------------- | --------------------------------- | --------------------------------------------- |
| **Performance overhead**    | Permission check on every request | Eager loading relationships; caching possible |
| **Complexity**              | More tables, more joins           | Good documentation; clear naming              |
| **Role explosion risk**     | Too many roles = defeats purpose  | Policy: max 10-15 roles                       |
| **Direct permission abuse** | Could bypass role structure       | Policy: must have documented reason           |

### Limitations

| Limitation                     | Why                   | Workaround                       |
| ------------------------------ | --------------------- | -------------------------------- |
| **No time-based permissions**  | Not implemented       | Manual revocation; cron job      |
| **No conditional permissions** | No ABAC support       | Check in route logic             |
| **No permission negation**     | Can't explicitly deny | Full control via roles           |
| **Single tenant**              | No org-level RBAC     | Would need multi-tenant refactor |

---

## 13. Scalability Considerations

### Current Design Handles

-   **Users**: Thousands (tested pattern)
-   **Roles**: Tens (recommended max 15-20)
-   **Permissions**: Hundreds (one per resource:action)
-   **Role assignments**: Linear with users
-   **Direct permissions**: Should be rare (< 5% of users)

### Future Optimizations (If Needed)

1. **Permission Caching**

    - Cache user's effective permissions in Redis
    - Invalidate on role/permission change
    - TTL for automatic refresh

2. **Denormalization**

    - Store computed permissions in user table
    - Update via triggers/events
    - Trade storage for speed

3. **Permission Groups**
    - Group related permissions
    - Assign groups to roles
    - Reduce role_permissions rows

---

## Summary

### Key Takeaways

1. **RBAC centralizes access control** - Permissions on roles, roles on users
2. **Hybrid allows exceptions** - Direct permissions for edge cases
3. **Inheritance reduces duplication** - Base roles shared across hierarchy
4. **Separation of concerns** - Each component has one job
5. **Security in layers** - Auth → Status → RBAC → Ownership

### Architecture Principles Applied

| Principle                  | Application                               |
| -------------------------- | ----------------------------------------- |
| **Single Responsibility**  | Each component does one thing             |
| **Open/Closed**            | Add new permissions without changing code |
| **DRY**                    | Permissions defined once in registry      |
| **Separation of Concerns** | Routes, services, models isolated         |
| **Defense in Depth**       | Multiple security layers                  |

---

> **Next:** [5.9 RBAC Implementation](./5.9_rbac_implementation.md) - See how these concepts are implemented in code
