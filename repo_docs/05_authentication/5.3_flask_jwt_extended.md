# ðŸ§© Flask-JWT-Extended

> **Setting Up and Configuring JWT Authentication**

---

## ðŸ“‹ Overview

**Flask-JWT-Extended** is the library we use for JWT authentication. It provides:

-   Token creation and verification
-   Decorators for protecting routes
-   Token refresh mechanism
-   Blacklisting (token revocation)
-   Custom claims

---

## ðŸ“¦ Installation

```bash
pip install flask-jwt-extended
```

---

## ðŸ”§ Our Configuration

### In `config.py`

```python
from datetime import timedelta

class Config:
    # JWT Secret Key (NEVER commit this!)
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or 'dev-secret-change-me'

    # Token expiration times
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=15)
    JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)

    # Where to look for tokens
    JWT_TOKEN_LOCATION = ['headers']
    JWT_HEADER_NAME = 'Authorization'
    JWT_HEADER_TYPE = 'Bearer'
```

### Environment Variables

```env
# .env
JWT_SECRET_KEY=your-super-secret-key-at-least-32-characters
JWT_ACCESS_TOKEN_EXPIRES=900        # 15 minutes in seconds
JWT_REFRESH_TOKEN_EXPIRES=2592000   # 30 days in seconds
```

---

## ðŸ“ Our JWT Setup (`app/auth/__init__.py`)

### Initialize JWT Manager

```python
from flask_jwt_extended import JWTManager

# Create manager instance (without app)
jwt = JWTManager()


def init_jwt(app: Flask) -> None:
    """Initialize JWT with the Flask app."""

    # Set default config values
    app.config.setdefault("JWT_SECRET_KEY", app.config.get("SECRET_KEY"))
    app.config.setdefault("JWT_ACCESS_TOKEN_EXPIRES", timedelta(minutes=15))
    app.config.setdefault("JWT_REFRESH_TOKEN_EXPIRES", timedelta(days=30))

    # Initialize the extension
    jwt.init_app(app)

    # Register callbacks (see below)
```

### User Identity Callbacks

These callbacks tell Flask-JWT-Extended how to work with our User model:

```python
@jwt.user_identity_loader
def user_identity_lookup(user):
    """
    Convert User object to identity for token.

    Called when creating a token.
    Returns what to store in the 'sub' claim.
    """
    if isinstance(user, User):
        return user.id  # Store user ID in token
    return user


@jwt.user_lookup_loader
def user_lookup_callback(_jwt_header, jwt_data):
    """
    Load User from database using token identity.

    Called on each request to a protected route.
    Returns User object for get_current_user().
    """
    identity = jwt_data["sub"]  # Get user ID from token
    return User.query.filter_by(id=identity, is_deleted=False).first()
```

### Token Blacklist Callback

```python
# In-memory blacklist (use Redis in production!)
_token_blacklist = set()


@jwt.token_in_blocklist_loader
def check_if_token_revoked(jwt_header, jwt_payload):
    """
    Check if token has been revoked (logged out).

    Called on every request to protected endpoint.
    """
    jti = jwt_payload["jti"]  # JWT ID
    return jti in _token_blacklist


def revoke_token(jti: str) -> None:
    """Add a token to the blacklist."""
    _token_blacklist.add(jti)
```

---

## ðŸ›¡ï¸ JWT Error Handlers

We customize error responses to match our standard format:

```python
@jwt.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    """Handle expired tokens."""
    return error_response(
        code=ErrorCode.TOKEN_EXPIRED,
        message="Token has expired",
        status_code=401,
    )


@jwt.invalid_token_loader
def invalid_token_callback(error):
    """Handle invalid tokens."""
    return error_response(
        code=ErrorCode.TOKEN_INVALID,
        message="Invalid token",
        status_code=401,
    )


@jwt.unauthorized_loader
def missing_token_callback(error):
    """Handle missing tokens."""
    return error_response(
        code=ErrorCode.UNAUTHORIZED,
        message="Authorization token required",
        status_code=401,
    )


@jwt.revoked_token_loader
def revoked_token_callback(jwt_header, jwt_payload):
    """Handle revoked (blacklisted) tokens."""
    return error_response(
        code=ErrorCode.TOKEN_INVALID,
        message="Token has been revoked",
        status_code=401,
    )
```

---

## ðŸ”‘ Creating Tokens

Our helper function for creating both tokens:

```python
from flask_jwt_extended import create_access_token, create_refresh_token


def create_tokens(user: User) -> Dict[str, str]:
    """
    Create access and refresh tokens for a user.

    Args:
        user: The User object

    Returns:
        Dict with 'access_token', 'refresh_token', 'token_type'
    """
    # Add custom claims (stored in token payload)
    additional_claims = {
        "username": user.username,
        "email": user.email,
    }

    access_token = create_access_token(
        identity=user,                    # Will be converted to user.id
        additional_claims=additional_claims,
    )

    refresh_token = create_refresh_token(identity=user)

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "Bearer",
    }
```

---

## ðŸ‘¤ Getting Current User

Two ways to get the current user in protected routes:

```python
from flask_jwt_extended import current_user, get_jwt_identity


def get_current_user() -> Optional[User]:
    """
    Get the current authenticated User object.

    Requires @jwt_required() decorator on the route.
    Hits the database (uses user_lookup_callback).
    """
    return current_user  # User object or None


def get_current_user_id() -> Optional[int]:
    """
    Get the current user's ID.

    Faster - doesn't hit the database!
    Just reads from the token payload.
    """
    try:
        return get_jwt_identity()  # User ID from 'sub' claim
    except Exception:
        return None
```

---

## ðŸ†š Express.js Comparison

### Express.js with Passport.js

```javascript
// passport.js setup
const JwtStrategy = require("passport-jwt").Strategy;

passport.use(
    new JwtStrategy(
        {
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            secretOrKey: process.env.JWT_SECRET,
        },
        async (payload, done) => {
            const user = await User.findById(payload.sub);
            if (!user) return done(null, false);
            return done(null, user);
        }
    )
);

// Protected route
app.get("/protected", passport.authenticate("jwt"), (req, res) => {
    res.json({ user: req.user });
});
```

### Flask with Flask-JWT-Extended

```python
# Callbacks handle user loading automatically

@app.route('/protected')
@jwt_required()
def protected():
    user = get_current_user()  # User loaded automatically
    return {'user': user.to_dict()}
```

**Flask-JWT-Extended is simpler** - callbacks are set up once, then routes just use decorators.

---

## ðŸ“Š Initialization Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 JWT INITIALIZATION FLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   1. app/__init__.py                                             â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                           â”‚
â”‚      from app.auth import init_jwt                               â”‚
â”‚                                                                  â”‚
â”‚      def create_app():                                           â”‚
â”‚          app = OpenAPI(__name__)                                 â”‚
â”‚          ...                                                     â”‚
â”‚          init_jwt(app)  â† Called here                            â”‚
â”‚          ...                                                     â”‚
â”‚                                                                  â”‚
â”‚   2. app/auth/__init__.py                                        â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚      def init_jwt(app):                                          â”‚
â”‚          jwt.init_app(app)  â† Connect to Flask                   â”‚
â”‚                                                                  â”‚
â”‚          @jwt.user_identity_loader   â† Register callbacks        â”‚
â”‚          @jwt.user_lookup_loader                                 â”‚
â”‚          @jwt.token_in_blocklist_loader                          â”‚
â”‚          @jwt.expired_token_loader                               â”‚
â”‚          ...                                                     â”‚
â”‚                                                                  â”‚
â”‚   3. Ready!                                                      â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚      @jwt_required() now works on any route                      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš ï¸ Production Considerations

### 1. Use Strong Secret Key

```python
# âŒ BAD
JWT_SECRET_KEY = "secret"

# âœ… GOOD - Generate with:
# python -c "import secrets; print(secrets.token_hex(32))"
JWT_SECRET_KEY = "a1b2c3d4e5f6..."  # 64+ hex characters
```

### 2. Use Redis for Blacklist

```python
# Development (in-memory) - DON'T use in production
_token_blacklist = set()

# Production (Redis)
import redis
redis_client = redis.Redis()

def revoke_token(jti: str, exp: int) -> None:
    """Revoke token with automatic expiration."""
    ttl = exp - int(time.time())  # Time until token expires anyway
    redis_client.setex(f"blacklist:{jti}", ttl, "true")

def is_token_revoked(jti: str) -> bool:
    return redis_client.exists(f"blacklist:{jti}")
```

### 3. Rotate Refresh Tokens

```python
# On each refresh, issue a NEW refresh token
@auth_bp.post('/refresh')
@jwt_required(refresh=True)
def refresh():
    jti = get_jwt()['jti']
    revoke_token(jti)  # Revoke old refresh token

    user = get_current_user()
    tokens = create_tokens(user)  # New access AND refresh
    return success_response(data=tokens)
```

---

## ðŸ”œ Next Steps

Now let's look at the auth routes in detail.

**Next: [5.4_auth_routes.md](./5.4_auth_routes.md)** - Login, logout, refresh endpoints.
