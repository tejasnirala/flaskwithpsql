# â° Token Lifecycle

> **Expiration, Refresh, and Blacklisting**

---

## ğŸ“‹ Overview

Understanding the token lifecycle is crucial for building secure applications. This document covers:

-   Token expiration timing
-   Refresh flow
-   Token revocation (blacklisting)
-   Production best practices

---

## ğŸ”„ Token Lifecycle Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  COMPLETE TOKEN LIFECYCLE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                      LOGIN                               â”‚   â”‚
â”‚   â”‚                        â”‚                                 â”‚   â”‚
â”‚   â”‚                        â–¼                                 â”‚   â”‚
â”‚   â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚   â”‚
â”‚   â”‚              â”‚ Issue Tokens    â”‚                         â”‚   â”‚
â”‚   â”‚              â”‚ â€¢ Access (15m)  â”‚                         â”‚   â”‚
â”‚   â”‚              â”‚ â€¢ Refresh (30d) â”‚                         â”‚   â”‚
â”‚   â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                  ACTIVE SESSION                           â”‚   â”‚
â”‚   â”‚                                                           â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚   â”‚   â”‚                                                    â”‚  â”‚   â”‚
â”‚   â”‚   â”‚   Access Token (15 min)                            â”‚  â”‚   â”‚
â”‚   â”‚   â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                             â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                                                    â”‚  â”‚   â”‚
â”‚   â”‚   â”‚   [API Call] â”€â–¶ Valid? â”€â–¶ [Response]               â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                   â”‚                                â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                   â””â”€ Expired? â”€â–¶ 401 TOKEN_EXPIRED â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                                                    â”‚  â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚   â”‚                            â”‚                              â”‚   â”‚
â”‚   â”‚                   Token expired?                          â”‚   â”‚
â”‚   â”‚                            â”‚                              â”‚   â”‚
â”‚   â”‚                            â–¼                              â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚   â”‚   â”‚                                                    â”‚  â”‚   â”‚
â”‚   â”‚   â”‚   Refresh Token (30 days)                          â”‚  â”‚   â”‚
â”‚   â”‚   â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                         â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                                                    â”‚  â”‚   â”‚
â”‚   â”‚   â”‚   [/refresh] â”€â–¶ Valid? â”€â–¶ New access + refresh     â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                   â”‚                                â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                   â””â”€ Expired? â”€â–¶ Redirect to login â”‚  â”‚   â”‚
â”‚   â”‚   â”‚                                                    â”‚  â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚   â”‚                                                           â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                      LOGOUT                                â”‚   â”‚
â”‚   â”‚                        â”‚                                   â”‚   â”‚
â”‚   â”‚                        â–¼                                   â”‚   â”‚
â”‚   â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚   â”‚
â”‚   â”‚              â”‚ Blacklist Token â”‚                           â”‚   â”‚
â”‚   â”‚              â”‚ (Add JTI to     â”‚                           â”‚   â”‚
â”‚   â”‚              â”‚  blocklist)     â”‚                           â”‚   â”‚
â”‚   â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚   â”‚
â”‚   â”‚                                                            â”‚   â”‚
â”‚   â”‚   Token can no longer be used, even if not expired         â”‚   â”‚
â”‚   â”‚                                                            â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## â±ï¸ Token Expiration

### Configuration

```python
# config.py
from datetime import timedelta

class Config:
    # Access token: Short-lived for security
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=15)

    # Refresh token: Long-lived for convenience
    JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)
```

### Why These Durations?

| Token       | Duration | Reason                                                               |
| ----------- | -------- | -------------------------------------------------------------------- |
| **Access**  | 15 min   | If stolen, damage is limited. Frequent validation against blacklist. |
| **Refresh** | 30 days  | User doesn't have to log in every day. Stored more securely.         |

### Expiration Check

When a request comes in:

```python
@jwt.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    """Called when token has expired."""
    return error_response(
        code=ErrorCode.TOKEN_EXPIRED,
        message="Token has expired",
        status_code=401,
    )
```

---

## ğŸ”„ Refresh Flow

### When to Refresh

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLIENT-SIDE REFRESH LOGIC                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   1. Make API request with access token                          â”‚
â”‚   2. If 401 TOKEN_EXPIRED:                                       â”‚
â”‚      a. Call /refresh with refresh token                         â”‚
â”‚      b. Get new access token                                     â”‚
â”‚      c. Retry original request                                   â”‚
â”‚   3. If /refresh also fails:                                     â”‚
â”‚      â†’ Redirect to login                                         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### JavaScript Implementation

```javascript
async function apiRequest(url, options = {}) {
    const accessToken = getAccessToken();

    // Make request with access token
    let response = await fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            Authorization: `Bearer ${accessToken}`,
        },
    });

    // If token expired, try to refresh
    if (response.status === 401) {
        const errorData = await response.json();

        if (errorData.error?.code === "TOKEN_EXPIRED") {
            const refreshed = await refreshToken();

            if (refreshed) {
                // Retry with new token
                const newToken = getAccessToken();
                response = await fetch(url, {
                    ...options,
                    headers: {
                        ...options.headers,
                        Authorization: `Bearer ${newToken}`,
                    },
                });
            } else {
                // Refresh failed - need to login again
                window.location.href = "/login";
                return null;
            }
        }
    }

    return response;
}

async function refreshToken() {
    const refreshToken = getRefreshToken();

    try {
        const response = await fetch("/api/v1/auth/refresh", {
            method: "POST",
            headers: {
                Authorization: `Bearer ${refreshToken}`,
            },
        });

        if (response.ok) {
            const data = await response.json();
            // Store new tokens
            setAccessToken(data.data.access_token);
            setRefreshToken(data.data.refresh_token);
            return true;
        }
    } catch (error) {
        console.error("Token refresh failed:", error);
    }

    return false;
}
```

### Axios Interceptor Version

```javascript
import axios from "axios";

// Request interceptor - add token
axios.interceptors.request.use((config) => {
    const token = getAccessToken();
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// Response interceptor - handle 401
axios.interceptors.response.use(
    (response) => response,
    async (error) => {
        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;

            const refreshed = await refreshToken();
            if (refreshed) {
                return axios(originalRequest);
            }
        }

        return Promise.reject(error);
    }
);
```

---

## ğŸš« Token Blacklisting (Revocation)

### Why Blacklist?

JWTs are **stateless** - the server doesn't track them. This is a problem when:

-   User logs out (token should be invalid)
-   Password is changed (all tokens should be invalid)
-   Account is compromised (revoke all tokens)

### Our Implementation

```python
# In-memory blacklist (development only!)
_token_blacklist = set()


def revoke_token(jti: str) -> None:
    """Add a token to the blacklist."""
    _token_blacklist.add(jti)


@jwt.token_in_blocklist_loader
def check_if_token_revoked(jwt_header, jwt_payload):
    """Check if token is blacklisted."""
    jti = jwt_payload["jti"]  # JWT ID - unique per token
    return jti in _token_blacklist
```

### Logout Handler

```python
@auth_bp.post('/logout')
@jwt_required()
def logout():
    """Revoke the current access token."""
    jti = get_jwt()["jti"]  # Get token's unique ID
    revoke_token(jti)
    return success_response(message="Logout successful")
```

---

## ğŸ­ Production Blacklist with Redis

In-memory blacklist is lost when server restarts. Use Redis for production:

```python
import redis
import time

redis_client = redis.Redis(host='localhost', port=6379, db=0)


def revoke_token(jti: str, exp: int) -> None:
    """
    Blacklist a token in Redis with automatic expiration.

    Args:
        jti: JWT ID (unique token identifier)
        exp: Token expiration timestamp
    """
    # Calculate TTL - how long until token expires anyway
    ttl = exp - int(time.time())

    if ttl > 0:
        # Store until token would naturally expire
        redis_client.setex(f"blacklist:{jti}", ttl, "true")


def is_token_revoked(jti: str) -> bool:
    """Check if token is blacklisted."""
    return redis_client.exists(f"blacklist:{jti}") > 0


# Updated callback
@jwt.token_in_blocklist_loader
def check_if_token_revoked(jwt_header, jwt_payload):
    jti = jwt_payload["jti"]
    return is_token_revoked(jti)


# Updated logout
@auth_bp.post('/logout')
@jwt_required()
def logout():
    jwt_data = get_jwt()
    jti = jwt_data["jti"]
    exp = jwt_data["exp"]
    revoke_token(jti, exp)
    return success_response(message="Logout successful")
```

### Why TTL Matters

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BLACKLIST STORAGE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Without TTL:                                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚   Token expires at T+15min                                       â”‚
â”‚   Blacklist entry stored forever                                 â”‚
â”‚   â†’ Blacklist grows infinitely! ğŸ’¥                               â”‚
â”‚                                                                  â”‚
â”‚   With TTL:                                                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     â”‚
â”‚   Token expires at T+15min                                       â”‚
â”‚   Blacklist entry expires at T+15min                             â”‚
â”‚   â†’ Blacklist stays small! âœ…                                    â”‚
â”‚                                                                  â”‚
â”‚   Why this works:                                                â”‚
â”‚   After expiration, we don't need to blacklist -                 â”‚
â”‚   the token is already invalid due to expiration!                â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ Token Rotation

For extra security, rotate refresh tokens on each use:

```python
@auth_bp.post('/refresh')
@jwt_required(refresh=True)
def refresh():
    """Get new tokens and revoke old refresh token."""

    # Revoke the old refresh token
    jwt_data = get_jwt()
    old_jti = jwt_data["jti"]
    old_exp = jwt_data["exp"]
    revoke_token(old_jti, old_exp)

    # Issue new tokens
    user = get_current_user()
    tokens = create_tokens(user)

    return success_response(data=tokens)
```

**Benefits:**

-   If refresh token is stolen, it becomes invalid after one use
-   Attacker can only use it once before owner's next refresh
-   Owner notices when their session is invalidated

---

## ğŸ“Š Token Claims Reference

```python
# Access token payload
{
    "sub": 1,                    # User ID (subject)
    "username": "john",          # Custom claim
    "email": "john@example.com", # Custom claim
    "iat": 1700000000,           # Issued at (Unix timestamp)
    "exp": 1700000900,           # Expires at (iat + 15min)
    "jti": "abc-123-def",        # Unique token ID
    "type": "access",            # Token type
    "fresh": false,              # Is freshly issued?
}

# Refresh token payload
{
    "sub": 1,
    "iat": 1700000000,
    "exp": 1702592000,           # iat + 30 days
    "jti": "xyz-456-uvw",
    "type": "refresh",
}
```

---

## âš ï¸ Security Considerations

### 1. Never Store Tokens in Plain localStorage

```javascript
// âŒ Vulnerable to XSS
localStorage.setItem("access_token", token);

// âœ… Better: HttpOnly cookie for refresh token
// Access token in memory only
```

### 2. Always Use HTTPS

```
âŒ HTTP: Token can be intercepted
âœ… HTTPS: Token is encrypted in transit
```

### 3. Short Access Token Lifetime

```python
# âŒ Too long
JWT_ACCESS_TOKEN_EXPIRES = timedelta(days=7)

# âœ… Reasonable
JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=15)
```

### 4. Revoke on Password Change

```python
def change_password(user, new_password):
    user.set_password(new_password)

    # Revoke all existing tokens for this user
    # (Requires storing token count or using different secret per user)
    db.session.commit()
```

---

## ğŸ”œ Next Steps

Now let's understand password security.

**Next: [5.7_password_security.md](./5.7_password_security.md)** - Secure password hashing and verification.
