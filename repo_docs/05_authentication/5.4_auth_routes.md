# üõ§Ô∏è Auth Routes

> **Login, Logout, Refresh, and Me Endpoints**

---

## üìã Overview

Our authentication routes are in `app/auth/v1/routes.py`. These handle:

| Endpoint                | Method | Description          |
| ----------------------- | ------ | -------------------- |
| `/api/v1/auth/register` | POST   | Create new user      |
| `/api/v1/auth/login`    | POST   | Get tokens           |
| `/api/v1/auth/logout`   | POST   | Revoke token         |
| `/api/v1/auth/refresh`  | POST   | Get new access token |
| `/api/v1/auth/me`       | GET    | Get current user     |

---

## üìÅ File Structure

```
app/auth/
‚îú‚îÄ‚îÄ __init__.py          # JWT setup, create_tokens(), helper functions
‚îî‚îÄ‚îÄ v1/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ routes.py        # Auth endpoints (this file)
```

---

## üìä Auth Endpoints

### 1. POST `/api/v1/auth/register`

Create a new user account.

**Request:**

```bash
curl -X POST http://localhost:5500/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "johndoe",
    "email": "john@example.com",
    "password": "SecurePass123!",
    "first_name": "John",
    "last_name": "Doe"
  }'
```

**Response (201 Created):**

```json
{
    "success": true,
    "data": {
        "id": 1,
        "username": "johndoe",
        "email": "john@example.com",
        "first_name": "John",
        "last_name": "Doe",
        "is_active": true,
        "created_at": "2025-01-13T10:30:00Z"
    },
    "message": "User created successfully"
}
```

**Error (409 Conflict):**

```json
{
    "success": false,
    "error": {
        "code": "RESOURCE_ALREADY_EXISTS",
        "message": "Email already exists"
    }
}
```

---

### 2. POST `/api/v1/auth/login`

Authenticate and get JWT tokens.

**Request:**

```bash
curl -X POST http://localhost:5500/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "john@example.com",
    "password": "SecurePass123!"
  }'
```

**Response (200 OK):**

```json
{
    "success": true,
    "data": {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "Bearer",
        "user": {
            "id": 1,
            "username": "johndoe",
            "email": "john@example.com"
        }
    },
    "message": "Login successful"
}
```

**Error (401 Unauthorized):**

```json
{
    "success": false,
    "error": {
        "code": "INVALID_CREDENTIALS",
        "message": "Invalid password"
    }
}
```

---

### 3. POST `/api/v1/auth/logout`

Revoke the current access token (add to blacklist).

**Request:**

```bash
curl -X POST http://localhost:5500/api/v1/auth/logout \
  -H "Authorization: Bearer <access_token>"
```

**Response (200 OK):**

```json
{
    "success": true,
    "message": "Logout successful"
}
```

**Note:** After logout, the access token cannot be used again.

---

### 4. POST `/api/v1/auth/refresh`

Get a new access token using the refresh token.

**Request:**

```bash
curl -X POST http://localhost:5500/api/v1/auth/refresh \
  -H "Authorization: Bearer <refresh_token>"
```

**Response (200 OK):**

```json
{
    "success": true,
    "data": {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "Bearer"
    },
    "message": "Token refreshed"
}
```

**Important:** Use the **refresh token** here, not the access token!

---

### 5. GET `/api/v1/auth/me`

Get the currently authenticated user's information.

**Request:**

```bash
curl http://localhost:5500/api/v1/auth/me \
  -H "Authorization: Bearer <access_token>"
```

**Response (200 OK):**

```json
{
    "success": true,
    "data": {
        "id": 1,
        "username": "johndoe",
        "email": "john@example.com",
        "first_name": "John",
        "last_name": "Doe",
        "is_active": true,
        "created_at": "2025-01-13T10:30:00Z"
    }
}
```

---

## üìù Route Implementation

### Login Route (Detailed)

```python
@auth_bp_v1.post(
    "/login",
    summary="Login",
    description="Authenticate with email and password to receive JWT tokens.",
    responses={
        200: TokenResponse,
        401: StandardErrorResponse,
        404: StandardErrorResponse,
    },
)
def login(body: LoginRequest):
    """Login and get JWT tokens."""
    try:
        # 1. Authenticate user (service layer)
        user = UserService.authenticate(body.email, body.password)

        # 2. Create tokens
        tokens = create_tokens(user)

        # 3. Format user data
        user_data = UserResponseSchema.model_validate(user).to_dict()

        # 4. Return success response
        return success_response(
            data={
                **tokens,
                "user": user_data,
            },
            message="Login successful",
        )

    except UserNotFoundError:
        return error_response(
            code=ErrorCode.RESOURCE_NOT_FOUND,
            message="User not found",
            status_code=404,
        )
    except InvalidCredentialsError:
        return error_response(
            code=ErrorCode.INVALID_CREDENTIALS,
            message="Invalid password",
            status_code=401,
        )
```

### Logout Route (Detailed)

```python
@auth_bp_v1.post(
    "/logout",
    summary="Logout",
    description="Revoke the current access token.",
    security=[{"jwt": []}],  # Swagger shows lock icon
)
@jwt_required()  # Requires valid access token
def logout():
    """Logout and revoke current token."""

    # 1. Get the JWT ID from the current token
    jti = get_jwt()["jti"]

    # 2. Add to blacklist
    revoke_token(jti)

    # 3. Return success
    return success_response(message="Logout successful")
```

### Refresh Route (Detailed)

```python
@auth_bp_v1.post(
    "/refresh",
    summary="Refresh Token",
    security=[{"jwt": []}],
)
@jwt_required(refresh=True)  # ‚Üê Note: refresh=True!
def refresh():
    """Get new access token using refresh token."""

    # 1. Get current user from refresh token
    user = get_current_user()
    if not user:
        return error_response(
            code=ErrorCode.UNAUTHORIZED,
            message="User not found",
            status_code=401,
        )

    # 2. Create new tokens
    tokens = create_tokens(user)

    # 3. Return new tokens
    return success_response(
        data=tokens,
        message="Token refreshed",
    )
```

---

## üìä Request Schemas

### LoginRequest

```python
from pydantic import BaseModel, EmailStr, Field


class LoginRequest(BaseModel):
    """Login request body."""

    email: EmailStr = Field(..., description="User's email address")
    password: str = Field(..., min_length=1, description="User's password")
```

### Response Schemas

```python
class TokenResponse(StandardSuccessResponse):
    """Token response schema."""

    class TokenData(BaseModel):
        access_token: str
        refresh_token: str
        token_type: str = "Bearer"
        user: Optional[Dict[str, Any]] = None

    data: Optional[TokenData] = None
```

---

## üîÑ Complete Auth Flow Example

```javascript
// 1. Register
const registerResponse = await fetch("/api/v1/auth/register", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
        username: "johndoe",
        email: "john@example.com",
        password: "SecurePass123!",
        first_name: "John",
    }),
});

// 2. Login
const loginResponse = await fetch("/api/v1/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
        email: "john@example.com",
        password: "SecurePass123!",
    }),
});
const {
    data: { access_token, refresh_token },
} = await loginResponse.json();

// 3. Use access token for API requests
const meResponse = await fetch("/api/v1/auth/me", {
    headers: { Authorization: `Bearer ${access_token}` },
});

// 4. When token expires, refresh
const refreshResponse = await fetch("/api/v1/auth/refresh", {
    method: "POST",
    headers: { Authorization: `Bearer ${refresh_token}` },
});
const newTokens = await refreshResponse.json();

// 5. Logout
await fetch("/api/v1/auth/logout", {
    method: "POST",
    headers: { Authorization: `Bearer ${access_token}` },
});
```

---

## üÜö Express.js Comparison

### Express.js

```javascript
router.post("/login", async (req, res) => {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ error: "User not found" });

    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) return res.status(401).json({ error: "Invalid password" });

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET);
    res.json({ token });
});
```

### Flask

```python
@auth_bp.post('/login')
def login(body: LoginRequest):
    try:
        user = UserService.authenticate(body.email, body.password)
        tokens = create_tokens(user)
        return success_response(data=tokens)
    except InvalidCredentialsError:
        return error_response(message="Invalid password", status_code=401)
```

**Flask version is cleaner** thanks to:

-   Pydantic validation (no manual validation)
-   Service layer (business logic separated)
-   Standardized responses (consistent error format)

---

## üîú Next Steps

Now let's see how to protect routes with JWT.

**Next: [5.5_protecting_routes.md](./5.5_protecting_routes.md)** - Using `@jwt_required()`.
