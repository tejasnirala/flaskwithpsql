# 6.4 Error Classes (Custom Exceptions)

> **Designing Exception Hierarchies for Clean Error Handling**

This document explains how we design and use custom exception classes in the Flask application. We'll cover why custom exceptions are important, how to design them, and how they flow from services to HTTP responses.

---

## Table of Contents

1. [Why Custom Exceptions?](#why-custom-exceptions)
2. [Exception Design Principles](#exception-design-principles)
3. [Exception Hierarchies](#exception-hierarchies)
4. [Our Custom Exceptions](#our-custom-exceptions)
5. [Exception to HTTP Mapping](#exception-to-http-mapping)
6. [Best Practices](#best-practices)
7. [Testing Exceptions](#testing-exceptions)

---

## Why Custom Exceptions?

### The Problem with Generic Exceptions

```python
# ❌ BAD: Using generic exceptions or strings

def create_user(data):
    if User.query.filter_by(email=data.email).first():
        raise Exception("User already exists")  # What kind of error is this?

    if not is_valid_email(data.email):
        raise ValueError("Invalid email")  # Hard to distinguish from other ValueErrors

    # ...
```

**Problems:**

| Issue              | Description                                      |
| ------------------ | ------------------------------------------------ |
| **Ambiguous**      | Can't tell what kind of error occurred           |
| **Hard to handle** | Catching `Exception` catches everything          |
| **No context**     | Just a string message, no structured data        |
| **Inconsistent**   | Different parts of code use different approaches |

### The Solution: Custom Exceptions

```python
# ✅ GOOD: Using custom exceptions

class UserAlreadyExistsError(UserServiceError):
    def __init__(self, field: str, value: str):
        self.field = field
        self.value = value
        super().__init__(f"User with {field}='{value}' already exists")

def create_user(data):
    if User.query.filter_by(email=data.email).first():
        raise UserAlreadyExistsError("email", data.email)
```

**Benefits:**

| Benefit        | Description                                      |
| -------------- | ------------------------------------------------ |
| **Specific**   | Clear what kind of error occurred                |
| **Catchable**  | Can catch specific exception types               |
| **Contextual** | Exception carries structured data (field, value) |
| **Documented** | Exception names are self-documenting             |
| **Consistent** | Same error type across entire application        |

---

## Exception Design Principles

### 1. Hierarchy from General to Specific

```
Exception (Python built-in)
└── ApplicationError (your base)
    ├── UserServiceError
    │   ├── UserNotFoundError
    │   ├── UserAlreadyExistsError
    │   └── InvalidCredentialsError
    ├── RBACError
    │   ├── PermissionDeniedError
    │   ├── RoleNotFoundError
    │   └── PermissionNotFoundError
    └── DatabaseError (if needed)
```

**Why?** Allows catching at different granularity:

```python
# Catch specific error
except UserNotFoundError:
    return 404

# Catch any user error
except UserServiceError:
    return 400

# Catch any application error
except ApplicationError:
    return 500
```

### 2. Meaningful Names

Exception names should be:

-   **Descriptive**: Tell what happened
-   **Noun-based**: End with `Error` or `Exception`
-   **Specific**: `UserNotFoundError` not `NotFoundException`

| Bad Name             | Good Name                 |
| -------------------- | ------------------------- |
| `Error`              | `UserNotFoundError`       |
| `NotFoundException`  | `UserNotFoundError`       |
| `DuplicateException` | `UserAlreadyExistsError`  |
| `AuthError`          | `InvalidCredentialsError` |

### 3. Carry Context

Exceptions should carry information for:

-   Logging
-   Error messages
-   Debugging

```python
class UserAlreadyExistsError(UserServiceError):
    """
    Carry context about which field caused the conflict.
    """
    def __init__(self, field: str, value: str):
        self.field = field      # "username" or "email"
        self.value = value      # The duplicate value
        super().__init__(f"User with {field}='{value}' already exists")

# Usage in route:
except UserAlreadyExistsError as e:
    logger.warning(f"Duplicate {e.field}: {e.value}")
    return error_response(
        code=ErrorCode.RESOURCE_ALREADY_EXISTS,
        message=f"{e.field.title()} already exists",
        details={"field": e.field}
    )
```

---

## Exception Hierarchies

### User Service Exceptions

```python
# app/services/user_service.py

class UserServiceError(Exception):
    """
    Base exception for user service errors.

    All user-related business logic errors inherit from this.
    Allows catching any user error with one except clause.
    """
    pass


class UserNotFoundError(UserServiceError):
    """
    Raised when a user lookup fails.

    Maps to: HTTP 404 Not Found
    """
    pass


class UserAlreadyExistsError(UserServiceError):
    """
    Raised when trying to create a user with duplicate username/email.

    Maps to: HTTP 409 Conflict

    Attributes:
        field: The field that caused the conflict ('username' or 'email')
        value: The duplicate value
    """
    def __init__(self, field: str, value: str):
        self.field = field
        self.value = value
        super().__init__(f"User with {field}='{value}' already exists")


class InvalidCredentialsError(UserServiceError):
    """
    Raised when authentication fails due to wrong password.

    Maps to: HTTP 401 Unauthorized

    Note: For security, we don't specify whether username or
    password was wrong (prevents user enumeration).
    """
    pass
```

### RBAC Exceptions

```python
# app/rbac/exceptions.py

class RBACError(Exception):
    """
    Base exception for RBAC (Role-Based Access Control) errors.

    Attributes:
        message: Human-readable error message
        code: Machine-readable error code (optional)
    """
    def __init__(self, message: str, code: str = "RBAC_ERROR"):
        self.message = message
        self.code = code
        super().__init__(message)


class PermissionDeniedError(RBACError):
    """
    Raised when user lacks required permission.

    Maps to: HTTP 403 Forbidden

    Attributes:
        required_permissions: List of permissions that were required
    """
    def __init__(
        self,
        message: str = "Permission denied",
        required_permissions: list = None
    ):
        self.required_permissions = required_permissions or []
        super().__init__(message, code="PERMISSION_DENIED")


class RoleNotFoundError(RBACError):
    """
    Raised when a role lookup fails.

    Maps to: HTTP 404 Not Found
    """
    def __init__(
        self,
        message: str = "Role not found",
        role_name: str = None,
        role_id: int = None
    ):
        self.role_name = role_name
        self.role_id = role_id
        super().__init__(message, code="ROLE_NOT_FOUND")


class PermissionNotFoundError(RBACError):
    """
    Raised when a permission lookup fails.

    Maps to: HTTP 404 Not Found
    """
    def __init__(
        self,
        message: str = "Permission not found",
        permission_name: str = None
    ):
        self.permission_name = permission_name
        super().__init__(message, code="PERMISSION_NOT_FOUND")


class RoleAssignmentError(RBACError):
    """
    Raised when role assignment/revocation fails.

    Maps to: HTTP 400 Bad Request
    """
    def __init__(
        self,
        message: str,
        user_id: int = None,
        role_name: str = None
    ):
        self.user_id = user_id
        self.role_name = role_name
        super().__init__(message, code="ROLE_ASSIGNMENT_ERROR")


class SystemRoleError(RBACError):
    """
    Raised when trying to modify a protected system role.

    Maps to: HTTP 403 Forbidden
    """
    def __init__(self, message: str, role_name: str = None):
        self.role_name = role_name
        super().__init__(message, code="SYSTEM_ROLE_ERROR")


class DirectPermissionError(RBACError):
    """
    Raised when direct permission assignment fails.

    Maps to: HTTP 400 Bad Request
    """
    def __init__(
        self,
        message: str,
        user_id: int = None,
        permission_name: str = None
    ):
        self.user_id = user_id
        self.permission_name = permission_name
        super().__init__(message, code="DIRECT_PERMISSION_ERROR")
```

---

## Our Custom Exceptions

### Exception Overview

| Exception                 | Module   | HTTP Code | Description                  |
| ------------------------- | -------- | --------- | ---------------------------- |
| `UserServiceError`        | services | 500       | Base for user errors         |
| `UserNotFoundError`       | services | 404       | User doesn't exist           |
| `UserAlreadyExistsError`  | services | 409       | Duplicate username/email     |
| `InvalidCredentialsError` | services | 401       | Wrong password               |
| `RBACError`               | rbac     | 500       | Base for RBAC errors         |
| `PermissionDeniedError`   | rbac     | 403       | Lacks permission             |
| `RoleNotFoundError`       | rbac     | 404       | Role doesn't exist           |
| `PermissionNotFoundError` | rbac     | 404       | Permission doesn't exist     |
| `RoleAssignmentError`     | rbac     | 400       | Role assignment failed       |
| `SystemRoleError`         | rbac     | 403       | Can't modify system role     |
| `DirectPermissionError`   | rbac     | 400       | Permission assignment failed |

### Exception Attributes

```python
# UserAlreadyExistsError - carries field and value
e.field  # "email" or "username"
e.value  # "john@example.com"

# RoleNotFoundError - carries role identifier
e.role_name  # "admin" or None
e.role_id    # 5 or None

# PermissionDeniedError - carries required permissions
e.required_permissions  # ["users:read", "users:write"]

# All RBAC errors - have code and message
e.message  # "Permission denied"
e.code     # "PERMISSION_DENIED"
```

---

## Exception to HTTP Mapping

### Global Error Handlers

Flask's error handlers catch exceptions and convert them to HTTP responses:

```python
# app/utils/error_handlers.py

from app.utils.responses import error_response, ErrorCode

def register_error_handlers(app: Flask) -> None:
    """Register all global error handlers."""

    # =========================================================================
    # User Service Errors
    # =========================================================================

    @app.errorhandler(UserNotFoundError)
    def handle_user_not_found(error: UserNotFoundError):
        logger.info(f"User not found: {error}")
        return error_response(
            code=ErrorCode.RESOURCE_NOT_FOUND,
            message=str(error),
            status_code=404
        )

    @app.errorhandler(UserAlreadyExistsError)
    def handle_user_exists(error: UserAlreadyExistsError):
        logger.warning(f"User already exists: {error.field}={error.value}")
        return error_response(
            code=ErrorCode.RESOURCE_ALREADY_EXISTS,
            message=f"{error.field.title()} already exists",
            details={"field": error.field},
            status_code=409
        )

    # =========================================================================
    # RBAC Errors
    # =========================================================================

    @app.errorhandler(PermissionDeniedError)
    def handle_permission_denied(error: PermissionDeniedError):
        logger.warning(
            f"Permission denied: {error.message}",
            extra={"required_permissions": error.required_permissions}
        )
        return error_response(
            code=ErrorCode.FORBIDDEN,
            message=error.message,
            details={"required_permissions": error.required_permissions}
                if error.required_permissions else None,
            status_code=403
        )
```

### Exception Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Service Layer                                                            │
│                                                                          │
│ def create_user(data):                                                   │
│     if User.query.filter_by(email=data.email).first():                  │
│         raise UserAlreadyExistsError("email", data.email)  ◄──────────── │
│                                                            Exception    │
│                                                            raised       │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ Route Layer                                                              │
│                                                                          │
│ @users_bp.post("/register")                                             │
│ def register_user(body: UserCreateSchema):                              │
│     try:                                                                 │
│         user = UserService.create_user(body)                            │
│         return success_response(...)                                    │
│     except UserAlreadyExistsError as e:  ◄───────────────────────────── │
│         return error_response(                        Exception caught  │
│             code=ErrorCode.RESOURCE_ALREADY_EXISTS,                     │
│             message=f"{e.field.title()} already exists",                │
│             status_code=409                                             │
│         )                                                                │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ HTTP Response                                                            │
│                                                                          │
│ 409 Conflict                                                             │
│ {                                                                        │
│   "success": false,                                                      │
│   "data": null,                                                          │
│   "error": {                                                             │
│     "code": "RESOURCE_ALREADY_EXISTS",                                   │
│     "message": "Email already exists",                                   │
│     "details": {"field": "email"}                                        │
│   },                                                                     │
│   "meta": null                                                           │
│ }                                                                        │
└─────────────────────────────────────────────────────────────────────────┘
```

### Mapping Table

| Exception                 | ErrorCode                 | HTTP Status | Response Message            |
| ------------------------- | ------------------------- | ----------- | --------------------------- |
| `UserNotFoundError`       | `RESOURCE_NOT_FOUND`      | 404         | "User not found"            |
| `UserAlreadyExistsError`  | `RESOURCE_ALREADY_EXISTS` | 409         | "{field} already exists"    |
| `InvalidCredentialsError` | `INVALID_CREDENTIALS`     | 401         | "Invalid email or password" |
| `PermissionDeniedError`   | `FORBIDDEN`               | 403         | "Permission denied"         |
| `RoleNotFoundError`       | `RESOURCE_NOT_FOUND`      | 404         | "Role not found"            |
| `RoleAssignmentError`     | `BAD_REQUEST`             | 400         | (dynamic message)           |
| `SystemRoleError`         | `FORBIDDEN`               | 403         | "Cannot modify system role" |

---

## Best Practices

### 1. Use Specific Exceptions

```python
# ❌ BAD: Reusing generic exceptions
raise ValueError("User not found")
raise Exception("Duplicate email")

# ✅ GOOD: Using specific exceptions
raise UserNotFoundError(f"User with id={user_id} not found")
raise UserAlreadyExistsError("email", data.email)
```

### 2. Include Context in Exceptions

```python
# ❌ BAD: No context
raise UserNotFoundError()

# ✅ GOOD: Include identifying information
raise UserNotFoundError(f"User with id={user_id} not found")

# ✅ BETTER: Structured context
class UserNotFoundError(UserServiceError):
    def __init__(self, user_id: int = None, email: str = None):
        self.user_id = user_id
        self.email = email
        if user_id:
            msg = f"User with id={user_id} not found"
        elif email:
            msg = f"User with email not found"
        else:
            msg = "User not found"
        super().__init__(msg)
```

### 3. Don't Expose Sensitive Information

```python
# ❌ BAD: Exposes email in error
raise UserNotFoundError(f"User with email={email} not found")

# ✅ GOOD: Generic message for auth failures
raise InvalidCredentialsError("Invalid email or password")

# ✅ GOOD: Log detail server-side
logger.warning(f"Auth failed for email: {email}")
raise InvalidCredentialsError("Authentication failed")
```

### 4. Create Base Exception per Module

```python
# app/services/user_service.py
class UserServiceError(Exception):
    """Base for all user service errors."""
    pass

# app/rbac/exceptions.py
class RBACError(Exception):
    """Base for all RBAC errors."""
    pass

# app/payments/exceptions.py (future)
class PaymentError(Exception):
    """Base for all payment errors."""
    pass
```

### 5. Document Exception Behavior

```python
class UserService:
    @staticmethod
    def create_user(data: UserCreateSchema) -> User:
        """
        Create a new user.

        Args:
            data: Validated user creation data

        Returns:
            The newly created User object

        Raises:
            UserAlreadyExistsError: If username or email already exists.
                Contains `field` (str) and `value` (str) attributes.
        """
```

---

## Testing Exceptions

### Testing Exception Raising

```python
import pytest
from app.services.user_service import (
    UserService,
    UserNotFoundError,
    UserAlreadyExistsError,
)


class TestCreateUserExceptions:
    """Test exceptions raised by create_user()."""

    def test_duplicate_username_raises_exception(self, db_session, existing_user):
        """Should raise UserAlreadyExistsError for duplicate username."""
        data = UserCreateSchema(
            username=existing_user.username,  # Duplicate!
            email="new@example.com",
            password="password123"
        )

        with pytest.raises(UserAlreadyExistsError) as exc_info:
            UserService.create_user(data)

        # Check exception attributes
        assert exc_info.value.field == "username"
        assert exc_info.value.value == existing_user.username

    def test_duplicate_email_raises_exception(self, db_session, existing_user):
        """Should raise UserAlreadyExistsError for duplicate email."""
        data = UserCreateSchema(
            username="newuser",
            email=existing_user.email,  # Duplicate!
            password="password123"
        )

        with pytest.raises(UserAlreadyExistsError) as exc_info:
            UserService.create_user(data)

        assert exc_info.value.field == "email"


class TestAuthenticationExceptions:
    """Test authentication exception handling."""

    def test_user_not_found_raises_exception(self, db_session):
        """Should raise UserNotFoundError for unknown email."""
        with pytest.raises(UserNotFoundError):
            UserService.authenticate("unknown@example.com", "password")

    def test_wrong_password_raises_exception(self, db_session, existing_user):
        """Should raise InvalidCredentialsError for wrong password."""
        with pytest.raises(InvalidCredentialsError):
            UserService.authenticate(existing_user.email, "wrong_password")
```

### Testing Exception Messages

```python
def test_exception_message_format(self, db_session, existing_user):
    """Verify exception message format."""
    data = UserCreateSchema(
        username=existing_user.username,
        email="new@example.com",
        password="password123"
    )

    with pytest.raises(UserAlreadyExistsError) as exc_info:
        UserService.create_user(data)

    # Check the string representation
    assert str(exc_info.value) == f"User with username='{existing_user.username}' already exists"
```

### Testing HTTP Response Mapping

```python
def test_duplicate_email_returns_409(self, client, existing_user):
    """API should return 409 Conflict for duplicate email."""
    response = client.post("/api/v1/users/register", json={
        "username": "newuser",
        "email": existing_user.email,  # Duplicate!
        "password": "password123"
    })

    assert response.status_code == 409

    data = response.get_json()
    assert data["success"] is False
    assert data["error"]["code"] == "RESOURCE_ALREADY_EXISTS"
    assert "email" in data["error"]["message"].lower()
```

---

## Summary

### Key Takeaways

1. **Create exception hierarchies** - Base exceptions per module
2. **Use specific names** - `UserNotFoundError` not `NotFoundException`
3. **Carry context** - Store useful attributes (field, value, etc.)
4. **Map to HTTP** - Global handlers convert exceptions to responses
5. **Don't expose secrets** - Log details server-side only
6. **Test thoroughly** - Verify exceptions are raised and messages are correct

### Exception Design Checklist

-   [ ] Does the exception have a meaningful name?
-   [ ] Does it inherit from the appropriate base exception?
-   [ ] Does it carry necessary context for debugging?
-   [ ] Is there a global handler that maps it to HTTP?
-   [ ] Are there tests for the exception?
-   [ ] Is the `__init__` documented with attributes?

---

## Next Steps

-   **[6.5 Dependency Injection](./6.5_dependency_injection.md)** - DI patterns in Python
-   **[4.11 Error Handling](../04_api_design/4.11_error_handling.md)** - Global error handlers
-   **[6.3 User Service](./6.3_user_service.md)** - Service implementation

---

> **Related Documentation:**
>
> -   [app/utils/error_handlers.py](../../app/utils/error_handlers.py) - Global error handlers
> -   [app/services/user_service.py](../../app/services/user_service.py) - User service exceptions
> -   [app/rbac/exceptions.py](../../app/rbac/exceptions.py) - RBAC exceptions
