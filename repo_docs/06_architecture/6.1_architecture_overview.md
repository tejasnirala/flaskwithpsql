# 6.1 Architecture Overview

> **Understanding Clean Architecture Principles in Our Flask Application**

This document explains the architectural patterns and principles used in this Flask application. We'll cover why these patterns matter and how they make the codebase maintainable, testable, and production-ready.

---

## Table of Contents

1. [What is Clean Architecture?](#what-is-clean-architecture)
2. [Why Architecture Matters](#why-architecture-matters)
3. [Our Architecture at a Glance](#our-architecture-at-a-glance)
4. [Layered Architecture](#layered-architecture)
5. [Separation of Concerns](#separation-of-concerns)
6. [Data Flow Through Layers](#data-flow-through-layers)
7. [Directory Structure](#directory-structure)
8. [Key Principles](#key-principles)
9. [Comparison with Express/Node.js](#comparison-with-expressnodejs)

---

## What is Clean Architecture?

### Definition

**Clean Architecture** is a software design philosophy that separates code into distinct layers, each with a specific responsibility. The goal is to create code that is:

-   **Independent of frameworks** - Business logic doesn't depend on Flask specifics
-   **Testable** - Business rules can be tested without UI, database, or external services
-   **Independent of the database** - You can swap PostgreSQL for MongoDB without changing business logic
-   **Independent of external agencies** - Business rules don't know about the outside world

### The Dependency Rule

The fundamental rule of clean architecture:

> **Source code dependencies can only point inward.**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│    ┌───────────────────────────────────────────────────────────────┐    │
│    │                     FRAMEWORKS & DRIVERS                       │    │
│    │            (Flask, SQLAlchemy, External APIs)                  │    │
│    │                                                                │    │
│    │    ┌───────────────────────────────────────────────────────┐   │    │
│    │    │              INTERFACE ADAPTERS                        │   │    │
│    │    │        (Routes, Controllers, Presenters)               │   │    │
│    │    │                                                        │   │    │
│    │    │    ┌───────────────────────────────────────────────┐   │   │    │
│    │    │    │           APPLICATION LAYER                    │   │   │    │
│    │    │    │           (Use Cases, Services)                │   │   │    │
│    │    │    │                                                │   │   │    │
│    │    │    │    ┌───────────────────────────────────────┐   │   │   │    │
│    │    │    │    │         DOMAIN LAYER                   │   │   │   │    │
│    │    │    │    │         (Entities, Models)             │   │   │   │    │
│    │    │    │    │                                        │   │   │   │    │
│    │    │    │    │      ← Business Rules Live Here        │   │   │   │    │
│    │    │    │    └───────────────────────────────────────┘   │   │   │    │
│    │    │    └───────────────────────────────────────────────┘   │   │    │
│    │    └───────────────────────────────────────────────────────┘   │    │
│    └───────────────────────────────────────────────────────────────┘    │
│                                                                         │
│                          Dependencies Point Inward →                    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Why Architecture Matters

### The Problem Without Architecture

Imagine a simple Flask route:

```python
# ❌ BAD: Everything mixed together
@app.route("/users", methods=["POST"])
def create_user():
    data = request.json

    # Validation (inline)
    if not data.get("email"):
        return {"error": "Email required"}, 400

    # Check for duplicates (business logic + DB)
    existing = db.session.query(User).filter_by(email=data["email"]).first()
    if existing:
        return {"error": "Email exists"}, 409

    # Hash password (business logic)
    hashed = bcrypt.hashpw(data["password"].encode(), bcrypt.gensalt())

    # Create user (DB operation)
    user = User(email=data["email"], password_hash=hashed)
    db.session.add(user)
    db.session.commit()

    # Send welcome email (external service)
    send_email(user.email, "Welcome!")

    return {"id": user.id}, 201
```

**Problems:**

| Issue                | Description                                                 |
| -------------------- | ----------------------------------------------------------- |
| **Untestable**       | Can't test business logic without HTTP context              |
| **Hard to reuse**    | Can't use this logic in CLI scripts or background jobs      |
| **Tightly coupled**  | Changing email service requires changing the route          |
| **Hard to maintain** | 50 lines of mixed concerns in one function                  |
| **No separation**    | Validation, business logic, DB, external services all mixed |

### The Solution: Layered Architecture

```python
# ✅ GOOD: Separated concerns

# Route Layer (thin)
@users_bp.post("/register")
def register_user(body: UserCreateSchema):
    try:
        user = UserService.create_user(body)
        return success_response(data=user.to_dict(), status_code=201)
    except UserAlreadyExistsError as e:
        return error_response(code=ErrorCode.RESOURCE_ALREADY_EXISTS, ...)

# Service Layer (business logic)
class UserService:
    @staticmethod
    def create_user(data: UserCreateSchema) -> User:
        # Uniqueness check
        if User.query.filter_by(email=data.email).first():
            raise UserAlreadyExistsError("email", data.email)

        # Create user
        user = User(email=data.email)
        user.set_password(data.password)

        db.session.add(user)
        db.session.commit()
        return user

# Model Layer (data structure)
class User(BaseModel):
    email = db.Column(db.String(255), unique=True)
    password_hash = db.Column(db.String(255))

    def set_password(self, password: str):
        self.password_hash = generate_password_hash(password)
```

**Benefits:**

| Benefit          | Description                                                 |
| ---------------- | ----------------------------------------------------------- |
| **Testable**     | Test `UserService.create_user()` without HTTP               |
| **Reusable**     | Call `UserService.create_user()` from CLI or background job |
| **Maintainable** | Each layer has one responsibility                           |
| **Flexible**     | Swap database or framework without touching business logic  |

---

## Our Architecture at a Glance

Here's how our Flask application is structured:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          HTTP Request                                    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    PRESENTATION LAYER                                    │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                      Routes (Blueprints)                         │    │
│  │                                                                  │    │
│  │  • app/routes/v1/users.py                                       │    │
│  │  • app/routes/v1/main.py                                        │    │
│  │  • app/auth/routes.py                                           │    │
│  │                                                                  │    │
│  │  Responsibilities:                                               │    │
│  │  - Parse HTTP request                                           │    │
│  │  - Validate input (Pydantic)                                    │    │
│  │  - Call service methods                                         │    │
│  │  - Format and return HTTP response                              │    │
│  └─────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    APPLICATION LAYER (Services)                          │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                      Services                                    │    │
│  │                                                                  │    │
│  │  • app/services/user_service.py                                 │    │
│  │                                                                  │    │
│  │  Responsibilities:                                               │    │
│  │  - Business logic                                               │    │
│  │  - Transaction management                                        │    │
│  │  - Orchestration of multiple operations                         │    │
│  │  - Error handling and custom exceptions                         │    │
│  └─────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      DOMAIN LAYER (Models)                               │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                      Models (SQLAlchemy)                         │    │
│  │                                                                  │    │
│  │  • app/models/base.py                                           │    │
│  │  • app/models/user.py                                           │    │
│  │  • app/models/role.py                                           │    │
│  │  • app/models/permission.py                                     │    │
│  │                                                                  │    │
│  │  Responsibilities:                                               │    │
│  │  - Data structure definitions                                   │    │
│  │  - Relationships between entities                               │    │
│  │  - Instance methods for entity operations                       │    │
│  │  - Data validation at model level                               │    │
│  └─────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    INFRASTRUCTURE LAYER                                  │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                      Database (PostgreSQL)                       │    │
│  │                                                                  │    │
│  │  • SQLAlchemy ORM                                               │    │
│  │  • Flask-Migrate for migrations                                 │    │
│  │                                                                  │    │
│  │  Responsibilities:                                               │    │
│  │  - Data persistence                                             │    │
│  │  - Query execution                                              │    │
│  │  - Transaction support                                          │    │
│  └─────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Layered Architecture

### Layer Definitions

| Layer              | Directory             | Purpose                            |
| ------------------ | --------------------- | ---------------------------------- |
| **Presentation**   | `app/routes/`         | HTTP handling, request/response    |
| **Application**    | `app/services/`       | Business logic, use cases          |
| **Domain**         | `app/models/`         | Core entities and business rules   |
| **Infrastructure** | `config.py`, database | External systems (DB, cache, APIs) |
| **Cross-Cutting**  | `app/utils/`          | Logging, error handling, utilities |

### Layer Communication Rules

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       Layer Communication                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Presentation ──────► Application ──────► Domain ──────► Infrastructure │
│     (routes)          (services)        (models)         (db, apis)     │
│                                                                          │
│  Rules:                                                                  │
│  ───────                                                                 │
│  ✓ Routes CAN call Services                                             │
│  ✓ Services CAN call Models                                             │
│  ✓ Services CAN access Database                                         │
│  ✗ Routes CANNOT access Database directly                               │
│  ✗ Models CANNOT call Services                                          │
│  ✗ Routes CANNOT call other Routes                                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Separation of Concerns

### What Each Layer Handles

#### 1. Routes (Presentation Layer)

```python
# app/routes/v1/users.py

@users_bp.post("/register")
def register_user(body: UserCreateSchema):
    """
    Routes handle:
    - HTTP method (POST)
    - URL path (/register)
    - Request parsing (body parameter)
    - Response formatting (success_response)
    - HTTP status codes (201, 409)
    """
    try:
        user = UserService.create_user(body)  # Delegates to service
        return success_response(data=user.to_dict(), status_code=201)
    except UserAlreadyExistsError as e:
        return error_response(
            code=ErrorCode.RESOURCE_ALREADY_EXISTS,
            message=f"{e.field.title()} already exists",
            status_code=409
        )
```

#### 2. Services (Application Layer)

```python
# app/services/user_service.py

class UserService:
    @staticmethod
    def create_user(data: UserCreateSchema) -> User:
        """
        Services handle:
        - Business logic (uniqueness check)
        - Transaction management (commit/rollback)
        - Orchestration (multiple DB operations)
        - Custom exceptions for business errors
        """
        # Business rule: username must be unique
        if User.query.filter_by(username=data.username).first():
            raise UserAlreadyExistsError("username", data.username)

        # Create entity
        user = User(
            username=data.username,
            email=data.email,
        )
        user.set_password(data.password)

        # Transaction
        try:
            db.session.add(user)
            db.session.commit()
            return user
        except Exception:
            db.session.rollback()
            raise
```

#### 3. Models (Domain Layer)

```python
# app/models/user.py

class User(BaseModel):
    """
    Models handle:
    - Data structure (columns)
    - Relationships (foreign keys)
    - Instance-level operations (set_password)
    - Data serialization (to_dict)
    """
    __tablename__ = "users"

    username = db.Column(db.String(50), unique=True)
    email = db.Column(db.String(255), unique=True)
    password_hash = db.Column(db.String(255))

    def set_password(self, password: str) -> None:
        """Hash and set the user's password."""
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        """Verify a password against the hash."""
        return check_password_hash(self.password_hash, password)
```

#### 4. Utils (Cross-Cutting Concerns)

```python
# app/utils/responses.py

def success_response(data, message=None, meta=None, status_code=200):
    """
    Utils handle:
    - Consistent response formatting
    - Error code standardization
    - Logging configuration
    - Request tracking
    """
    response_body = {
        "success": True,
        "data": data,
        "error": None,
        "meta": meta
    }
    return jsonify(response_body), status_code
```

---

## Data Flow Through Layers

### Complete Request Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────┐
│ 1. HTTP Request                                                          │
│    POST /api/v1/users/register                                          │
│    {"username": "john", "email": "john@example.com", "password": "..."}  │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 2. Flask Routing                                                         │
│    - Match URL to blueprint (users_bp)                                   │
│    - Match path to route handler (register_user)                        │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 3. Pydantic Validation (flask-openapi3)                                 │
│    - Parse JSON body                                                     │
│    - Validate against UserCreateSchema                                   │
│    - Return 422 if validation fails                                     │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 4. Route Handler                                                         │
│    - Receive validated data                                              │
│    - Call UserService.create_user(data)                                 │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 5. Service Layer                                                         │
│    - Check business rules (unique username, email)                      │
│    - Create User model instance                                         │
│    - Hash password via user.set_password()                              │
│    - db.session.add(user)                                               │
│    - db.session.commit()                                                │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 6. Database Layer                                                        │
│    - SQLAlchemy executes INSERT                                         │
│    - PostgreSQL stores the record                                        │
│    - User.id is generated                                               │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 7. Return Path                                                           │
│    - Service returns User instance                                       │
│    - Route calls user.to_dict()                                         │
│    - Route returns success_response(data=user_dict, status_code=201)    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ 8. HTTP Response                                                         │
│    201 Created                                                           │
│    {"success": true, "data": {...}, "error": null, "meta": null}        │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

Our directory structure reflects the architecture:

```
app/
├── __init__.py              # Application factory (create_app)
├── extensions.py            # Flask extensions (db, migrate, jwt)
│
├── models/                  # DOMAIN LAYER
│   ├── __init__.py         # Model exports
│   ├── base.py             # BaseModel with common fields
│   ├── user.py             # User entity
│   ├── role.py             # Role entity
│   └── permission.py       # Permission entity
│
├── services/                # APPLICATION LAYER
│   ├── __init__.py         # Service exports and exceptions
│   └── user_service.py     # User business logic
│
├── routes/                  # PRESENTATION LAYER (v1)
│   └── v1/
│       ├── __init__.py     # Version routing
│       ├── main.py         # Health/info endpoints
│       └── users.py        # User endpoints
│
├── auth/                    # AUTH MODULE
│   ├── __init__.py         # Auth blueprint
│   ├── routes.py           # Login/logout/refresh
│   └── utils.py            # JWT utilities
│
├── rbac/                    # RBAC MODULE
│   ├── __init__.py         # RBAC exports
│   ├── decorators.py       # Permission decorators
│   ├── exceptions.py       # RBAC exceptions
│   └── service.py          # RBAC business logic
│
├── schemas/                 # DATA TRANSFER OBJECTS
│   ├── __init__.py         # Schema exports
│   ├── user.py             # User schemas
│   └── auth.py             # Auth schemas
│
└── utils/                   # CROSS-CUTTING CONCERNS
    ├── __init__.py         # Utility exports
    ├── responses.py        # Response helpers
    ├── error_handlers.py   # Global error handlers
    ├── logging_config.py   # Logging setup
    └── rate_limiter.py     # Rate limiting

config.py                    # Configuration classes
run.py                       # Entry point
```

---

## Key Principles

### 1. Single Responsibility Principle (SRP)

Each module/class has one reason to change:

| Component | Responsibility         | Changes When...              |
| --------- | ---------------------- | ---------------------------- |
| Route     | HTTP handling          | API contract changes         |
| Service   | Business logic         | Business rules change        |
| Model     | Data structure         | Database schema changes      |
| Schema    | Validation rules       | Input/output format changes  |
| Utils     | Cross-cutting concerns | Logging/error format changes |

### 2. Don't Repeat Yourself (DRY)

Reusable patterns are centralized:

-   **Response formatting** → `success_response()`, `error_response()`
-   **Error handling** → Global error handlers
-   **Common model fields** → `BaseModel` class
-   **Logging** → Centralized `setup_logging()`

### 3. Dependency Inversion

High-level modules don't depend on low-level details:

```python
# ✅ Good: Route depends on service interface, not implementation
user = UserService.create_user(data)

# ❌ Bad: Route knows about database details
user = User(...)
db.session.add(user)
db.session.commit()
```

---

## Comparison with Express/Node.js

If you're coming from Express.js, here's how concepts map:

| Express/Node.js           | Flask/Python               | Notes                 |
| ------------------------- | -------------------------- | --------------------- |
| `express.Router()`        | `Blueprint`                | Route grouping        |
| `controller.js`           | `routes/users.py`          | Route handlers        |
| `service.js`              | `services/user_service.py` | Business logic        |
| `model.js` (Mongoose)     | `models/user.py`           | Data models           |
| `middleware`              | `@before_request`          | Request preprocessing |
| `express-validator`/`joi` | Pydantic schemas           | Input validation      |
| `response.json()`         | `success_response()`       | JSON responses        |
| `next(err)`               | Raise exception            | Error propagation     |
| `app.use(errorHandler)`   | `@app.errorhandler`        | Global error handling |

---

## Summary

### Key Takeaways

1. **Thin Routes**: Routes only handle HTTP concerns
2. **Fat Services**: Business logic lives in services
3. **Dumb Models**: Models define structure, not logic
4. **Centralized Utils**: Common concerns in one place
5. **Custom Exceptions**: Clear error types for business failures

### Next Steps

-   **[6.2 Service Layer](./6.2_service_layer.md)** - Deep dive into services
-   **[6.3 User Service](./6.3_user_service.md)** - Complete user service walkthrough
-   **[6.4 Error Classes](./6.4_error_classes.md)** - Custom exception patterns

---

> **Related Documentation:**
>
> -   [2.2 App Factory Pattern](../02_flask_fundamentals/2.2_app_factory_pattern.md)
> -   [4.3 Routes Structure](../04_api_design/4.3_routes_structure.md)
> -   [4.11 Error Handling](../04_api_design/4.11_error_handling.md)
