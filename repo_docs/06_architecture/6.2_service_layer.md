# 6.2 Service Layer

> **Separating Business Logic from HTTP Handling**

This document explains the service layer pattern used in our Flask application. We'll cover why services are essential, how they work, and the benefits they bring to your codebase.

---

## Table of Contents

1. [What is the Service Layer?](#what-is-the-service-layer)
2. [Why Not Just Use Routes?](#why-not-just-use-routes)
3. [Service Layer Benefits](#service-layer-benefits)
4. [Our Implementation](#our-implementation)
5. [Service Method Patterns](#service-method-patterns)
6. [Transaction Management](#transaction-management)
7. [Error Handling](#error-handling)
8. [Testing Services](#testing-services)
9. [Best Practices](#best-practices)

---

## What is the Service Layer?

### Definition

The **Service Layer** is a design pattern that introduces a dedicated layer for **business logic** between your HTTP routes (controllers) and your data models (repositories).

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Without Service Layer                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│    HTTP Request                                                          │
│         │                                                                │
│         ▼                                                                │
│    ┌─────────────┐                                                       │
│    │   Route     │  ← Business logic mixed with HTTP handling           │
│    │  Handler    │  ← Validation, DB queries, all in one place          │
│    └──────┬──────┘                                                       │
│           │                                                              │
│           ▼                                                              │
│    ┌─────────────┐                                                       │
│    │   Model     │  ← Just data structure                               │
│    │  (ORM)      │                                                       │
│    └─────────────┘                                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                      With Service Layer                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│    HTTP Request                                                          │
│         │                                                                │
│         ▼                                                                │
│    ┌─────────────┐                                                       │
│    │   Route     │  ← Only HTTP concerns (parse request, format resp)   │
│    │  Handler    │                                                       │
│    └──────┬──────┘                                                       │
│           │                                                              │
│           ▼                                                              │
│    ┌─────────────┐                                                       │
│    │  Service    │  ← Business logic lives here                         │
│    │   Layer     │  ← Validation rules, transactions, orchestration     │
│    └──────┬──────┘                                                       │
│           │                                                              │
│           ▼                                                              │
│    ┌─────────────┐                                                       │
│    │   Model     │  ← Data structure and persistence                    │
│    │  (ORM)      │                                                       │
│    └─────────────┘                                                       │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Key Characteristics

| Characteristic   | Description                                         |
| ---------------- | --------------------------------------------------- |
| **Location**     | Between routes and models                           |
| **Purpose**      | Contains all business logic                         |
| **Independence** | Doesn't know about HTTP (no Flask request/response) |
| **Testability**  | Can be tested without HTTP context                  |
| **Reusability**  | Called from routes, CLI commands, background jobs   |

---

## Why Not Just Use Routes?

### The "Fat Controller" Anti-Pattern

Let's look at a route handler that does everything:

```python
# ❌ BAD: "Fat Controller" - route does everything

@users_bp.post("/register")
def register_user():
    # Get JSON data
    data = request.get_json()

    # Manual validation
    if not data:
        return jsonify({"error": "No data provided"}), 400

    if not data.get("username"):
        return jsonify({"error": "Username required"}), 400

    if len(data["username"]) < 3:
        return jsonify({"error": "Username too short"}), 400

    if not data.get("email"):
        return jsonify({"error": "Email required"}), 400

    # Email format validation
    import re
    email_pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    if not re.match(email_pattern, data["email"]):
        return jsonify({"error": "Invalid email"}), 400

    if not data.get("password"):
        return jsonify({"error": "Password required"}), 400

    if len(data["password"]) < 8:
        return jsonify({"error": "Password too short"}), 400

    # Check for existing username
    existing_user = User.query.filter_by(username=data["username"]).first()
    if existing_user:
        return jsonify({"error": "Username exists"}), 409

    # Check for existing email
    existing_email = User.query.filter_by(email=data["email"]).first()
    if existing_email:
        return jsonify({"error": "Email exists"}), 409

    # Create user
    from werkzeug.security import generate_password_hash
    user = User(
        username=data["username"],
        email=data["email"],
        password_hash=generate_password_hash(data["password"]),
        first_name=data.get("first_name"),
        last_name=data.get("last_name"),
    )

    # Save to database
    try:
        db.session.add(user)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500

    # Return formatted response
    return jsonify({
        "success": True,
        "data": {
            "id": user.id,
            "username": user.username,
            "email": user.email,
        }
    }), 201
```

### Problems with Fat Controllers

| Problem              | Description                                      |
| -------------------- | ------------------------------------------------ |
| **Long functions**   | 60+ lines doing too many things                  |
| **Untestable**       | Can't test business logic without HTTP context   |
| **Not reusable**     | Can't create users from CLI without copy-pasting |
| **Code duplication** | Same validation/logic repeated across routes     |
| **Hard to maintain** | Any change requires understanding everything     |
| **No separation**    | HTTP, validation, business rules all mixed       |

---

## Service Layer Benefits

### 1. Testability

```python
# ✅ With service layer - easy to test

import pytest
from app.services.user_service import UserService, UserAlreadyExistsError

def test_create_user_success(db_session):
    """Test user creation without HTTP."""
    data = UserCreateSchema(
        username="testuser",
        email="test@example.com",
        password="securepassword123"
    )

    user = UserService.create_user(data)

    assert user.id is not None
    assert user.username == "testuser"
    assert user.email == "test@example.com"

def test_create_user_duplicate_username(db_session, existing_user):
    """Test duplicate username handling."""
    data = UserCreateSchema(
        username=existing_user.username,  # Same username
        email="new@example.com",
        password="securepassword123"
    )

    with pytest.raises(UserAlreadyExistsError) as exc:
        UserService.create_user(data)

    assert exc.value.field == "username"
```

**No HTTP mocking needed!** You test the business logic directly.

### 2. Reusability

```python
# Use from CLI
@app.cli.command()
def create_admin():
    """Create an admin user via command line."""
    data = UserCreateSchema(
        username="admin",
        email="admin@example.com",
        password="admin123456"
    )
    user = UserService.create_user(data)
    print(f"Admin created: ID={user.id}")


# Use from background job
def process_bulk_users(users_data: list):
    """Background job to create multiple users."""
    for data in users_data:
        try:
            user = UserService.create_user(data)
            logger.info(f"Created user: {user.id}")
        except UserAlreadyExistsError as e:
            logger.warning(f"Skipped duplicate: {e}")


# Use from route
@users_bp.post("/register")
def register_user(body: UserCreateSchema):
    """HTTP endpoint uses the same service."""
    user = UserService.create_user(body)
    return success_response(data=user.to_dict(), status_code=201)
```

### 3. Thin Routes

```python
# ✅ GOOD: Thin route that only handles HTTP

@users_bp.post("/register")
def register_user(body: UserCreateSchema):
    """
    Register a new user.

    This route only handles:
    1. Receive request (body parameter handles parsing)
    2. Call service
    3. Handle service exceptions
    4. Return formatted response
    """
    try:
        user = UserService.create_user(body)
        return success_response(data=user.to_dict(), status_code=201)

    except UserAlreadyExistsError as e:
        return error_response(
            code=ErrorCode.RESOURCE_ALREADY_EXISTS,
            message=f"{e.field.title()} already exists",
            status_code=409
        )
```

### 4. Clear Error Types

```python
# Service defines clear exceptions
class UserServiceError(Exception):
    """Base exception for user service."""
    pass

class UserNotFoundError(UserServiceError):
    """User doesn't exist."""
    pass

class UserAlreadyExistsError(UserServiceError):
    """User already exists."""
    def __init__(self, field: str, value: str):
        self.field = field
        self.value = value

class InvalidCredentialsError(UserServiceError):
    """Authentication failed."""
    pass
```

---

## Our Implementation

### File Structure

```
app/
└── services/
    ├── __init__.py          # Exports services and exceptions
    └── user_service.py      # User business logic
```

### Service Export Pattern

```python
# app/services/__init__.py

"""
Services Package - Business logic layer.

This package contains service classes that encapsulate business logic,
separating it from HTTP handling (routes) and data structure (models).
"""

from app.services.user_service import (
    # Service class
    UserService,

    # Exceptions
    UserServiceError,
    UserNotFoundError,
    UserAlreadyExistsError,
    InvalidCredentialsError,
)

__all__ = [
    "UserService",
    "UserServiceError",
    "UserNotFoundError",
    "UserAlreadyExistsError",
    "InvalidCredentialsError",
]
```

### UserService Class Structure

```python
# app/services/user_service.py

import logging
from typing import List, Optional, Tuple

from app import db
from app.models.user import User
from app.schemas.user import UserCreateSchema, UserUpdateSchema

logger = logging.getLogger(__name__)


# =============================================================================
# Custom Exceptions
# =============================================================================

class UserServiceError(Exception):
    """Base exception for user service errors."""
    pass

class UserNotFoundError(UserServiceError):
    """Raised when a user is not found."""
    pass

class UserAlreadyExistsError(UserServiceError):
    """Raised when trying to create a user that already exists."""
    def __init__(self, field: str, value: str):
        self.field = field
        self.value = value
        super().__init__(f"User with {field}='{value}' already exists")

class InvalidCredentialsError(UserServiceError):
    """Raised when login credentials are invalid."""
    pass


# =============================================================================
# User Service
# =============================================================================

class UserService:
    """
    Service class for user-related business logic.

    All methods are static for simplicity. In a larger application,
    you might use dependency injection with instance methods.

    Transaction Management:
    ----------------------
    Methods that modify data commit their own transactions.
    If you need multiple operations in one transaction, use
    the lower-level methods with manual transaction control.
    """

    # =========================================================================
    # CREATE Operations
    # =========================================================================

    @staticmethod
    def create_user(data: UserCreateSchema) -> User:
        """
        Create a new user.

        Args:
            data: Validated user creation data

        Returns:
            The newly created User object

        Raises:
            UserAlreadyExistsError: If username or email already exists
        """
        logger.info(f"Creating user: {data.username}")

        # Check for existing username
        if User.query.filter_by(username=data.username, is_deleted=False).first():
            logger.warning(f"Username already exists: {data.username}")
            raise UserAlreadyExistsError("username", data.username)

        # Check for existing email
        if User.query.filter_by(email=data.email, is_deleted=False).first():
            logger.warning(f"Email already exists: {data.email}")
            raise UserAlreadyExistsError("email", data.email)

        # Create user
        user = User(
            username=data.username,
            email=data.email,
            first_name=data.first_name,
            middle_name=data.middle_name,
            last_name=data.last_name,
            bio=data.bio,
        )
        user.set_password(data.password)

        try:
            db.session.add(user)
            db.session.commit()
            logger.info(f"User created successfully: id={user.id}")
            return user
        except Exception as e:
            db.session.rollback()
            logger.error(f"Failed to create user: {e}")
            raise

    # ... more methods
```

---

## Service Method Patterns

### CREATE Pattern

```python
@staticmethod
def create_user(data: UserCreateSchema) -> User:
    """
    Create Pattern Flow:
    1. Log the attempt
    2. Check business rules (uniqueness, etc.)
    3. Create model instance
    4. Perform any transformations (hash password)
    5. Save to database with transaction
    6. Return created instance
    """
    logger.info(f"Creating user: {data.username}")

    # Business rule: username must be unique
    if User.query.filter_by(username=data.username, is_deleted=False).first():
        raise UserAlreadyExistsError("username", data.username)

    # Create instance
    user = User(username=data.username, email=data.email)
    user.set_password(data.password)

    # Transaction
    try:
        db.session.add(user)
        db.session.commit()
        logger.info(f"User created: id={user.id}")
        return user
    except Exception:
        db.session.rollback()
        raise
```

### READ Pattern

```python
@staticmethod
def get_by_id(user_id: int, include_deleted: bool = False) -> Optional[User]:
    """
    Read Pattern (nullable):
    - Returns the object or None
    - Caller decides how to handle None
    """
    query = User.query.filter_by(id=user_id)
    if not include_deleted:
        query = query.filter_by(is_deleted=False)
    return query.first()


@staticmethod
def get_by_id_or_404(user_id: int, include_deleted: bool = False) -> User:
    """
    Read Pattern (strict):
    - Returns the object or raises exception
    - Caller knows object will always exist
    """
    user = UserService.get_by_id(user_id, include_deleted)
    if not user:
        raise UserNotFoundError(f"User with id={user_id} not found")
    return user


@staticmethod
def get_all(
    include_deleted: bool = False,
    page: int = 1,
    per_page: int = 20,
) -> Tuple[List[User], int]:
    """
    List Pattern:
    - Returns tuple of (items, total_count)
    - Supports pagination
    - Returns empty list, never None
    """
    query = User.query
    if not include_deleted:
        query = query.filter_by(is_deleted=False)

    total = query.count()
    users = query.order_by(User.id).offset((page - 1) * per_page).limit(per_page).all()

    return users, total
```

### UPDATE Pattern

```python
@staticmethod
def update_user(user_id: int, data: UserUpdateSchema) -> User:
    """
    Update Pattern Flow:
    1. Get existing entity (raise if not found)
    2. Extract only provided fields
    3. Apply updates
    4. Commit transaction
    5. Return updated entity
    """
    user = UserService.get_by_id_or_404(user_id)

    logger.info(f"Updating user: user_id={user_id}")

    # Get only fields that were set (exclude_unset=True)
    update_data = data.model_dump(exclude_unset=True)
    logger.debug(f"Fields being updated: {list(update_data.keys())}")

    for field, value in update_data.items():
        setattr(user, field, value)

    try:
        db.session.commit()
        logger.info(f"User updated successfully: user_id={user_id}")
        return user
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to update user: {e}")
        raise
```

### DELETE Patterns

```python
@staticmethod
def soft_delete(user_id: int) -> User:
    """
    Soft Delete Pattern:
    - Mark as deleted without removing from database
    - Allows recovery if needed
    - Maintains data integrity (foreign keys)
    """
    user = UserService.get_by_id_or_404(user_id)

    logger.info(f"Soft-deleting user: user_id={user_id}")
    user.soft_delete()  # Sets is_deleted=True, deleted_at=now()

    try:
        db.session.commit()
        logger.info(f"User soft-deleted: user_id={user_id}")
        return user
    except Exception:
        db.session.rollback()
        raise


@staticmethod
def hard_delete(user_id: int) -> bool:
    """
    Hard Delete Pattern:
    - Permanently removes from database
    - Use with caution!
    - Consider soft delete for production
    """
    user = UserService.get_by_id(user_id, include_deleted=True)
    if not user:
        raise UserNotFoundError(f"User with id={user_id} not found")

    logger.warning(f"HARD DELETING user: user_id={user_id}")

    try:
        db.session.delete(user)
        db.session.commit()
        logger.info(f"User hard-deleted: user_id={user_id}")
        return True
    except Exception:
        db.session.rollback()
        raise


@staticmethod
def restore(user_id: int) -> User:
    """
    Restore Pattern:
    - Undo soft delete
    - Only works with soft-deleted records
    """
    user = UserService.get_by_id(user_id, include_deleted=True)
    if not user:
        raise UserNotFoundError(f"User with id={user_id} not found")

    logger.info(f"Restoring user: user_id={user_id}")
    user.restore()  # Sets is_deleted=False, deleted_at=None

    try:
        db.session.commit()
        logger.info(f"User restored: user_id={user_id}")
        return user
    except Exception:
        db.session.rollback()
        raise
```

---

## Transaction Management

### Why Transaction Management Matters

```python
# ❌ BAD: Multiple commits can leave data inconsistent

def transfer_money(from_user_id, to_user_id, amount):
    from_user = User.query.get(from_user_id)
    from_user.balance -= amount
    db.session.commit()  # What if next line fails?

    to_user = User.query.get(to_user_id)
    to_user.balance += amount
    db.session.commit()  # Money disappeared if this fails!
```

### Single Transaction Pattern

```python
# ✅ GOOD: All operations in one transaction

@staticmethod
def create_user_with_profile(data: UserCreateSchema) -> User:
    """Create user and profile in one transaction."""
    user = User(username=data.username, email=data.email)
    profile = UserProfile(bio=data.bio, avatar_url=data.avatar_url)

    try:
        user.profile = profile
        db.session.add(user)
        db.session.add(profile)
        db.session.commit()  # Single commit for both
        return user
    except Exception:
        db.session.rollback()  # Rollback everything
        raise
```

### Standard Transaction Block

```python
@staticmethod
def some_operation(data):
    """Standard transaction pattern."""
    try:
        # All database operations here
        db.session.add(entity)
        db.session.add(related_entity)

        # Single commit at the end
        db.session.commit()

        logger.info("Operation successful")
        return result

    except Exception as e:
        # Rollback on any failure
        db.session.rollback()
        logger.error(f"Operation failed: {e}")
        raise
```

---

## Error Handling

### Exception Hierarchy

```
UserServiceError (base)
├── UserNotFoundError        → 404 Not Found
├── UserAlreadyExistsError   → 409 Conflict
└── InvalidCredentialsError  → 401 Unauthorized
```

### Custom Exception Design

```python
class UserServiceError(Exception):
    """Base exception for user service errors."""
    pass


class UserNotFoundError(UserServiceError):
    """Raised when a user is not found."""
    pass


class UserAlreadyExistsError(UserServiceError):
    """
    Raised when trying to create a user that already exists.

    Attributes:
        field: The field that caused the conflict (username/email)
        value: The duplicate value
    """
    def __init__(self, field: str, value: str):
        self.field = field
        self.value = value
        super().__init__(f"User with {field}='{value}' already exists")


class InvalidCredentialsError(UserServiceError):
    """
    Raised when login credentials are invalid.

    Note: We don't specify WHETHER username or password was wrong
    for security reasons (prevents user enumeration).
    """
    pass
```

### Route Exception Handling

```python
@users_bp.post("/register")
def register_user(body: UserCreateSchema):
    try:
        user = UserService.create_user(body)
        return success_response(data=user.to_dict(), status_code=201)

    except UserAlreadyExistsError as e:
        # Map service exception to HTTP response
        return error_response(
            code=ErrorCode.RESOURCE_ALREADY_EXISTS,
            message=f"{e.field.title()} already exists",
            details={"field": e.field, "value": e.value},
            status_code=409
        )


@auth_bp.post("/login")
def login(body: LoginSchema):
    try:
        user = UserService.authenticate(body.email, body.password)
        # ... generate token

    except UserNotFoundError:
        # Don't say "user not found" - security!
        return error_response(
            code=ErrorCode.INVALID_CREDENTIALS,
            message="Invalid email or password",
            status_code=401
        )

    except InvalidCredentialsError:
        return error_response(
            code=ErrorCode.INVALID_CREDENTIALS,
            message="Invalid email or password",
            status_code=401
        )
```

---

## Testing Services

### Unit Test Example

```python
# tests/test_services/test_user_service.py

import pytest
from app.services.user_service import (
    UserService,
    UserNotFoundError,
    UserAlreadyExistsError,
)
from app.schemas.user import UserCreateSchema


class TestUserServiceCreate:
    """Tests for UserService.create_user()"""

    def test_create_user_success(self, db_session):
        """Successfully create a new user."""
        data = UserCreateSchema(
            username="newuser",
            email="new@example.com",
            password="securepassword123"
        )

        user = UserService.create_user(data)

        assert user.id is not None
        assert user.username == "newuser"
        assert user.email == "new@example.com"
        assert user.check_password("securepassword123")

    def test_create_user_duplicate_username(self, db_session, existing_user):
        """Reject duplicate username."""
        data = UserCreateSchema(
            username=existing_user.username,
            email="different@example.com",
            password="securepassword123"
        )

        with pytest.raises(UserAlreadyExistsError) as exc:
            UserService.create_user(data)

        assert exc.value.field == "username"

    def test_create_user_duplicate_email(self, db_session, existing_user):
        """Reject duplicate email."""
        data = UserCreateSchema(
            username="differentuser",
            email=existing_user.email,
            password="securepassword123"
        )

        with pytest.raises(UserAlreadyExistsError) as exc:
            UserService.create_user(data)

        assert exc.value.field == "email"


class TestUserServiceGet:
    """Tests for UserService getter methods."""

    def test_get_by_id_found(self, db_session, existing_user):
        """Return user when found."""
        user = UserService.get_by_id(existing_user.id)

        assert user is not None
        assert user.id == existing_user.id

    def test_get_by_id_not_found(self, db_session):
        """Return None when not found."""
        user = UserService.get_by_id(99999)

        assert user is None

    def test_get_by_id_or_404_not_found(self, db_session):
        """Raise exception when not found."""
        with pytest.raises(UserNotFoundError):
            UserService.get_by_id_or_404(99999)
```

### Test Fixtures

```python
# tests/conftest.py

import pytest
from app import create_app, db
from app.models.user import User


@pytest.fixture
def app():
    """Create application for testing."""
    app = create_app("testing")
    return app


@pytest.fixture
def db_session(app):
    """Create fresh database for each test."""
    with app.app_context():
        db.create_all()
        yield db.session
        db.session.rollback()
        db.drop_all()


@pytest.fixture
def existing_user(db_session):
    """Create a user for tests that need one."""
    user = User(
        username="existing",
        email="existing@example.com"
    )
    user.set_password("password123")
    db_session.add(user)
    db_session.commit()
    return user
```

---

## Best Practices

### DO ✓

1. **Keep routes thin**

    ```python
    # ✓ Route only handles HTTP
    @users_bp.get("/{user_id}")
    def get_user(path: UserPath):
        user = UserService.get_by_id_or_404(path.user_id)
        return success_response(data=user.to_dict())
    ```

2. **Use custom exceptions**

    ```python
    # ✓ Clear exception types
    raise UserAlreadyExistsError("email", data.email)
    ```

3. **Log service operations**

    ```python
    # ✓ Log at appropriate levels
    logger.info(f"Creating user: {data.username}")
    logger.warning(f"Username already exists: {data.username}")
    logger.error(f"Failed to create user: {e}")
    ```

4. **Accept Pydantic schemas**

    ```python
    # ✓ Input already validated
    def create_user(data: UserCreateSchema) -> User:
    ```

5. **Return domain objects**
    ```python
    # ✓ Return User, not dict
    return user  # Let route handle serialization
    ```

### DON'T ✗

1. **Put HTTP logic in services**

    ```python
    # ✗ Services shouldn't know about HTTP
    def create_user(data):
        if not data:
            return {"error": "No data"}, 400  # Wrong!
    ```

2. **Commit in loops**

    ```python
    # ✗ N commits instead of 1
    for item in items:
        db.session.add(item)
        db.session.commit()  # Wrong!
    ```

3. **Return inconsistent types**

    ```python
    # ✗ Returns User or None or dict
    def get_user(id):
        if ...:
            return user
        else:
            return {"error": "not found"}  # Wrong!
    ```

4. **Forget rollback**
    ```python
    # ✗ Data could be partially committed
    try:
        db.session.add(user)
        db.session.commit()
    except:
        raise  # Forgot rollback!
    ```

---

## Summary

| Aspect                | Without Service Layer | With Service Layer   |
| --------------------- | --------------------- | -------------------- |
| **Location of logic** | In route handlers     | In service classes   |
| **Testing**           | Requires HTTP mocking | Direct unit tests    |
| **Reusability**       | Copy-paste code       | Call service methods |
| **Route length**      | 50-100+ lines         | 5-15 lines           |
| **Error handling**    | Mixed with logic      | Custom exceptions    |

---

## Next Steps

-   **[6.3 User Service](./6.3_user_service.md)** - Complete UserService walkthrough
-   **[6.4 Error Classes](./6.4_error_classes.md)** - Custom exception patterns
-   **[6.5 Dependency Injection](./6.5_dependency_injection.md)** - DI patterns in Python

---

> **Related Documentation:**
>
> -   [4.6 User Routes](../04_api_design/4.6_user_routes.md)
> -   [4.11 Error Handling](../04_api_design/4.11_error_handling.md)
> -   [3.5 User Model](../03_database/3.5_user_model.md)
