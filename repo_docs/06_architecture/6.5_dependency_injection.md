# 6.5 Dependency Injection in Python

> **Patterns for Loose Coupling and Testability**

This document explains Dependency Injection (DI) patterns in Python and how they're applied in our Flask application. We'll compare different approaches and explain why we've chosen our current design.

---

## Table of Contents

1. [What is Dependency Injection?](#what-is-dependency-injection)
2. [Why Dependency Injection Matters](#why-dependency-injection-matters)
3. [DI Patterns in Python](#di-patterns-in-python)
4. [Our Approach: Static Methods](#our-approach-static-methods)
5. [Flask's Built-in DI](#flasks-built-in-di)
6. [Alternative Approaches](#alternative-approaches)
7. [When to Use Each Pattern](#when-to-use-each-pattern)
8. [Testing with DI](#testing-with-di)

---

## What is Dependency Injection?

### Definition

**Dependency Injection (DI)** is a design pattern where a class receives its dependencies from external sources rather than creating them internally.

### Without DI (Tight Coupling)

```python
# ❌ Class creates its own dependencies
class UserService:
    def __init__(self):
        # Hardcoded dependency - hard to test, hard to change
        self.db = PostgresDatabase("localhost:5432/mydb")
        self.emailer = SMTPEmailer("smtp.gmail.com")

    def create_user(self, data):
        user = User(...)
        self.db.insert(user)           # Can't use different DB
        self.emailer.send_welcome()    # Always sends real emails
        return user
```

**Problems:**

-   Can't swap database implementation
-   Tests send real emails
-   Configuration is scattered

### With DI (Loose Coupling)

```python
# ✅ Dependencies are injected from outside
class UserService:
    def __init__(self, db: Database, emailer: Emailer):
        self.db = db
        self.emailer = emailer

    def create_user(self, data):
        user = User(...)
        self.db.insert(user)           # Use whatever DB was passed in
        self.emailer.send_welcome()    # Could be mock in tests
        return user

# Production
service = UserService(
    db=PostgresDatabase("..."),
    emailer=SMTPEmailer("...")
)

# Testing
service = UserService(
    db=MockDatabase(),
    emailer=MockEmailer()
)
```

### Visual Comparison

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     WITHOUT Dependency Injection                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                      UserService                                 │    │
│  │                                                                  │    │
│  │  def __init__(self):                                            │    │
│  │      self.db = PostgresDatabase(...)  ← Creates own dependency  │    │
│  │      self.emailer = SMTPEmailer(...)  ← Creates own dependency  │    │
│  │                                                                  │    │
│  │  PROBLEM: Can't change, can't test                              │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                      WITH Dependency Injection                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────────────┐                                               │
│  │  PostgresDatabase    │  ←── Or MockDatabase for tests               │
│  └──────────┬───────────┘                                               │
│             │                                                            │
│             │  injected                                                  │
│             ▼                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                      UserService                                 │    │
│  │                                                                  │    │
│  │  def __init__(self, db: Database, emailer: Emailer):            │    │
│  │      self.db = db          ← Receives dependency                │    │
│  │      self.emailer = emailer ← Receives dependency               │    │
│  │                                                                  │    │
│  │  BENEFIT: Swappable, testable                                   │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│             ▲                                                            │
│             │  injected                                                  │
│             │                                                            │
│  ┌──────────┴───────────┐                                               │
│  │  SMTPEmailer         │  ←── Or MockEmailer for tests                │
│  └──────────────────────┘                                               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Why Dependency Injection Matters

### 1. Testability

```python
# Without DI - hard to test
class UserService:
    def create_user(self, data):
        db = PostgresDatabase()  # Always hits real DB
        user = db.insert(...)
        return user

# With DI - easy to test
class UserService:
    def __init__(self, db: Database):
        self.db = db

    def create_user(self, data):
        return self.db.insert(...)

# Test
def test_create_user():
    mock_db = Mock()
    service = UserService(db=mock_db)
    service.create_user({"name": "John"})
    mock_db.insert.assert_called_once()  # No real DB touched!
```

### 2. Flexibility

```python
# Same service works with different databases
postgres_service = UserService(db=PostgresDatabase())
sqlite_service = UserService(db=SQLiteDatabase())
memory_service = UserService(db=InMemoryDatabase())  # For testing
```

### 3. Configuration Centralization

```python
# All dependencies configured in one place
def create_app(config_name):
    app = Flask(__name__)

    # Configure dependencies based on environment
    if config_name == "production":
        db = PostgresDatabase(app.config["DATABASE_URL"])
        cache = RedisCache(app.config["REDIS_URL"])
    elif config_name == "testing":
        db = SQLiteDatabase(":memory:")
        cache = DictCache()

    # Inject into services
    app.user_service = UserService(db=db, cache=cache)

    return app
```

---

## DI Patterns in Python

Python supports several DI patterns, each with trade-offs:

### Pattern 1: Constructor Injection

```python
class UserService:
    def __init__(self, db: Database, cache: Cache):
        self.db = db
        self.cache = cache

    def get_user(self, user_id: int):
        cached = self.cache.get(f"user:{user_id}")
        if cached:
            return cached
        return self.db.query(User, user_id)
```

**Pros:**

-   Clear dependencies
-   Immutable after construction
-   Easy to test

**Cons:**

-   Verbose instantiation
-   Need to wire everything manually

### Pattern 2: Function Parameters

```python
def get_user(user_id: int, db: Database, cache: Cache):
    cached = cache.get(f"user:{user_id}")
    if cached:
        return cached
    return db.query(User, user_id)
```

**Pros:**

-   Simple
-   Very explicit

**Cons:**

-   Need to pass dependencies through every function call
-   Verbose when many dependencies

### Pattern 3: Flask Application Context

```python
# Flask's built-in approach
from flask import current_app

def get_user(user_id: int):
    db = current_app.extensions['sqlalchemy'].db
    return db.session.query(User).get(user_id)
```

**Pros:**

-   No need to pass dependencies
-   Flask-native
-   Works well with Flask's request/response model

**Cons:**

-   Requires app context
-   Can be harder to test

### Pattern 4: Static Methods with Globals

```python
# Our current approach
from app import db

class UserService:
    @staticmethod
    def get_user(user_id: int):
        return db.session.query(User).get(user_id)
```

**Pros:**

-   Simple to use
-   No instantiation needed
-   Works well with Flask's app factory

**Cons:**

-   Depends on global `db`
-   Slightly harder to mock

---

## Our Approach: Static Methods

### Why We Use Static Methods

Our `UserService` uses static methods:

```python
class UserService:
    """
    Service class for user-related business logic.

    All methods are static for simplicity. In a larger application,
    you might use dependency injection with instance methods.
    """

    @staticmethod
    def create_user(data: UserCreateSchema) -> User:
        # Uses global db from app
        db.session.add(user)
        db.session.commit()
        return user

    @staticmethod
    def get_by_id(user_id: int) -> Optional[User]:
        return User.query.filter_by(id=user_id).first()
```

### Why This Works for Us

1. **Flask-SQLAlchemy provides `db`** - Already injected via Flask's extension system
2. **Simple API** - Just call `UserService.create_user(data)`
3. **No boilerplate** - No need to instantiate services
4. **Still testable** - Flask's test client provides test context

### The Trade-off

We get simplicity at the cost of pure DI. The `db` object is a module-level import, which is a form of service locator pattern rather than pure DI.

For our use case (learning Flask, medium-sized application), this is the right trade-off. For larger applications with complex testing needs, you might want constructor injection.

---

## Flask's Built-in DI

Flask has its own dependency injection mechanisms:

### 1. Extensions (`app.extensions`)

```python
# app/__init__.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()  # Create extension

def create_app():
    app = Flask(__name__)
    db.init_app(app)  # Inject into app
    return app
```

After init, the extension is available:

-   Via the global `db` (module-level)
-   Via `current_app.extensions['sqlalchemy']`

### 2. Application Context (`current_app`)

```python
from flask import current_app

def get_config_value():
    return current_app.config['SECRET_KEY']
```

Inside a request, `current_app` gives access to the app and its config.

### 3. Request Context (`g`)

```python
from flask import g

@app.before_request
def inject_user():
    g.current_user = get_authenticated_user()

# Later in route
def my_route():
    user = g.current_user  # Injected earlier
```

`g` is a request-scoped namespace for storing data.

### 4. Custom Extensions

```python
# Create your own injectable extension
class CacheExtension:
    def __init__(self, app=None):
        if app:
            self.init_app(app)

    def init_app(self, app):
        app.config.setdefault('CACHE_TYPE', 'simple')
        app.extensions['cache'] = self

    def get(self, key):
        ...

# Usage
cache = CacheExtension()

def create_app():
    app = Flask(__name__)
    cache.init_app(app)  # Now cache is injectable
    return app
```

---

## Alternative Approaches

### Approach 1: Dependency Injection Container

Use a DI container library like `dependency-injector`:

```python
from dependency_injector import containers, providers

class Container(containers.DeclarativeContainer):
    config = providers.Configuration()

    database = providers.Singleton(
        PostgresDatabase,
        url=config.database_url
    )

    user_service = providers.Factory(
        UserService,
        db=database
    )

# Usage
container = Container()
container.config.database_url.from_env("DATABASE_URL")

service = container.user_service()
user = service.create_user(data)
```

**When to use:** Large applications with complex dependency graphs.

### Approach 2: Factory Functions

```python
def create_user_service(app):
    """Factory that creates configured UserService."""
    db = app.extensions['sqlalchemy'].db
    cache = app.extensions.get('cache')
    return UserService(db=db, cache=cache)

# app/__init__.py
def create_app():
    app = Flask(__name__)
    # ... setup extensions ...

    # Create services
    app.user_service = create_user_service(app)

    return app

# Usage in routes
@bp.route('/users/<int:id>')
def get_user(id):
    service = current_app.user_service
    return service.get_by_id(id)
```

### Approach 3: Service Locator

```python
class ServiceLocator:
    """Central registry for services."""
    _services = {}

    @classmethod
    def register(cls, name: str, service):
        cls._services[name] = service

    @classmethod
    def get(cls, name: str):
        return cls._services[name]

# Registration
ServiceLocator.register('user_service', UserService(db))

# Usage
service = ServiceLocator.get('user_service')
service.create_user(data)
```

**Note:** Service Locator is often considered an anti-pattern because it hides dependencies. Use with caution.

---

## When to Use Each Pattern

### Use Static Methods When...

-   ✅ Building a small to medium Flask application
-   ✅ Using Flask-SQLAlchemy (db is already global)
-   ✅ Team is familiar with the pattern
-   ✅ Simple dependencies (just db, maybe cache)

### Use Constructor Injection When...

-   ✅ Building a large application
-   ✅ Need to swap implementations (testing, multi-tenancy)
-   ✅ Following strict DI principles
-   ✅ Using a DI framework

### Use Flask's `g` When...

-   ✅ Storing per-request data (current user, request ID)
-   ✅ Need request-scoped singletons

### Use `current_app` When...

-   ✅ Accessing configuration
-   ✅ Accessing registered extensions
-   ✅ Already inside a request/app context

---

## Testing with DI

### Testing Static Methods (Our Approach)

```python
# tests/conftest.py
import pytest
from app import create_app, db

@pytest.fixture
def app():
    """Create application with test configuration."""
    app = create_app('testing')  # Uses test database
    return app

@pytest.fixture
def db_session(app):
    """Provide database session with rollback."""
    with app.app_context():
        db.create_all()
        yield db.session
        db.session.rollback()
        db.drop_all()

# tests/test_user_service.py
def test_create_user(db_session):
    """Test within app context - uses test DB."""
    data = UserCreateSchema(
        username="test",
        email="test@example.com",
        password="password123"
    )

    user = UserService.create_user(data)

    assert user.id is not None
    assert user.username == "test"
```

**Key:** The test fixtures provide an app context with a test database. The global `db` points to the test database inside the context.

### Testing with Mocks

```python
from unittest.mock import patch, Mock

def test_create_user_with_mock():
    """Mock the database entirely."""
    with patch('app.services.user_service.db') as mock_db:
        with patch('app.services.user_service.User') as mock_user_class:
            # Setup mocks
            mock_user = Mock()
            mock_user.id = 1
            mock_user_class.return_value = mock_user
            mock_user_class.query.filter_by.return_value.first.return_value = None

            # Call service
            data = UserCreateSchema(
                username="test",
                email="test@example.com",
                password="password123"
            )
            user = UserService.create_user(data)

            # Verify
            mock_db.session.add.assert_called_once()
            mock_db.session.commit.assert_called_once()
            assert user.id == 1
```

### Testing Constructor Injection

```python
class UserService:
    def __init__(self, db: Database):
        self.db = db

# Test
def test_create_user():
    mock_db = Mock()
    service = UserService(db=mock_db)

    service.create_user(data)

    mock_db.session.add.assert_called_once()
```

---

## Summary

### Our Architecture Decisions

| Decision              | Reasoning                                        |
| --------------------- | ------------------------------------------------ |
| Static methods        | Simpler API, no instantiation overhead           |
| Global `db` via Flask | Flask-SQLAlchemy pattern, well-understood        |
| No DI framework       | Overkill for our application size                |
| Test with app context | Flask-native, maintains production-like behavior |

### Key Takeaways

1. **DI isn't just classes** - Python has many DI patterns
2. **Flask has built-in DI** - Use extensions, `g`, and `current_app`
3. **Choose based on scale** - Static methods for small/medium, full DI for large
4. **Testing is the goal** - Choose whichever pattern makes testing easier

---

## Next Steps

-   **[6.6 Logging System](./6.6_logging_system.md)** - Structured logging
-   **[6.3 User Service](./6.3_user_service.md)** - See static methods in action
-   **[8.1 Testing Overview](../08_testing/8.1_testing_overview.md)** - Testing strategies

---

> **Related Documentation:**
>
> -   [2.2 App Factory Pattern](../02_flask_fundamentals/2.2_app_factory_pattern.md)
> -   [2.6 Flask Extensions](../02_flask_fundamentals/2.6_flask_extensions.md)
> -   [2.7 Application Context](../02_flask_fundamentals/2.7_application_context.md)
