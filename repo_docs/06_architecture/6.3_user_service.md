# 6.3 User Service Explained

> **Complete Walkthrough of `user_service.py`**

This document provides a line-by-line explanation of the `UserService` class, showing how it implements business logic for user operations. We'll trace the complete data flow for each method.

---

## Table of Contents

1. [File Overview](#file-overview)
2. [Imports and Dependencies](#imports-and-dependencies)
3. [Custom Exceptions](#custom-exceptions)
4. [CREATE Operations](#create-operations)
5. [READ Operations](#read-operations)
6. [AUTHENTICATION Operations](#authentication-operations)
7. [UPDATE Operations](#update-operations)
8. [DELETE Operations](#delete-operations)
9. [Complete Flow Examples](#complete-flow-examples)

---

## File Overview

### Location

```
app/
└── services/
    ├── __init__.py          # Exports UserService and exceptions
    └── user_service.py      # ← This file
```

### Structure Summary

```python
# user_service.py structure

# 1. Imports
import logging
from typing import ...
from app import db
from app.models.user import User
from app.schemas.user import ...

# 2. Logger
logger = logging.getLogger(__name__)

# 3. Custom Exceptions
class UserServiceError(Exception): ...
class UserNotFoundError(UserServiceError): ...
class UserAlreadyExistsError(UserServiceError): ...
class InvalidCredentialsError(UserServiceError): ...

# 4. UserService Class
class UserService:
    # CREATE operations
    @staticmethod
    def create_user(data: UserCreateSchema) -> User: ...

    # READ operations
    @staticmethod
    def get_by_id(user_id: int, ...) -> Optional[User]: ...
    @staticmethod
    def get_by_id_or_404(user_id: int, ...) -> User: ...
    @staticmethod
    def get_by_email(email: str, ...) -> Optional[User]: ...
    @staticmethod
    def get_by_username(username: str, ...) -> Optional[User]: ...
    @staticmethod
    def get_all(...) -> Tuple[List[User], int]: ...

    # AUTHENTICATION
    @staticmethod
    def authenticate(email: str, password: str) -> User: ...

    # UPDATE operations
    @staticmethod
    def update_user(user_id: int, data: UserUpdateSchema) -> User: ...

    # DELETE operations
    @staticmethod
    def soft_delete(user_id: int) -> User: ...
    @staticmethod
    def restore(user_id: int) -> User: ...
    @staticmethod
    def hard_delete(user_id: int) -> bool: ...
```

---

## Imports and Dependencies

```python
"""
User Service - Business logic for user operations.

This service layer separates business logic from route handlers, making
the code more testable, maintainable, and reusable.

Why Use a Service Layer?
------------------------
1. **Separation of Concerns**: Routes handle HTTP, services handle business logic
2. **Testability**: Services can be unit tested without HTTP overhead
3. **Reusability**: Same logic can be used from CLI scripts, background jobs, etc.
4. **Single Responsibility**: Each layer has one job to do well

Usage:
    from app.services.user_service import UserService

    # In a route
    user = UserService.create_user(data)

    # In a CLI script
    user = UserService.get_by_email("test@example.com")
"""
```

### Import Breakdown

```python
import logging                      # Python's built-in logging module
from typing import List, Optional, Tuple  # Type hints for return types

from app import db                  # SQLAlchemy database instance
from app.models.user import User    # User model (ORM)
from app.schemas.user import (      # Pydantic schemas for validation
    UserCreateSchema,               # Input validation for creation
    UserUpdateSchema                # Input validation for updates
)

logger = logging.getLogger(__name__)
```

**Explanation:**

| Import                  | Purpose                                                  |
| ----------------------- | -------------------------------------------------------- |
| `logging`               | Log service operations (info, warning, error)            |
| `List, Optional, Tuple` | Type hints for clearer API                               |
| `db`                    | SQLAlchemy session for database operations               |
| `User`                  | User model for CRUD operations                           |
| `UserCreateSchema`      | Pydantic schema for creation input validation            |
| `UserUpdateSchema`      | Pydantic schema for update input validation              |
| `logger`                | Module-level logger (name = `app.services.user_service`) |

---

## Custom Exceptions

### Why Custom Exceptions?

Custom exceptions let us:

1. **Separate concerns**: Service throws exceptions, route catches and formats
2. **Clear error types**: Each failure mode has its own exception
3. **Carry context**: Exceptions can hold additional data (field, value, etc.)

### Exception Hierarchy

```
UserServiceError (base)
├── UserNotFoundError
│   └── Raised when: User ID doesn't exist, email not found
│   └── HTTP: 404 Not Found
│
├── UserAlreadyExistsError
│   └── Raised when: Duplicate username or email
│   └── HTTP: 409 Conflict
│   └── Extra: field name and duplicate value
│
└── InvalidCredentialsError
    └── Raised when: Wrong password during authentication
    └── HTTP: 401 Unauthorized
```

### Implementation

```python
class UserServiceError(Exception):
    """Base exception for user service errors."""
    pass
```

**Purpose:** Base class that other exceptions inherit from. Routes can catch `UserServiceError` to handle any user service failure generically.

---

```python
class UserNotFoundError(UserServiceError):
    """Raised when a user is not found."""
    pass
```

**Purpose:** Raised when looking up a user that doesn't exist. Simple exception with just a message.

**Usage:**

```python
raise UserNotFoundError(f"User with id={user_id} not found")
```

---

```python
class UserAlreadyExistsError(UserServiceError):
    """Raised when trying to create a user that already exists."""

    def __init__(self, field: str, value: str):
        self.field = field      # "username" or "email"
        self.value = value      # The duplicate value
        super().__init__(f"User with {field}='{value}' already exists")
```

**Purpose:** Raised when attempting to create a user with a duplicate username or email. Carries extra context about WHICH field was duplicate.

**Usage:**

```python
raise UserAlreadyExistsError("username", "john_doe")
# In route:
except UserAlreadyExistsError as e:
    # e.field = "username"
    # e.value = "john_doe"
    return error_response(message=f"{e.field.title()} already exists")
```

---

```python
class InvalidCredentialsError(UserServiceError):
    """Raised when login credentials are invalid."""
    pass
```

**Purpose:** Raised when password verification fails during authentication. Simple exception for security reasons (don't reveal which credential was wrong).

---

## CREATE Operations

### `create_user()` Method

```python
@staticmethod
def create_user(data: UserCreateSchema) -> User:
    """
    Create a new user.

    Args:
        data: Validated user creation data

    Returns:
        The newly created User object

    Raises:
        UserAlreadyExistsError: If username or email already exists
    """
```

**Signature Breakdown:**

| Part                     | Meaning                                         |
| ------------------------ | ----------------------------------------------- |
| `@staticmethod`          | Can be called without instantiating UserService |
| `data: UserCreateSchema` | Input is a validated Pydantic model             |
| `-> User`                | Returns a User model instance                   |

### Line-by-Line Flow

```python
    logger.info(f"Creating user: {data.username}")
```

**Log the attempt** at INFO level. Helps track who's creating accounts.

---

```python
    # Check for existing username
    if User.query.filter_by(username=data.username, is_deleted=False).first():
        logger.warning(f"Username already exists: {data.username}")
        raise UserAlreadyExistsError("username", data.username)
```

**Business Rule Check:**

1. Query database for user with same username (excluding soft-deleted)
2. If found, log a warning and raise exception
3. Route will catch this and return 409 Conflict

**Why `is_deleted=False`?**

-   Soft-deleted users shouldn't block new registrations
-   Someone can re-register with the same username if the original was deleted

---

```python
    # Check for existing email
    if User.query.filter_by(email=data.email, is_deleted=False).first():
        logger.warning(f"Email already exists: {data.email}")
        raise UserAlreadyExistsError("email", data.email)
```

**Same check for email uniqueness.**

---

```python
    # Create user
    user = User(
        username=data.username,
        email=data.email,
        first_name=data.first_name,
        middle_name=data.middle_name,
        last_name=data.last_name,
        bio=data.bio,
    )
    user.set_password(data.password)
```

**Create the User instance:**

1. Pass validated data from Pydantic schema to User constructor
2. Call `set_password()` to hash the password (never store plaintext!)

**Note:** `set_password()` is a method on the User model:

```python
def set_password(self, password: str) -> None:
    self.password_hash = generate_password_hash(password)
```

---

```python
    try:
        db.session.add(user)
        db.session.commit()
        logger.info(f"User created successfully: id={user.id}")
        return user
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to create user: {e}")
        raise
```

**Transaction Block:**

1. `db.session.add(user)` - Stage the user for insertion
2. `db.session.commit()` - Execute the INSERT query
3. Log success with the generated user ID
4. Return the user object (now has `user.id` populated)
5. If any error, rollback and re-raise

**Why try/except?**
Database operations can fail for various reasons:

-   Connection lost
-   Disk full
-   Constraint violations not caught earlier
-   Deadlocks

---

## READ Operations

### `get_by_id()` - Nullable Version

```python
@staticmethod
def get_by_id(user_id: int, include_deleted: bool = False) -> Optional[User]:
    """
    Get a user by ID.

    Args:
        user_id: The user's ID
        include_deleted: If True, include soft-deleted users

    Returns:
        User object or None if not found
    """
    query = User.query.filter_by(id=user_id)
    if not include_deleted:
        query = query.filter_by(is_deleted=False)
    return query.first()
```

**Flow:**

```
Input: user_id=5, include_deleted=False
         │
         ▼
┌───────────────────────────────────────────┐
│ query = User.query.filter_by(id=5)        │
│       SELECT * FROM users WHERE id = 5    │
└─────────────────┬─────────────────────────┘
                  │
                  ▼
┌───────────────────────────────────────────┐
│ if not include_deleted:                   │
│   query = query.filter_by(is_deleted=False)│
│       AND is_deleted = false              │
└─────────────────┬─────────────────────────┘
                  │
                  ▼
┌───────────────────────────────────────────┐
│ return query.first()                      │
│       LIMIT 1                             │
│       Returns User or None                │
└───────────────────────────────────────────┘
```

**Returns:**

-   `User` object if found
-   `None` if not found (caller must handle this!)

---

### `get_by_id_or_404()` - Strict Version

```python
@staticmethod
def get_by_id_or_404(user_id: int, include_deleted: bool = False) -> User:
    """
    Get a user by ID or raise 404.

    Args:
        user_id: The user's ID
        include_deleted: If True, include soft-deleted users

    Returns:
        User object

    Raises:
        UserNotFoundError: If user not found
    """
    user = UserService.get_by_id(user_id, include_deleted)
    if not user:
        raise UserNotFoundError(f"User with id={user_id} not found")
    return user
```

**Purpose:** Convenience method that throws an exception instead of returning None. Useful when you KNOW the user should exist.

**Pattern:**

```python
# Caller doesn't need to check for None
user = UserService.get_by_id_or_404(user_id)
# If we reach here, user is guaranteed to be a User object
```

---

### `get_by_email()` and `get_by_username()`

Same pattern as `get_by_id()` but filtering by different fields:

```python
@staticmethod
def get_by_email(email: str, include_deleted: bool = False) -> Optional[User]:
    query = User.query.filter_by(email=email)
    if not include_deleted:
        query = query.filter_by(is_deleted=False)
    return query.first()

@staticmethod
def get_by_username(username: str, include_deleted: bool = False) -> Optional[User]:
    query = User.query.filter_by(username=username)
    if not include_deleted:
        query = query.filter_by(is_deleted=False)
    return query.first()
```

---

### `get_all()` - Paginated List

```python
@staticmethod
def get_all(
    include_deleted: bool = False,
    page: int = 1,
    per_page: int = 20,
) -> Tuple[List[User], int]:
    """
    Get all users with pagination.

    Args:
        include_deleted: If True, include soft-deleted users
        page: Page number (1-indexed)
        per_page: Number of users per page

    Returns:
        Tuple of (list of users, total count)
    """
    query = User.query
    if not include_deleted:
        query = query.filter_by(is_deleted=False)

    # Get total count before pagination
    total = query.count()

    # Apply pagination
    users = query.order_by(User.id).offset((page - 1) * per_page).limit(per_page).all()

    return users, total
```

**Pagination Math:**

| Page | Offset Calculation | Result  |
| ---- | ------------------ | ------- |
| 1    | (1-1) × 20 = 0     | Skip 0  |
| 2    | (2-1) × 20 = 20    | Skip 20 |
| 3    | (3-1) × 20 = 40    | Skip 40 |

**Returns tuple:**

```python
users, total = UserService.get_all(page=2, per_page=10)
# users = [User, User, ...] (10 items for page 2)
# total = 156 (total users across all pages)
```

---

## AUTHENTICATION Operations

### `authenticate()` Method

```python
@staticmethod
def authenticate(email: str, password: str) -> User:
    """
    Authenticate a user with email and password.

    Args:
        email: The user's email address
        password: The plain text password

    Returns:
        The authenticated User object

    Raises:
        InvalidCredentialsError: If email not found OR password is incorrect
            (same error to prevent email enumeration attacks)

    Security Note:
        We intentionally return the same error for both "user not found"
        and "wrong password" to prevent attackers from discovering valid
        email addresses in our system.
    """
    logger.info("Authentication attempt")

    user = UserService.get_by_email(email)

    # Security: Return same error for user not found AND wrong password
    # This prevents email enumeration attacks
    if not user or not user.check_password(password):
        logger.warning("Authentication failed: invalid credentials")
        raise InvalidCredentialsError("Invalid email or password")

    logger.info(f"User authenticated successfully: user_id={user.id}")
    return user
```

**Complete Authentication Flow:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Input: email="john@example.com", password="secret123"                    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ logger.info("Authentication attempt")                                    │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ user = UserService.get_by_email("john@example.com")                     │
│                                                                          │
│ SQL: SELECT * FROM users                                                │
│      WHERE email = 'john@example.com'                                   │
│      AND is_deleted = false                                             │
│      LIMIT 1                                                             │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ if not user or not user.check_password(password):                       │
│     raise InvalidCredentialsError("Invalid email or password")          │
│                                                                          │
│ SECURITY: Same error for BOTH cases prevents email enumeration!         │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                     ┌───────────┴───────────┐
                     │                       │
           user is None OR             Both checks pass
         password is wrong                   │
                     │                       │
                     ▼                       ▼
    raise InvalidCredentialsError      return user ✓
```

**Security Notes:**

1. **Same error for all failures** - Whether email doesn't exist or password is wrong, we return `InvalidCredentialsError("Invalid email or password")`. This prevents "email enumeration attacks" where attackers try to discover valid emails.
2. **Generic log message** - Log only "invalid credentials", not "user not found" vs "wrong password"
3. **Password never logged** - Only log success/failure, never the actual password

**What is Email Enumeration?**

If your login returns different errors for "user not found" vs "wrong password", attackers can:

1. Try random emails until they get "wrong password" response
2. Now they know that email exists in your system
3. They can target those emails for phishing or password attacks

**The Fix:**

```python
# ❌ OLD (Vulnerable)
if not user:
    raise UserNotFoundError("User not found")  # Different error!
if not user.check_password(password):
    raise InvalidCredentialsError("Invalid password")  # Different error!

# ✅ NEW (Secure)
if not user or not user.check_password(password):
    raise InvalidCredentialsError("Invalid email or password")  # Same error!
```

---

## UPDATE Operations

### `update_user()` Method

```python
@staticmethod
def update_user(user_id: int, data: UserUpdateSchema) -> User:
    """
    Update a user's profile.

    Args:
        user_id: The user's ID
        data: Validated update data

    Returns:
        The updated User object

    Raises:
        UserNotFoundError: If user not found
    """
    user = UserService.get_by_id_or_404(user_id)

    logger.info(f"Updating user: user_id={user_id}")

    # Get only fields that were set
    update_data = data.model_dump(exclude_unset=True)
    logger.debug(f"Fields being updated: {list(update_data.keys())}")

    for field, value in update_data.items():
        setattr(user, field, value)

    try:
        db.session.commit()
        logger.info(f"User updated successfully: user_id={user_id}")
        return user
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to update user: {e}")
        raise
```

**Key Feature: `exclude_unset=True`**

This Pydantic feature only includes fields that were explicitly provided:

```python
# Request body: {"first_name": "John"}
data = UserUpdateSchema(first_name="John")

# With exclude_unset=True:
data.model_dump(exclude_unset=True)
# Result: {"first_name": "John"}

# Without exclude_unset (default):
data.model_dump()
# Result: {"first_name": "John", "last_name": None, "bio": None, ...}
```

**Why this matters:**

-   Only update fields the user actually sent
-   Don't accidentally overwrite existing data with `None`
-   Supports partial updates (PATCH semantics)

---

## DELETE Operations

### `soft_delete()` - Reversible Delete

```python
@staticmethod
def soft_delete(user_id: int) -> User:
    """
    Soft delete a user.

    Args:
        user_id: The user's ID

    Returns:
        The soft-deleted User object

    Raises:
        UserNotFoundError: If user not found
    """
    user = UserService.get_by_id_or_404(user_id)

    logger.info(f"Soft-deleting user: user_id={user_id}")

    user.soft_delete()  # Sets is_deleted=True, deleted_at=now()

    try:
        db.session.commit()
        logger.info(f"User soft-deleted successfully: user_id={user_id}")
        return user
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to soft-delete user: {e}")
        raise
```

**What `user.soft_delete()` does (defined in BaseModel):**

```python
def soft_delete(self):
    self.is_deleted = True
    self.deleted_at = datetime.utcnow()
```

---

### `restore()` - Undo Soft Delete

```python
@staticmethod
def restore(user_id: int) -> User:
    """
    Restore a soft-deleted user.
    """
    user = UserService.get_by_id(user_id, include_deleted=True)
    if not user:
        raise UserNotFoundError(f"User with id={user_id} not found")

    logger.info(f"Restoring user: user_id={user_id}")

    user.restore()  # Sets is_deleted=False, deleted_at=None

    try:
        db.session.commit()
        logger.info(f"User restored successfully: user_id={user_id}")
        return user
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to restore user: {e}")
        raise
```

**Note:** Uses `include_deleted=True` because we're looking for a deleted user!

---

### `hard_delete()` - Permanent Delete

```python
@staticmethod
def hard_delete(user_id: int) -> bool:
    """
    Permanently delete a user (use with caution!).

    Args:
        user_id: The user's ID

    Returns:
        True if deleted successfully

    Raises:
        UserNotFoundError: If user not found
    """
    user = UserService.get_by_id(user_id, include_deleted=True)
    if not user:
        raise UserNotFoundError(f"User with id={user_id} not found")

    logger.warning(f"HARD DELETING user: user_id={user_id}")

    try:
        db.session.delete(user)
        db.session.commit()
        logger.info(f"User hard-deleted successfully: user_id={user_id}")
        return True
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to hard-delete user: {e}")
        raise
```

**Key Differences from Soft Delete:**

| Aspect     | Soft Delete                  | Hard Delete                   |
| ---------- | ---------------------------- | ----------------------------- |
| Operation  | UPDATE (set is_deleted=True) | DELETE                        |
| Reversible | Yes (call restore())         | No                            |
| Data       | Still in database            | Permanently removed           |
| Log level  | INFO                         | WARNING (more severe action)  |
| Use case   | Normal user deletion         | GDPR erasure, testing cleanup |

---

## Complete Flow Examples

### Registration Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│ HTTP Request                                                             │
│ POST /api/v1/users/register                                             │
│ {"username": "john", "email": "john@example.com", "password": "pass123"} │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ Route Handler: register_user(body: UserCreateSchema)                    │
│ - Pydantic already validated the input                                  │
│ - Passwords meet requirements, email format valid, etc.                 │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ UserService.create_user(body)                                           │
│                                                                          │
│ 1. logger.info("Creating user: john")                                   │
│                                                                          │
│ 2. Check username uniqueness:                                           │
│    SELECT * FROM users                                                   │
│    WHERE username = 'john' AND is_deleted = false                       │
│    → None (no duplicate)                                                │
│                                                                          │
│ 3. Check email uniqueness:                                              │
│    SELECT * FROM users                                                   │
│    WHERE email = 'john@example.com' AND is_deleted = false              │
│    → None (no duplicate)                                                │
│                                                                          │
│ 4. Create User instance:                                                │
│    user = User(username="john", email="john@example.com", ...)          │
│                                                                          │
│ 5. Hash password:                                                       │
│    user.set_password("pass123")                                         │
│    → user.password_hash = "pbkdf2:sha256:..."                           │
│                                                                          │
│ 6. Transaction:                                                         │
│    db.session.add(user)                                                 │
│    db.session.commit()                                                  │
│    → INSERT INTO users (username, email, password_hash, ...)            │
│    → user.id = 42 (auto-generated)                                      │
│                                                                          │
│ 7. logger.info("User created successfully: id=42")                      │
│                                                                          │
│ 8. return user                                                          │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ Route Handler (continued):                                              │
│                                                                          │
│ return success_response(                                                │
│     data=user.to_dict(),                                                │
│     message="User created successfully",                                │
│     status_code=201                                                     │
│ )                                                                        │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│ HTTP Response: 201 Created                                              │
│ {                                                                        │
│   "success": true,                                                       │
│   "data": {                                                              │
│     "message": "User created successfully",                              │
│     "id": 42,                                                            │
│     "username": "john",                                                  │
│     "email": "john@example.com",                                         │
│     "created_at": "2026-01-15T08:30:00Z"                                │
│   },                                                                     │
│   "error": null,                                                         │
│   "meta": null                                                           │
│ }                                                                        │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Summary

### Method Overview

| Method             | Returns            | Raises                                         | Purpose              |
| ------------------ | ------------------ | ---------------------------------------------- | -------------------- |
| `create_user`      | `User`             | `UserAlreadyExistsError`                       | Create new user      |
| `get_by_id`        | `Optional[User]`   | -                                              | Find user (nullable) |
| `get_by_id_or_404` | `User`             | `UserNotFoundError`                            | Find user (strict)   |
| `get_by_email`     | `Optional[User]`   | -                                              | Find by email        |
| `get_by_username`  | `Optional[User]`   | -                                              | Find by username     |
| `get_all`          | `Tuple[List, int]` | -                                              | Paginated list       |
| `authenticate`     | `User`             | `UserNotFoundError`, `InvalidCredentialsError` | Login                |
| `update_user`      | `User`             | `UserNotFoundError`                            | Update profile       |
| `soft_delete`      | `User`             | `UserNotFoundError`                            | Soft delete          |
| `restore`          | `User`             | `UserNotFoundError`                            | Undo soft delete     |
| `hard_delete`      | `bool`             | `UserNotFoundError`                            | Permanent delete     |

---

## Next Steps

-   **[6.4 Error Classes](./6.4_error_classes.md)** - Custom exception patterns
-   **[6.2 Service Layer](./6.2_service_layer.md)** - Service layer philosophy
-   **[4.6 User Routes](../04_api_design/4.6_user_routes.md)** - How routes use this service

---

> **Related Documentation:**
>
> -   [3.5 User Model](../03_database/3.5_user_model.md) - The User ORM model
> -   [4.8 Schemas Explained](../04_api_design/4.8_schemas_explained.md) - Pydantic schemas
> -   [5.4 Auth Routes](../05_authentication/5.4_auth_routes.md) - Authentication endpoints
