# ğŸ›ï¸ BaseModel - Common Fields Pattern

> **DRY Principle for Database Models**

---

## ğŸ“‹ What is BaseModel?

BaseModel is an **abstract base class** that provides common fields shared by all database models. This follows the DRY (Don't Repeat Yourself) principle.

---

## ğŸ¯ Why BaseModel?

Without BaseModel, you'd repeat these fields in every model:

```python
# âŒ REPETITIVE - Same fields in every model
class User(db.Model):
    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, onupdate=datetime.utcnow)
    is_deleted = Column(Boolean, default=False)
    # ... user-specific fields

class Post(db.Model):
    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)  # Repeated!
    updated_at = Column(DateTime, onupdate=datetime.utcnow)  # Repeated!
    is_deleted = Column(Boolean, default=False)  # Repeated!
    # ... post-specific fields
```

With BaseModel:

```python
# âœ… DRY - Inherit common fields
class User(BaseModel):
    # id, created_at, updated_at, is_deleted inherited!
    username = Column(String(80), unique=True)

class Post(BaseModel):
    # id, created_at, updated_at, is_deleted inherited!
    title = Column(String(200))
```

---

## ğŸ“ Our BaseModel Implementation

```python
# app/models/base.py

from datetime import datetime, timezone
from sqlalchemy import Boolean, Column, DateTime, Integer
from app import db


class BaseModel(db.Model):
    """
    Abstract base model class that provides common fields for all models.

    This class is marked as abstract, meaning SQLAlchemy will NOT create
    a separate table for it. It only serves as a parent class.

    Attributes:
        id (int): Primary key, auto-incrementing integer
        created_at (datetime): UTC timestamp when record was created
        updated_at (datetime): UTC timestamp when record was last modified
        is_deleted (bool): Soft delete flag
    """

    # Don't create a table for this class
    __abstract__ = True

    # ========================================================================
    # PRIMARY KEY
    # ========================================================================
    id = Column(
        Integer,
        primary_key=True,
        autoincrement=True,
        comment="Unique identifier for the record",
    )

    # ========================================================================
    # TIMESTAMP FIELDS
    # ========================================================================
    created_at = Column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        comment="UTC timestamp when this record was created",
    )

    updated_at = Column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc),
        nullable=False,
        comment="UTC timestamp when this record was last updated",
    )

    # ========================================================================
    # SOFT DELETE FLAG
    # ========================================================================
    is_deleted = Column(
        Boolean,
        default=False,
        nullable=False,
        index=True,
        comment="Soft delete flag. True means record is logically deleted",
    )

    # ========================================================================
    # HELPER METHODS
    # ========================================================================
    def soft_delete(self):
        """Mark this record as deleted (soft delete)."""
        self.is_deleted = True

    def restore(self):
        """Restore a soft-deleted record."""
        self.is_deleted = False

    def to_base_dict(self):
        """Convert base fields to a dictionary."""
        return {
            "id": self.id,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
            "is_deleted": self.is_deleted,
        }

    def __repr__(self):
        """Default string representation."""
        return f"<{self.__class__.__name__} id={self.id}>"
```

---

## ğŸ“Š Fields Explained

### 1. `id` - Primary Key

```python
id = Column(
    Integer,
    primary_key=True,
    autoincrement=True,
)
```

-   **Auto-incrementing**: PostgreSQL uses SERIAL type
-   **Primary key**: Uniquely identifies each row
-   **Integer**: Simple, efficient, sufficient for most cases

### 2. `created_at` - Creation Timestamp

```python
created_at = Column(
    DateTime(timezone=True),
    default=lambda: datetime.now(timezone.utc),
    nullable=False,
)
```

-   **Timezone-aware**: Stores UTC timestamp
-   **Auto-set**: Populated automatically when record is created
-   **Immutable**: Never changes after creation

### 3. `updated_at` - Last Modified Timestamp

```python
updated_at = Column(
    DateTime(timezone=True),
    default=lambda: datetime.now(timezone.utc),
    onupdate=lambda: datetime.now(timezone.utc),
    nullable=False,
)
```

-   **Auto-update**: `onupdate` triggers on every modification
-   **Audit trail**: Know when records were last changed

### 4. `is_deleted` - Soft Delete Flag

```python
is_deleted = Column(
    Boolean,
    default=False,
    nullable=False,
    index=True,
)
```

-   **Soft delete**: Data is never truly deleted
-   **Indexed**: Fast filtering of active records
-   **Recoverable**: Can "undelete" if needed

---

## ğŸ—‘ï¸ Soft Delete Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SOFT DELETE vs HARD DELETE                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   HARD DELETE (Traditional):                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚   DELETE FROM users WHERE id = 1;                                â”‚
â”‚   â†’ Record is GONE FOREVER                                       â”‚
â”‚   â†’ Cannot recover                                               â”‚
â”‚   â†’ May break foreign key references                             â”‚
â”‚                                                                  â”‚
â”‚   SOFT DELETE (Our Approach):                                    â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                     â”‚
â”‚   UPDATE users SET is_deleted = TRUE WHERE id = 1;               â”‚
â”‚   â†’ Record still exists in database                              â”‚
â”‚   â†’ Can be "undeleted" (restore)                                 â”‚
â”‚   â†’ Foreign keys remain valid                                    â”‚
â”‚   â†’ Useful for audit trails                                      â”‚
â”‚                                                                  â”‚
â”‚   Querying Active Records:                                       â”‚
â”‚   SELECT * FROM users WHERE is_deleted = FALSE;                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Using Soft Delete

```python
# Delete a user (soft)
user = User.query.get(1)
user.soft_delete()
db.session.commit()

# User still exists in database, but:
User.query.filter_by(is_deleted=False).all()  # Won't include user 1

# Restore a deleted user
user.restore()
db.session.commit()
```

---

## ğŸ”§ Helper Methods

### `to_base_dict()`

Converts base fields to a dictionary. Child models extend this:

```python
class User(BaseModel):
    username = Column(String(80))

    def to_dict(self):
        # Start with base fields
        data = self.to_base_dict()
        # Add user-specific fields
        data.update({
            "username": self.username,
        })
        return data
```

**Output:**

```python
{
    "id": 1,
    "created_at": "2025-01-13T10:30:00+00:00",
    "updated_at": "2025-01-13T10:30:00+00:00",
    "is_deleted": False,
    "username": "john_doe"
}
```

### `__repr__()`

Provides a readable string representation for debugging:

```python
>>> user = User.query.get(1)
>>> print(user)
<User id=1>

# Child classes override for more detail:
>>> print(user)  # If User overrides __repr__
<User john_doe>
```

---

## ğŸ†š Express.js Comparison

### Mongoose with Timestamps

```javascript
const userSchema = new mongoose.Schema(
    {
        username: String,
    },
    {
        timestamps: true, // Adds createdAt, updatedAt
    }
);
```

### Prisma

```prisma
model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)
  username  String
}
```

### SQLAlchemy (BaseModel)

```python
class User(BaseModel):
    # id, created_at, updated_at, is_deleted inherited
    username = Column(String(80))
```

Same concept, different implementation!

---

## ğŸ“Š Inheritance Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     MODEL INHERITANCE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚                      db.Model (SQLAlchemy)                       â”‚
â”‚                             â”‚                                    â”‚
â”‚                             â–¼                                    â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                   â”‚     BaseModel     â”‚  (abstract)              â”‚
â”‚                   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                          â”‚
â”‚                   â”‚  â€¢ id             â”‚                          â”‚
â”‚                   â”‚  â€¢ created_at     â”‚                          â”‚
â”‚                   â”‚  â€¢ updated_at     â”‚                          â”‚
â”‚                   â”‚  â€¢ is_deleted     â”‚                          â”‚
â”‚                   â”‚  â€¢ soft_delete()  â”‚                          â”‚
â”‚                   â”‚  â€¢ restore()      â”‚                          â”‚
â”‚                   â”‚  â€¢ to_base_dict() â”‚                          â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                             â”‚                                    â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚         â”‚                   â”‚                   â”‚                â”‚
â”‚         â–¼                   â–¼                   â–¼                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚   â”‚   User    â”‚      â”‚   Post    â”‚       â”‚  Comment  â”‚           â”‚
â”‚   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚           â”‚
â”‚   â”‚ username  â”‚      â”‚ title     â”‚       â”‚ content   â”‚           â”‚
â”‚   â”‚ email     â”‚      â”‚ content   â”‚       â”‚ user_id   â”‚           â”‚
â”‚   â”‚ password  â”‚      â”‚ user_id   â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                  â”‚
â”‚   All child models automatically have:                           â”‚
â”‚   id, created_at, updated_at, is_deleted                         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš ï¸ Important: `__abstract__ = True`

```python
class BaseModel(db.Model):
    __abstract__ = True  # CRUCIAL!
```

**Why is this important?**

Without `__abstract__ = True`:

-   SQLAlchemy would try to create a `base_model` table
-   That table would be empty and useless
-   Migrations would be confused

With `__abstract__ = True`:

-   No table created for BaseModel
-   Only child classes get tables
-   Clean database schema

---

## ğŸ”œ Next Steps

Now let's look at our User model in detail.

**Next: [3.5_user_model.md](./3.5_user_model.md)** - The User model deep dive.
