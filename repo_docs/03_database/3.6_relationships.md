# ğŸ”— Relationships Between Models

> **Foreign Keys, One-to-Many, Many-to-Many**

---

## ğŸ“‹ Overview

While our current app only has the User model, understanding relationships is essential for expanding the application. This document explains how to create relationships in SQLAlchemy.

---

## ğŸ†š Comparison with Node.js

### Mongoose (MongoDB)

```javascript
// One-to-Many: User has many Posts
const postSchema = new mongoose.Schema({
    title: String,
    author: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
});

// Usage
const post = await Post.findById(id).populate("author");
```

### Prisma

```prisma
model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  author   User @relation(fields: [authorId], references: [id])
  authorId Int
}
```

### SQLAlchemy

```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    posts = db.relationship('Post', backref='author')

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    author_id = db.Column(db.Integer, db.ForeignKey('users.id'))
```

---

## ğŸ“Š Relationship Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RELATIONSHIP TYPES                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   ONE-TO-MANY (1:N)                                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚   One User has many Posts                                        â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚   â”‚  User  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  Post  â”‚                                â”‚
â”‚   â”‚  (1)   â”‚    has    â”‚  (N)   â”‚                                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   many    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                                                  â”‚
â”‚   ONE-TO-ONE (1:1)                                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚   One User has one Profile                                       â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚  User  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ Profile â”‚                               â”‚
â”‚   â”‚  (1)   â”‚    has    â”‚   (1)   â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    one    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                  â”‚
â”‚   MANY-TO-MANY (N:M)                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚   Many Users can have many Roles                                 â”‚
â”‚                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  User  â”‚ â—„â”€â”€â”€â”‚  user_roles    â”‚â”€â”€â”€â–º â”‚  Role  â”‚               â”‚
â”‚   â”‚  (N)   â”‚     â”‚ (junction tbl) â”‚     â”‚  (M)   â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ One-to-Many Relationship

**Example:** One User has many Posts

### Defining the Relationship

```python
# app/models/user.py
class User(BaseModel):
    __tablename__ = "users"

    username = Column(String(80), unique=True)

    # Relationship - List of posts belonging to this user
    posts = relationship(
        "Post",              # Related model name (string)
        backref="author",    # Adds 'author' attribute to Post
        lazy="dynamic",      # Returns query, not list (efficient)
        cascade="all, delete-orphan",  # Delete posts when user deleted
    )


# app/models/post.py
class Post(BaseModel):
    __tablename__ = "posts"

    title = Column(String(200), nullable=False)
    content = Column(Text)

    # Foreign Key - References users.id
    author_id = Column(
        Integer,
        ForeignKey("users.id"),  # Table.column
        nullable=False,
        index=True,  # Index for faster joins
    )
```

### Using the Relationship

```python
# Get user's posts
user = User.query.get(1)
posts = user.posts.all()  # List of Post objects

# Get post's author
post = Post.query.get(1)
author = post.author  # User object

# Create a post for a user
new_post = Post(
    title="My First Post",
    content="Hello world!",
    author_id=user.id,  # OR...
)
# Alternative: use the relationship
user.posts.append(new_post)
db.session.commit()
```

---

## ğŸ”§ One-to-One Relationship

**Example:** One User has one Profile

```python
# app/models/user.py
class User(BaseModel):
    __tablename__ = "users"

    username = Column(String(80), unique=True)

    # One-to-One relationship
    profile = relationship(
        "Profile",
        backref=backref("user", uselist=False),  # uselist=False makes it 1:1
        uselist=False,
        cascade="all, delete-orphan",
    )


# app/models/profile.py
class Profile(BaseModel):
    __tablename__ = "profiles"

    avatar_url = Column(String(500))
    website = Column(String(200))

    # Foreign Key
    user_id = Column(
        Integer,
        ForeignKey("users.id"),
        unique=True,  # Unique constraint enforces 1:1
        nullable=False,
    )
```

### Usage

```python
# Get user's profile
user = User.query.get(1)
profile = user.profile  # Single Profile object (not list)

# Get profile's user
profile = Profile.query.get(1)
user = profile.user  # Single User object
```

---

## ğŸ”§ Many-to-Many Relationship

**Example:** Users can have many Roles, Roles can belong to many Users

### Method 1: Association Table (Simple)

```python
# Junction table (no model needed for simple M:N)
user_roles = db.Table(
    "user_roles",
    Column("user_id", Integer, ForeignKey("users.id"), primary_key=True),
    Column("role_id", Integer, ForeignKey("roles.id"), primary_key=True),
)


# app/models/user.py
class User(BaseModel):
    __tablename__ = "users"

    username = Column(String(80), unique=True)

    # Many-to-Many relationship
    roles = relationship(
        "Role",
        secondary=user_roles,  # The junction table
        backref="users",       # Role.users
        lazy="dynamic",
    )


# app/models/role.py
class Role(BaseModel):
    __tablename__ = "roles"

    name = Column(String(50), unique=True)
```

### Usage

```python
# Add role to user
admin_role = Role.query.filter_by(name="admin").first()
user.roles.append(admin_role)
db.session.commit()

# Check if user has role
if admin_role in user.roles:
    print("User is admin")

# Get all users with a role
admin_role.users.all()  # List of users
```

### Method 2: Association Object (Complex)

When you need extra data on the relationship:

```python
# When the relationship has its own data
class UserRole(BaseModel):
    __tablename__ = "user_roles"

    user_id = Column(Integer, ForeignKey("users.id"), primary_key=True)
    role_id = Column(Integer, ForeignKey("roles.id"), primary_key=True)

    # Extra data about the relationship
    assigned_at = Column(DateTime, default=datetime.utcnow)
    assigned_by = Column(Integer, ForeignKey("users.id"))

    # Relationships
    user = relationship("User", foreign_keys=[user_id])
    role = relationship("Role")
```

---

## ğŸ“Š Lazy Loading Options

The `lazy` parameter controls how relationships are loaded:

```python
# Lazy loading options
posts = relationship("Post", lazy="select")     # Default: load on first access
posts = relationship("Post", lazy="dynamic")    # Returns a query object
posts = relationship("Post", lazy="joined")     # Eager load with JOIN
posts = relationship("Post", lazy="subquery")   # Eager load with subquery
posts = relationship("Post", lazy="raise")      # Raise error if accessed
```

| Option     | When to Use                            | Performance                 |
| ---------- | -------------------------------------- | --------------------------- |
| `select`   | Small relationships, occasional access | N+1 queries possible        |
| `dynamic`  | Large relationships, need filtering    | Efficient, returns query    |
| `joined`   | Always need related data               | Single query, bigger result |
| `subquery` | Multiple relationships to load         | Separate efficient query    |

---

## ğŸš« Avoiding N+1 Query Problem

### The Problem

```python
# âŒ N+1 queries - BAD!
users = User.query.all()  # 1 query
for user in users:
    print(user.posts.count())  # N queries (one per user!)
```

### The Solution

```python
# âœ… Eager loading - GOOD!
from sqlalchemy.orm import joinedload

# Option 1: joinedload
users = User.query.options(joinedload(User.posts)).all()

# Option 2: subqueryload
from sqlalchemy.orm import subqueryload
users = User.query.options(subqueryload(User.posts)).all()

# Now only 1-2 queries total!
for user in users:
    print(len(user.posts))  # No additional queries
```

---

## ğŸ“ Future Model Setup

When we add more models, the structure might look like:

```
app/models/
â”œâ”€â”€ __init__.py           # Export all models
â”œâ”€â”€ base.py               # BaseModel
â”œâ”€â”€ user.py               # User model
â”œâ”€â”€ post.py               # Post model (future)
â”œâ”€â”€ comment.py            # Comment model (future)
â”œâ”€â”€ role.py               # Role model (future)
â””â”€â”€ associations.py       # Junction tables
```

---

## âš ï¸ Common Mistakes

### Mistake 1: Forgetting Foreign Key Index

```python
# âŒ BAD - Slow JOINs
author_id = Column(Integer, ForeignKey("users.id"))

# âœ… GOOD - Fast JOINs
author_id = Column(Integer, ForeignKey("users.id"), index=True)
```

### Mistake 2: Circular Imports

```python
# âŒ BAD - Import at top level
from app.models.post import Post

class User(db.Model):
    posts = relationship(Post)  # Direct reference

# âœ… GOOD - Use string reference
class User(db.Model):
    posts = relationship("Post")  # String reference
```

### Mistake 3: Not Using Cascade

```python
# âŒ BAD - Orphan posts if user deleted
posts = relationship("Post", backref="author")

# âœ… GOOD - Delete posts when user is deleted
posts = relationship(
    "Post",
    backref="author",
    cascade="all, delete-orphan",
)
```

---

## ğŸ”œ Next Steps

Now let's learn how to query data from the database.

**Next: [3.7_querying_data.md](./3.7_querying_data.md)** - CRUD operations with SQLAlchemy.
