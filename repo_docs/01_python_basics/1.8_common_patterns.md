# üêç Pythonic Patterns and Idioms

> **Writing Code the Python Way**

---

## üìã What is "Pythonic"?

"Pythonic" means writing code that follows Python's philosophy and conventions. The goal is code that is:

-   Clear and readable
-   Simple and elegant
-   Following established patterns

The Zen of Python (run `import this`):

> "Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex."

---

## üéØ Common Pythonic Patterns

### 1. List Comprehensions

Transform data elegantly:

**Non-Pythonic:**

```python
squares = []
for x in range(10):
    squares.append(x ** 2)
```

**Pythonic:**

```python
squares = [x ** 2 for x in range(10)]
```

**With condition:**

```python
# Only even squares
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
```

**üÜö JavaScript equivalent:**

```javascript
const squares = [...Array(10)].map((_, x) => x ** 2);
const evenSquares = [...Array(10)].map((_, x) => x ** 2).filter((x) => x % 2 === 0);
```

---

### 2. Dictionary Comprehensions

```python
# Create dict from lists
names = ['alice', 'bob', 'charlie']
name_lengths = {name: len(name) for name in names}
# {'alice': 5, 'bob': 3, 'charlie': 7}

# Transform a dict
prices = {'apple': 1.0, 'banana': 0.5}
sale_prices = {item: price * 0.9 for item, price in prices.items()}
```

---

### 3. Unpacking

**Tuple unpacking:**

```python
# Instead of
point = (3, 4)
x = point[0]
y = point[1]

# Do this
x, y = (3, 4)
```

**Swap values:**

```python
# Instead of
temp = a
a = b
b = temp

# Do this
a, b = b, a
```

**Extended unpacking:**

```python
first, *middle, last = [1, 2, 3, 4, 5]
# first = 1, middle = [2, 3, 4], last = 5

head, *tail = [1, 2, 3, 4]
# head = 1, tail = [2, 3, 4]
```

**Function return unpacking:**

```python
def get_user_info():
    return "John", 25, "john@example.com"

name, age, email = get_user_info()
```

---

### 4. Enumerate

When you need index AND value:

**Non-Pythonic:**

```python
i = 0
for item in items:
    print(f"{i}: {item}")
    i += 1
```

**Pythonic:**

```python
for i, item in enumerate(items):
    print(f"{i}: {item}")

# Start from 1
for i, item in enumerate(items, start=1):
    print(f"{i}: {item}")
```

---

### 5. Zip

Iterate over multiple sequences together:

```python
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]

# Pair them up
for name, age in zip(names, ages):
    print(f"{name} is {age}")

# Create dict
user_dict = dict(zip(names, ages))
# {'Alice': 25, 'Bob': 30, 'Charlie': 35}
```

---

### 6. Get with Default

**Non-Pythonic:**

```python
if 'key' in dictionary:
    value = dictionary['key']
else:
    value = 'default'
```

**Pythonic:**

```python
value = dictionary.get('key', 'default')
```

**For defaultdict:**

```python
from collections import defaultdict

# Auto-initialize missing keys
word_count = defaultdict(int)
for word in words:
    word_count[word] += 1  # No KeyError!
```

---

### 7. Truthiness Checks

**Non-Pythonic:**

```python
if len(items) > 0:
    ...

if len(name) == 0:
    ...

if value == None:
    ...

if value == True:
    ...
```

**Pythonic:**

```python
if items:      # Non-empty collection
    ...

if not name:   # Empty string/collection
    ...

if value is None:   # Use 'is' for None
    ...

if value:      # Truthy check
    ...
```

---

### 8. Ternary Expression

**Non-Pythonic:**

```python
if condition:
    x = 'yes'
else:
    x = 'no'
```

**Pythonic:**

```python
x = 'yes' if condition else 'no'
```

---

### 9. String Joining

**Non-Pythonic:**

```python
result = ''
for item in items:
    result += item + ', '
result = result[:-2]  # Remove trailing comma
```

**Pythonic:**

```python
result = ', '.join(items)
```

---

### 10. Context Managers for Cleanup

**Non-Pythonic:**

```python
f = open('file.txt')
try:
    data = f.read()
finally:
    f.close()
```

**Pythonic:**

```python
with open('file.txt') as f:
    data = f.read()
```

---

## üèóÔ∏è Patterns in Our Project

### 1. List Comprehension for Serialization

```python
# app/routes/users.py
def get_all_users():
    users, total = UserService.get_all_paginated(page, per_page)

    # List comprehension to serialize
    return success_response(
        data=[user.to_dict() for user in users],
        meta={"total": total, "page": page}
    )
```

### 2. Dictionary Unpacking

```python
# Creating response
response = {
    "success": True,
    **data,           # Spread data dict
    **metadata        # Spread metadata dict
}
```

### 3. Getattr with Default

```python
# Safely get attribute
username = getattr(user, 'username', 'Unknown')
```

### 4. Unpacking in Loops

```python
# Iterate over dict items
for key, value in config.items():
    print(f"{key} = {value}")

# Enumerate with index
for index, user in enumerate(users, start=1):
    print(f"{index}. {user.username}")
```

---

## üìù Anti-Patterns to Avoid

### 1. Don't Use Mutable Default Arguments

```python
# BAD - Default list is shared!
def add_item(item, items=[]):
    items.append(item)
    return items

add_item(1)  # [1]
add_item(2)  # [1, 2] - Unexpected!

# GOOD
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

### 2. Don't Use `is` for Value Comparison

```python
# BAD
if x is 5:       # Works sometimes, but wrong!
if name is "":   # Wrong!

# GOOD
if x == 5:
if name == "":
if not name:     # Even better for empty check

# 'is' is ONLY for:
if x is None:
if x is True:
if x is False:
```

### 3. Don't Catch Generic Exceptions

```python
# BAD
try:
    do_something()
except:    # Catches EVERYTHING, even Ctrl+C!
    pass

# GOOD
try:
    do_something()
except SpecificError:
    handle_error()
except Exception as e:  # If you must be broad
    log.error(f"Unexpected: {e}")
    raise
```

### 4. Don't Iterate with Index When Not Needed

```python
# BAD
for i in range(len(items)):
    print(items[i])

# GOOD
for item in items:
    print(item)

# GOOD (when you need index)
for i, item in enumerate(items):
    print(f"{i}: {item}")
```

---

## üé® Code Style (PEP 8)

### Naming Conventions

```python
# Variables and functions: snake_case
user_name = "john"
def get_user_by_id(user_id):
    pass

# Classes: PascalCase
class UserService:
    pass

# Constants: SCREAMING_SNAKE_CASE
MAX_RETRY_COUNT = 3
DATABASE_URL = "..."

# Private: leading underscore
_internal_function()
_private_variable = True

# "Very private": double underscore
__name_mangled = True
```

### Line Length

-   Max 79 characters (strict PEP 8)
-   Max 100 characters (common in projects - we use this)
-   Black formatter handles this automatically

### Imports Order

```python
# 1. Standard library
import os
import sys

# 2. Third-party
from flask import Flask
import requests

# 3. Local
from app.models import User
```

---

## üß∞ Useful Built-in Functions

```python
# any() - True if ANY element is truthy
if any(user.is_admin for user in users):
    print("At least one admin")

# all() - True if ALL elements are truthy
if all(user.is_active for user in users):
    print("All users active")

# sorted() - Return sorted list
sorted_users = sorted(users, key=lambda u: u.username)

# filter() - Filter elements
active_users = list(filter(lambda u: u.is_active, users))
# Pythonic: [u for u in users if u.is_active]

# map() - Transform elements
usernames = list(map(lambda u: u.username, users))
# Pythonic: [u.username for u in users]

# min/max with key
youngest = min(users, key=lambda u: u.age)
oldest = max(users, key=lambda u: u.age)

# sum
total_age = sum(user.age for user in users)
```

---

## üîß F-strings Tips

```python
name = "John"
age = 25
price = 49.99

# Basic
f"Hello, {name}"

# Expressions
f"Next year: {age + 1}"

# Method calls
f"Upper: {name.upper()}"

# Formatting numbers
f"Price: ${price:.2f}"      # "Price: $49.99"
f"Padded: {age:04d}"        # "Padded: 0025"
f"Percent: {0.25:.1%}"      # "Percent: 25.0%"

# Alignment
f"{'left':<10}"   # "left      "
f"{'right':>10}"  # "     right"
f"{'center':^10}" # "  center  "

# Debug (Python 3.8+)
f"{name=}"        # "name='John'"
f"{age=}"         # "age=25"
```

---

## ‚úÖ Checklist: Is Your Code Pythonic?

-   [ ] Using list comprehensions where appropriate?
-   [ ] Using `enumerate()` instead of `range(len(...))`?
-   [ ] Using `zip()` for parallel iteration?
-   [ ] Using `.get()` for safe dictionary access?
-   [ ] Using truthiness checks (`if items:` not `if len(items) > 0:`)?
-   [ ] Using `is None` not `== None`?
-   [ ] Using context managers (`with`) for resources?
-   [ ] Following PEP 8 naming conventions?
-   [ ] Using f-strings for formatting?
-   [ ] Avoiding mutable default arguments?

---

## üéâ Congratulations!

You've completed the **01_python_basics** section! You now understand:

1. ‚úÖ Python syntax for JS developers
2. ‚úÖ Virtual environments
3. ‚úÖ Imports and modules
4. ‚úÖ Decorators
5. ‚úÖ Type hints
6. ‚úÖ Context managers
7. ‚úÖ Classes and OOP
8. ‚úÖ Pythonic patterns

---

## üîú Next Section

Ready to learn Flask? Let's dive in!

**Next: [../02_flask_fundamentals/2.1_what_is_flask.md](../02_flask_fundamentals/2.1_what_is_flask.md)** - Introduction to Flask.
