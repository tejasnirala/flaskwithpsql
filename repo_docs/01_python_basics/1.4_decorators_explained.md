# ğŸ¨ Decorators Explained

> **Python's Powerful Function Wrappers**

---

## ğŸ“‹ What is a Decorator?

A **decorator** is a function that takes another function and extends its behavior without modifying it directly.

You've already seen them:

```python
@app.route('/users')      # Flask route decorator
def get_users():
    ...

@jwt_required()           # Authentication decorator
def protected_route():
    ...
```

That `@something` syntax is a decorator.

---

## ğŸ†š JavaScript Comparison

Decorators exist in JavaScript (TC39 proposal), but they're not commonly used yet. The closest concept is **Higher-Order Functions**:

**JavaScript:**

```javascript
// Higher-order function
const withLogging = (fn) => {
    return (...args) => {
        console.log("Calling function");
        return fn(...args);
    };
};

const greet = (name) => `Hello, ${name}`;
const greetWithLogging = withLogging(greet);

greetWithLogging("John"); // Logs "Calling function", returns "Hello, John"
```

**Python with decorator syntax:**

```python
def with_logging(fn):
    def wrapper(*args, **kwargs):
        print('Calling function')
        return fn(*args, **kwargs)
    return wrapper

@with_logging
def greet(name):
    return f"Hello, {name}"

greet("John")  # Logs "Calling function", returns "Hello, John"
```

The `@with_logging` is just syntactic sugar for:

```python
def greet(name):
    return f"Hello, {name}"

greet = with_logging(greet)  # Same result!
```

---

## ğŸ”§ Building a Decorator Step by Step

### Step 1: A Simple Function

```python
def greet(name):
    return f"Hello, {name}"

print(greet("World"))  # "Hello, World"
```

### Step 2: A Function That Wraps Another

```python
def make_fancy(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return f"âœ¨ {result} âœ¨"
    return wrapper

# Apply manually
fancy_greet = make_fancy(greet)
print(fancy_greet("World"))  # "âœ¨ Hello, World âœ¨"
```

### Step 3: Using @ Syntax

```python
@make_fancy
def greet(name):
    return f"Hello, {name}"

print(greet("World"))  # "âœ¨ Hello, World âœ¨"
```

**The `@` syntax is equivalent to:**

```python
greet = make_fancy(greet)
```

---

## ğŸ“ Decorator Anatomy

```python
def my_decorator(func):           # Takes a function
    def wrapper(*args, **kwargs): # Replacement function
        # Before the original function
        print("Before")

        result = func(*args, **kwargs)  # Call original

        # After the original function
        print("After")

        return result             # Return original result
    return wrapper                # Return the wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Output:
# Before
# Hello!
# After
```

### Visual Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DECORATOR EXECUTION FLOW                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   @my_decorator                                                  â”‚
â”‚   def say_hello():                                               â”‚
â”‚       print("Hello!")                                            â”‚
â”‚                                                                  â”‚
â”‚   say_hello() is called:                                         â”‚
â”‚                                                                  â”‚
â”‚   1. wrapper() runs                                              â”‚
â”‚      â”‚                                                           â”‚
â”‚      â”œâ”€â”€ print("Before")     â†’ "Before"                          â”‚
â”‚      â”‚                                                           â”‚
â”‚      â”œâ”€â”€ func() runs         â†’ Original say_hello()              â”‚
â”‚      â”‚   â””â”€â”€ print("Hello!") â†’ "Hello!"                          â”‚
â”‚      â”‚                                                           â”‚
â”‚      â”œâ”€â”€ print("After")      â†’ "After"                           â”‚
â”‚      â”‚                                                           â”‚
â”‚      â””â”€â”€ return result                                           â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Real-World Use Cases

### 1. Logging Decorator

```python
import logging

def log_calls(func):
    """Log when a function is called."""
    def wrapper(*args, **kwargs):
        logging.info(f"Calling {func.__name__} with {args}, {kwargs}")
        result = func(*args, **kwargs)
        logging.info(f"{func.__name__} returned {result}")
        return result
    return wrapper

@log_calls
def add(a, b):
    return a + b

add(2, 3)
# Logs: Calling add with (2, 3), {}
# Logs: add returned 5
```

### 2. Timing Decorator

```python
import time

def timer(func):
    """Measure function execution time."""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "Done"

slow_function()
# Output: slow_function took 1.0012 seconds
```

### 3. Authentication Decorator (Like in Our App!)

```python
from functools import wraps
from flask import request, jsonify

def auth_required(func):
    """Require authentication token."""
    @wraps(func)
    def wrapper(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'error': 'No token provided'}), 401

        if not is_valid_token(token):
            return jsonify({'error': 'Invalid token'}), 401

        return func(*args, **kwargs)
    return wrapper

@app.route('/protected')
@auth_required
def protected_route():
    return jsonify({'message': 'You have access!'})
```

---

## ğŸ”§ The `@wraps` Decorator

**Problem:** Decorators replace your function's metadata.

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet():
    """Say hello."""
    pass

print(greet.__name__)  # "wrapper" - Wrong! Should be "greet"
print(greet.__doc__)   # None - Lost the docstring!
```

**Solution:** Use `@wraps` from `functools`:

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # Preserve func's metadata
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet():
    """Say hello."""
    pass

print(greet.__name__)  # "greet" âœ“
print(greet.__doc__)   # "Say hello." âœ“
```

**Always use `@wraps` in your decorators!**

---

## ğŸ›ï¸ Decorators with Arguments

Sometimes you want to configure a decorator:

```python
@route('/users')          # Argument: '/users'
@limit(requests=100)      # Arguments: requests=100
@cache(timeout=300)       # Arguments: timeout=300
```

### How to Create Decorators with Arguments

You need **three levels** of functions:

```python
def repeat(times):                    # 1. Takes decorator arguments
    def decorator(func):              # 2. Takes the function
        @wraps(func)
        def wrapper(*args, **kwargs): # 3. Runs the function
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def say_hello():
    print("Hello!")

say_hello()
# Hello!
# Hello!
# Hello!
```

### Visual Breakdown

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               DECORATOR WITH ARGUMENTS                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   @repeat(times=3)                                               â”‚
â”‚   def say_hello():                                               â”‚
â”‚       print("Hello!")                                            â”‚
â”‚                                                                  â”‚
â”‚   Unpacks to:                                                    â”‚
â”‚                                                                  â”‚
â”‚   say_hello = repeat(times=3)(say_hello)                         â”‚
â”‚               ^^^^^^^^^^^^^^  ^^^^^^^^^^                         â”‚
â”‚               Returns         Returns                            â”‚
â”‚               decorator()     wrapper()                          â”‚
â”‚                                                                  â”‚
â”‚   Level 1: repeat(times=3)     â†’ Returns decorator function      â”‚
â”‚   Level 2: decorator(say_hello) â†’ Returns wrapper function       â”‚
â”‚   Level 3: wrapper()            â†’ Runs say_hello 3 times         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š Decorators in Our Project

### 1. Flask Route Decorators

```python
# app/routes/users.py
@users_bp.get('/')
@users_bp.post('/')
@users_bp.put('/<int:id>')
```

These register URL patterns with Flask.

### 2. Rate Limiting

```python
# app/routes/users.py
from app.utils.rate_limiter import api_limit

@users_bp.post('/register')
@api_limit                    # Limits to 60/minute
def register_user():
    ...
```

**ğŸ“ See:** `app/utils/rate_limiter.py`

```python
# Preset decorators
auth_limit = limiter.limit("5 per minute")    # For login
api_limit = limiter.limit("60 per minute")    # For API calls
read_limit = limiter.limit("120 per minute")  # For GET requests
```

### 3. JWT Authentication

```python
# app/auth/routes.py
from flask_jwt_extended import jwt_required

@auth_bp.get('/me')
@jwt_required()
def get_current_user_info():
    user = get_current_user()
    ...
```

### 4. Error Handlers (Special Decorators)

```python
# app/utils/error_handlers.py
@app.errorhandler(404)
def handle_not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(ValidationError)
def handle_validation_error(error):
    ...
```

---

## ğŸ”„ Stacking Decorators

You can apply multiple decorators:

```python
@decorator1
@decorator2
@decorator3
def my_function():
    pass
```

**Execution order:** Bottom-up for wrapping, top-down for execution.

```python
@timer           # 2. Wraps logged_add (timer runs first when called)
@log_calls       # 1. Wraps add first
def add(a, b):
    return a + b

# Equivalent to:
add = timer(log_calls(add))

# When called:
# 1. timer's wrapper runs
# 2. Inside timer, log_calls' wrapper runs
# 3. Inside log_calls, original add runs
```

### Real Example from Our App

```python
@users_bp.post('/register')   # 3. Register with Flask
@api_limit                    # 2. Add rate limiting
def register_user():          # 1. Original function
    ...
```

---

## ğŸ› ï¸ Creating Our Own Decorator

Let's create a decorator used in our app:

```python
# app/auth/__init__.py

from functools import wraps
from flask import g
from flask_jwt_extended import verify_jwt_in_request

def admin_required():
    """
    Decorator for routes that require admin privileges.

    Usage:
        @app.route("/admin/users")
        @admin_required()
        def admin_users():
            ...
    """
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            # Verify JWT is present and valid
            verify_jwt_in_request()

            # Get current user
            user = get_current_user()

            if not user:
                return error_response(
                    code=ErrorCode.UNAUTHORIZED,
                    message="Authentication required",
                    status_code=401,
                )

            # Check admin status (TODO: implement properly)
            # if not user.is_admin:
            #     return error_response(
            #         code=ErrorCode.FORBIDDEN,
            #         message="Admin privileges required",
            #         status_code=403,
            #     )

            return fn(*args, **kwargs)
        return wrapper
    return decorator
```

---

## âš ï¸ Common Gotchas

### 1. Forgetting to Call Decorator with ()

```python
# Wrong - @jwt_required is a function that RETURNS a decorator
@jwt_required    # Missing ()!
def my_route():
    ...

# Correct
@jwt_required()
def my_route():
    ...
```

Some decorators don't need `()`:

```python
@staticmethod    # No ()
@property        # No ()
@api_limit       # Our rate limiter - no ()
```

### 2. Decorator Order Matters

```python
# Wrong - jwt_required should be AFTER route registration
@jwt_required()
@app.route('/users')
def get_users():
    ...

# Correct - route first (bottom), then protections (top)
@app.route('/users')
@jwt_required()
def get_users():
    ...
```

### 3. Forgetting @wraps

```python
# Without @wraps, Flask might not find your route!
def my_decorator(func):
    def wrapper(*args, **kwargs):  # func.__name__ becomes 'wrapper'
        return func(*args, **kwargs)
    return wrapper

# Flask uses __name__ to identify routes - this breaks!
```

---

## ğŸ§ª Practice: Read These Decorators

Find these in our codebase and understand what they do:

1. `@users_bp.get('/')` - Route registration
2. `@api_limit` - Rate limiting
3. `@jwt_required()` - Authentication
4. `@app.errorhandler(404)` - Error handling
5. `@wraps(func)` - Metadata preservation

---

## ğŸ”œ Next Steps

Now you understand decorators, one of Python's most powerful features. Next, let's learn about type hints.

**Next: [1.5_type_hints.md](./1.5_type_hints.md)** - Python's type system (like TypeScript for Python).
