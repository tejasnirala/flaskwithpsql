# ğŸ”„ Context Managers Explained

> **The 'with' Statement and Resource Management**

---

## ğŸ“‹ What is a Context Manager?

A **context manager** is an object that manages resources. It automatically handles setup and cleanup, ensuring resources are properly released even if errors occur.

```python
# The 'with' statement
with open('file.txt', 'r') as f:
    content = f.read()
# File is automatically closed here, even if an error occurred!
```

---

## ğŸ†š JavaScript Comparison

JavaScript doesn't have a direct equivalent, but the concept is similar to:

**JavaScript (try/finally):**

```javascript
let file;
try {
    file = fs.openSync("file.txt", "r");
    const content = fs.readFileSync(file, "utf8");
} finally {
    if (file) fs.closeSync(file); // Always cleanup
}
```

**Python (with statement):**

```python
with open('file.txt', 'r') as f:
    content = f.read()
# Cleanup is automatic!
```

The `with` statement is cleaner and guarantees cleanup.

---

## ğŸ”§ How It Works

### Behind the Scenes

```python
with something as name:
    # use name
```

Is equivalent to:

```python
name = something.__enter__()  # Setup
try:
    # use name
finally:
    something.__exit__(...)   # Cleanup (always runs!)
```

### Visual Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CONTEXT MANAGER FLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   with open('file.txt') as f:                                    â”‚
â”‚       content = f.read()                                         â”‚
â”‚                                                                  â”‚
â”‚   Execution:                                                     â”‚
â”‚                                                                  â”‚
â”‚   1. __enter__() is called                                       â”‚
â”‚      â””â”€â”€ Opens file, returns file object                         â”‚
â”‚      â””â”€â”€ File object is assigned to 'f'                          â”‚
â”‚                                                                  â”‚
â”‚   2. Block executes                                              â”‚
â”‚      â””â”€â”€ content = f.read()                                      â”‚
â”‚                                                                  â”‚
â”‚   3. __exit__() is called (ALWAYS)                               â”‚
â”‚      â””â”€â”€ Closes the file                                         â”‚
â”‚      â””â”€â”€ Even if an exception occurred!                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š Common Use Cases

### 1. File Operations

```python
# Reading a file
with open('data.txt', 'r') as f:
    content = f.read()

# Writing a file
with open('output.txt', 'w') as f:
    f.write('Hello, World!')

# Multiple files
with open('input.txt') as in_f, open('output.txt', 'w') as out_f:
    data = in_f.read()
    out_f.write(data.upper())
```

### 2. Database Connections

```python
# Without context manager (manual)
connection = db.connect()
try:
    cursor = connection.cursor()
    cursor.execute("SELECT * FROM users")
finally:
    connection.close()

# With context manager (automatic)
with db.connect() as connection:
    cursor = connection.cursor()
    cursor.execute("SELECT * FROM users")
# Connection automatically closed!
```

### 3. Locks (Threading)

```python
import threading

lock = threading.Lock()

# Without context manager
lock.acquire()
try:
    # Critical section
    shared_data += 1
finally:
    lock.release()

# With context manager
with lock:
    # Critical section
    shared_data += 1
# Lock automatically released!
```

### 4. Network Requests

```python
import requests

# requests handles cleanup automatically
with requests.Session() as session:
    response = session.get('https://api.example.com/data')
    data = response.json()
# Session closed, connections cleaned up
```

---

## ğŸ—ï¸ In Our Flask Project

### 1. Application Context

```python
# app/__init__.py and tests

# Flask operations need an app context
with app.app_context():
    db.create_all()              # Database operations
    user = User.query.first()   # Queries need context
```

**Why?** Flask needs to know which app is "current" for database operations.

### 2. Database Sessions (Implicit)

```python
# SQLAlchemy sessions in Flask
@app.route('/users')
def get_users():
    users = User.query.all()  # Session managed by Flask-SQLAlchemy
    return jsonify([u.to_dict() for u in users])
    # Session automatically handled per-request
```

Flask-SQLAlchemy manages sessions using request context, which is a form of context management.

### 3. Testing

```python
# tests/conftest.py

@pytest.fixture
def app():
    """Create application for testing."""
    app = create_app('testing')

    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()
```

### 4. Database Transactions

```python
# db_manage.py

with app.app_context():
    try:
        db.session.execute(db.text('DROP SCHEMA IF EXISTS "users" CASCADE'))
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        raise
```

---

## ğŸ”§ Creating Your Own Context Manager

### Method 1: Class-based

```python
class Timer:
    """Context manager to time code execution."""

    def __enter__(self):
        import time
        self.start = time.time()
        return self  # This is assigned to 'as' variable

    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        print(f"Elapsed: {self.end - self.start:.4f} seconds")
        return False  # Don't suppress exceptions

# Usage
with Timer() as t:
    # Some slow operation
    import time
    time.sleep(1)
# Output: Elapsed: 1.0012 seconds
```

### Method 2: Using `contextlib` (Simpler!)

```python
from contextlib import contextmanager

@contextmanager
def timer():
    """Context manager to time code execution."""
    import time
    start = time.time()

    yield  # This is where the 'with' block runs

    end = time.time()
    print(f"Elapsed: {end - start:.4f} seconds")

# Usage
with timer():
    import time
    time.sleep(1)
# Output: Elapsed: 1.0012 seconds
```

### The `@contextmanager` Pattern

```python
from contextlib import contextmanager

@contextmanager
def managed_resource():
    # Setup code (like __enter__)
    resource = acquire_resource()

    try:
        yield resource  # Give resource to 'with' block
    finally:
        # Cleanup code (like __exit__)
        release_resource(resource)
```

---

## ğŸ“Š Understanding `__exit__` Parameters

```python
def __exit__(self, exc_type, exc_val, exc_tb):
    """
    Called when exiting the 'with' block.

    Args:
        exc_type: Exception class (or None if no exception)
        exc_val: Exception instance (or None)
        exc_tb: Traceback object (or None)

    Returns:
        True to suppress the exception
        False to propagate it
    """
    if exc_type is not None:
        print(f"An error occurred: {exc_val}")

    # Cleanup code here
    self.close()

    return False  # Don't suppress exceptions
```

---

## ğŸŒŸ Real-World Example: Database Transaction

```python
from contextlib import contextmanager

@contextmanager
def transaction():
    """
    Context manager for database transactions.
    Commits on success, rolls back on failure.
    """
    try:
        yield db.session
        db.session.commit()
    except Exception:
        db.session.rollback()
        raise

# Usage
with transaction() as session:
    user = User(username="john", email="john@example.com")
    session.add(user)
    # If anything fails, rollback happens automatically
# If we get here, commit happened
```

---

## âš ï¸ Common Patterns

### 1. Suppressing Exceptions

```python
from contextlib import suppress

# Instead of try/except/pass
with suppress(FileNotFoundError):
    os.remove('maybe_exists.txt')
# No error if file doesn't exist
```

### 2. Redirecting Output

```python
from contextlib import redirect_stdout
import io

# Capture print output
output = io.StringIO()
with redirect_stdout(output):
    print("This goes to the buffer")

captured = output.getvalue()  # "This goes to the buffer\n"
```

### 3. Temporary Changes

```python
from contextlib import contextmanager
import os

@contextmanager
def temporary_env(key, value):
    """Temporarily set an environment variable."""
    old_value = os.environ.get(key)
    os.environ[key] = value
    try:
        yield
    finally:
        if old_value is None:
            del os.environ[key]
        else:
            os.environ[key] = old_value

# Usage
with temporary_env('DEBUG', 'true'):
    # DEBUG=true in here
    ...
# DEBUG restored to original value
```

---

## ğŸ§ª Practice: Find Context Managers

Look for these patterns in our codebase:

1. **File operations:** Any `with open(...)`
2. **App context:** `with app.app_context()`
3. **Test fixtures:** `yield` in pytest fixtures
4. **Database operations:** Transaction handling

---

## ğŸ”œ Next Steps

Now you understand context managers. Next, let's dive into Python's object-oriented programming.

**Next: [1.7_classes_and_oop.md](./1.7_classes_and_oop.md)** - Python OOP basics.
