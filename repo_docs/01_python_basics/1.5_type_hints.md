# ðŸ“ Type Hints Explained

> **Python's Optional Type System (Like TypeScript)**

---

## ðŸ“‹ What are Type Hints?

Type hints (also called "type annotations") let you specify the expected types of variables, function parameters, and return values.

```python
def greet(name: str) -> str:
    return f"Hello, {name}"
```

This says: "greet takes a string and returns a string."

**Key point:** Type hints are **optional** and **not enforced at runtime**. They're for:

-   Documentation
-   IDE autocompletion
-   Static analysis (mypy)

---

## ðŸ†š TypeScript Comparison

| TypeScript                             | Python                               |
| -------------------------------------- | ------------------------------------ |
| `function greet(name: string): string` | `def greet(name: str) -> str:`       |
| `let age: number = 25`                 | `age: int = 25`                      |
| `const items: string[]`                | `items: list[str]`                   |
| `interface User { ... }`               | `class User(TypedDict):` or Pydantic |

---

## ðŸ”§ Basic Type Hints

### Variables

```python
# Without type hints (still valid Python)
name = "John"
age = 25
is_active = True

# With type hints
name: str = "John"
age: int = 25
is_active: bool = True
price: float = 19.99
```

### Functions

```python
def add(a: int, b: int) -> int:
    return a + b

def greet(name: str) -> str:
    return f"Hello, {name}"

def process() -> None:     # Returns nothing
    print("Processing...")
```

---

## ðŸ“¦ Common Types

### Built-in Types

```python
# Primitives
name: str = "John"
age: int = 25
price: float = 9.99
is_active: bool = True
data: bytes = b"hello"

# Collections
names: list = ["John", "Jane"]      # Any list (less specific)
names: list[str] = ["John", "Jane"] # List of strings (more specific)

scores: dict = {"John": 100}               # Any dict
scores: dict[str, int] = {"John": 100}     # String keys, int values

unique_ids: set[int] = {1, 2, 3}

coordinates: tuple[float, float] = (1.5, 2.5)
```

### From `typing` Module

```python
from typing import List, Dict, Set, Tuple, Optional, Union, Any

# Before Python 3.9, you needed these:
names: List[str] = []
scores: Dict[str, int] = {}

# Python 3.9+, use lowercase:
names: list[str] = []
scores: dict[str, int] = {}
```

---

## ðŸŽ¯ Essential Types

### Optional (Value or None)

```python
from typing import Optional

def find_user(id: int) -> Optional[User]:
    """Returns User if found, None otherwise."""
    user = User.query.get(id)
    return user  # Could be User or None

# Usage
user = find_user(1)
if user is None:
    print("Not found")
```

**TypeScript equivalent:** `User | null`

### Union (Multiple Types)

```python
from typing import Union

def process(value: Union[str, int]) -> str:
    """Accept string or int."""
    return str(value)

# Python 3.10+ shorthand
def process(value: str | int) -> str:
    return str(value)
```

### Any (Escape Hatch)

```python
from typing import Any

def log_anything(value: Any) -> None:
    print(value)
```

**Warning:** `Any` disables type checking. Use sparingly!

---

## ðŸ“‹ Type Hints in Our Project

### Models

```python
# app/models/user.py

class User(BaseModel):
    __tablename__ = "users"

    id: int
    username: str
    email: str
    password_hash: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None

    def check_password(self, password: str) -> bool:
        return check_password_hash(self.password_hash, password)

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": self.id,
            "username": self.username,
            ...
        }
```

### Services

```python
# app/services/user_service.py

from typing import Optional, List, Tuple

class UserService:
    @staticmethod
    def get_by_id(user_id: int) -> Optional[User]:
        """Get user by ID."""
        return User.query.filter_by(
            id=user_id,
            is_deleted=False
        ).first()

    @staticmethod
    def get_all_paginated(
        page: int = 1,
        per_page: int = 20,
        include_deleted: bool = False
    ) -> Tuple[List[User], int]:
        """Get paginated users. Returns (users, total_count)."""
        ...
```

### Schemas (Pydantic)

```python
# app/schemas/user.py

from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class UserCreateSchema(BaseModel):
    username: str = Field(min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(min_length=8)
    first_name: str = Field(min_length=1, max_length=50)
    last_name: Optional[str] = Field(default=None, max_length=50)
    bio: Optional[str] = Field(default=None, max_length=500)
```

### Utility Functions

```python
# app/utils/responses.py

from typing import Any, Optional
from flask import Response

def success_response(
    data: Any,
    message: Optional[str] = None,
    status_code: int = 200,
    meta: Optional[dict[str, Any]] = None
) -> tuple[Response, int]:
    """Create a standardized success response."""
    ...
```

---

## ðŸ”§ Advanced Types

### Callable (Function Types)

```python
from typing import Callable

def apply_operation(
    x: int,
    y: int,
    operation: Callable[[int, int], int]
) -> int:
    return operation(x, y)

def add(a: int, b: int) -> int:
    return a + b

result = apply_operation(5, 3, add)  # 8
```

**TypeScript equivalent:** `(a: number, b: number) => number`

### TypedDict (Typed Dictionaries)

```python
from typing import TypedDict

class UserDict(TypedDict):
    id: int
    username: str
    email: str
    is_active: bool

def get_user() -> UserDict:
    return {
        "id": 1,
        "username": "john",
        "email": "john@example.com",
        "is_active": True
    }
```

### Generic Types

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')

class Repository(Generic[T]):
    def get_all(self) -> List[T]:
        ...

    def get_by_id(self, id: int) -> Optional[T]:
        ...

class UserRepository(Repository[User]):
    pass
```

---

## âœ… Type Checking with MyPy

Type hints alone don't enforce anything. Use **mypy** to check:

```bash
# Check a single file
mypy app/services/user_service.py

# Check entire project
mypy app/

# Our pre-commit runs mypy automatically
```

### MyPy Output Examples

```bash
# Error: Wrong type
app/routes/users.py:45: error: Argument 1 has incompatible type "str"; expected "int"

# Error: Missing return type
app/services/user.py:23: error: Function is missing a return type annotation

# Error: Could be None
app/auth.py:67: error: Item "None" has no attribute "username"
```

---

## ðŸ“– Reading Type Hints

### Example 1: Simple Function

```python
def create_user(username: str, email: str) -> User:
```

-   Takes `username` (string) and `email` (string)
-   Returns a `User` object

### Example 2: Optional Return

```python
def find_user(id: int) -> Optional[User]:
```

-   Takes `id` (integer)
-   Returns `User` if found, `None` if not

### Example 3: Complex Types

```python
def get_paginated(
    page: int,
    per_page: int
) -> Tuple[List[User], int]:
```

-   Takes two integers
-   Returns a tuple of (list of Users, total count)

### Example 4: Flexible Input

```python
def process_data(data: Union[str, bytes, dict]) -> dict:
```

-   Accepts string, bytes, OR dictionary
-   Always returns a dictionary

---

## âš ï¸ Common Patterns and Gotchas

### 1. Optional Parameters

```python
# Wrong
def func(name: str = None):  # Should be Optional[str]
    ...

# Correct
def func(name: Optional[str] = None):
    ...
```

### 2. Mutable Default Arguments

```python
# Dangerous!
def add_item(item: str, items: list[str] = []) -> list[str]:
    items.append(item)
    return items

# Safe
def add_item(
    item: str,
    items: Optional[list[str]] = None
) -> list[str]:
    if items is None:
        items = []
    items.append(item)
    return items
```

### 3. Forward References

```python
# Problem: User isn't defined yet
class UserService:
    def get_user(self) -> User:  # NameError!
        ...

class User:
    ...

# Solution 1: Use quotes
class UserService:
    def get_user(self) -> "User":  # String reference
        ...

# Solution 2: Use __future__ annotations
from __future__ import annotations

class UserService:
    def get_user(self) -> User:  # Now works!
        ...
```

### 4. Type Ignore Comments

When mypy is wrong or checking is impractical:

```python
result = some_dynamic_function()  # type: ignore
```

---

## ðŸŽ“ Best Practices

### 1. Always Type Function Signatures

```python
# Good
def create_user(username: str, email: str) -> User:
    ...

# Less good (missing types)
def create_user(username, email):
    ...
```

### 2. Use Optional for Nullable Values

```python
# Clear about nullability
def find_user(id: int) -> Optional[User]:
    ...
```

### 3. Be Specific When Possible

```python
# Too vague
def get_data() -> dict:
    ...

# More specific
def get_data() -> dict[str, Any]:
    ...

# Even more specific
def get_data() -> UserDict:
    ...
```

### 4. Use Pydantic for Complex Types

```python
# For complex data structures, Pydantic is better than TypedDict
from pydantic import BaseModel

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
```

---

## ðŸ”œ Next Steps

You now understand Python's type system. Next, let's learn about context managers (the `with` statement).

**Next: [1.6_context_managers.md](./1.6_context_managers.md)** - The 'with' statement explained.
