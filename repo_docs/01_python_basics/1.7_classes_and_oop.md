# üèõÔ∏è Classes and OOP in Python

> **Object-Oriented Programming Basics**

---

## üìã Overview

Python supports object-oriented programming (OOP) with classes, inheritance, and more. If you know JavaScript ES6 classes, Python classes will feel familiar.

---

## üÜö JavaScript Comparison

| Concept              | JavaScript         | Python              |
| -------------------- | ------------------ | ------------------- |
| Class definition     | `class User { }`   | `class User:`       |
| Constructor          | `constructor()`    | `__init__()`        |
| Instance reference   | `this`             | `self`              |
| Inheritance          | `extends`          | `(ParentClass)`     |
| Super call           | `super()`          | `super()`           |
| Private (convention) | `_name` or `#name` | `_name` or `__name` |
| Static method        | `static method()`  | `@staticmethod`     |

---

## üîß Basic Class

### JavaScript

```javascript
class User {
    constructor(username, email) {
        this.username = username;
        this.email = email;
    }

    greet() {
        return `Hello, ${this.username}!`;
    }
}

const user = new User("john", "john@example.com");
console.log(user.greet());
```

### Python

```python
class User:
    def __init__(self, username, email):
        self.username = username
        self.email = email

    def greet(self):
        return f"Hello, {self.username}!"

user = User('john', 'john@example.com')  # No 'new' keyword!
print(user.greet())
```

### Key Differences

1. **No `new` keyword** - Just call the class like a function
2. **`self` is explicit** - Must be first parameter of every method
3. **`__init__`** - The constructor (double underscores = "dunder method")
4. **Colon and indentation** - Instead of braces

---

## üìù The `self` Parameter

Every instance method must have `self` as its first parameter:

```python
class Counter:
    def __init__(self):
        self.count = 0        # Instance attribute

    def increment(self):       # self is required
        self.count += 1

    def get_count(self):       # self is required
        return self.count

counter = Counter()
counter.increment()            # self is passed automatically
print(counter.get_count())     # 1
```

**Why explicit `self`?** Python philosophy: "Explicit is better than implicit."

---

## üèóÔ∏è Class Attributes vs Instance Attributes

```python
class User:
    # Class attribute (shared by all instances)
    species = "human"
    user_count = 0

    def __init__(self, username):
        # Instance attribute (unique to each instance)
        self.username = username
        User.user_count += 1    # Modify class attribute

# Class attributes
print(User.species)        # "human"

# Instance attributes
user1 = User("john")
user2 = User("jane")

print(user1.username)      # "john"
print(user2.username)      # "jane"
print(User.user_count)     # 2
```

---

## üîó Inheritance

### Single Inheritance

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "Some sound"

class Dog(Animal):  # Dog inherits from Animal
    def __init__(self, name, breed):
        super().__init__(name)  # Call parent constructor
        self.breed = breed

    def speak(self):  # Override parent method
        return "Woof!"

dog = Dog("Buddy", "Labrador")
print(dog.name)     # "Buddy" (from Animal)
print(dog.breed)    # "Labrador" (from Dog)
print(dog.speak())  # "Woof!" (overridden)
```

### Multiple Inheritance

Python supports multiple inheritance (JavaScript doesn't):

```python
class Flyable:
    def fly(self):
        return "Flying!"

class Swimmable:
    def swim(self):
        return "Swimming!"

class Duck(Flyable, Swimmable):
    def quack(self):
        return "Quack!"

duck = Duck()
print(duck.fly())    # "Flying!"
print(duck.swim())   # "Swimming!"
print(duck.quack())  # "Quack!"
```

---

## üìö In Our Project: SQLAlchemy Models

### Base Model

```python
# app/models/base.py

class BaseModel(db.Model):
    """
    Abstract base model with common fields.
    All models inherit from this.
    """
    __abstract__ = True  # Don't create a table for this

    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    is_deleted = db.Column(db.Boolean, default=False)

    def soft_delete(self):
        """Mark as deleted without removing."""
        self.is_deleted = True

    def restore(self):
        """Restore a soft-deleted record."""
        self.is_deleted = False
```

### User Model (Inherits from BaseModel)

```python
# app/models/user.py

class User(BaseModel):
    """User model - inherits id, timestamps, soft delete."""

    __tablename__ = 'users'

    # User-specific columns
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)

    # Methods
    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            # Note: password_hash is NOT included!
        }
```

---

## üéØ Special Methods (Dunder Methods)

"Dunder" = Double Underscore. These are Python's magic methods.

### Common Dunder Methods

```python
class User:
    def __init__(self, username):
        """Constructor - called when creating instance."""
        self.username = username

    def __str__(self):
        """Human-readable string (like toString())."""
        return f"User: {self.username}"

    def __repr__(self):
        """Developer-readable string (for debugging)."""
        return f"<User username={self.username}>"

    def __eq__(self, other):
        """Equality comparison (==)."""
        return self.username == other.username

    def __len__(self):
        """Called by len()."""
        return len(self.username)

user = User("john")
print(str(user))      # "User: john"
print(repr(user))     # "<User username=john>"
print(len(user))      # 4
```

### In Our Code

```python
# app/models/user.py

class User(BaseModel):
    # ...

    def __repr__(self):
        return f"<User {self.username}>"

user = User.query.first()
print(user)  # <User john>
```

---

## üîí Access Modifiers (Convention-Based)

Python doesn't have private/protected keywords. It uses naming conventions:

```python
class BankAccount:
    def __init__(self):
        self.public = "Anyone can access"
        self._protected = "Should only be accessed internally"
        self.__private = "Name-mangled to prevent access"

    def get_private(self):
        return self.__private

account = BankAccount()


# Public - accessible
print(account.public)           # Works

# Protected - accessible but shouldn't be
print(account._protected)       # Works, but IDE may warn

# Private - name-mangled
print(account.__private)        # AttributeError!
print(account._BankAccount__private)  # Works (but don't do this)
print(account.get_private())    # Proper way
```

| Prefix   | Convention | Meaning                                |
| -------- | ---------- | -------------------------------------- |
| `name`   | Public     | Access freely                          |
| `_name`  | Protected  | Internal use, don't touch from outside |
| `__name` | Private    | Name-mangled, very internal            |

---

## üè∑Ô∏è Class Methods and Static Methods

### Instance Method (Normal)

```python
class User:
    def greet(self):  # Has access to instance (self)
        return f"Hello, {self.username}"
```

### Class Method (@classmethod)

```python
class User:
    user_count = 0

    @classmethod
    def get_count(cls):  # Has access to class (cls), not instance
        return cls.user_count

    @classmethod
    def create_admin(cls, username):
        """Alternative constructor."""
        user = cls(username, email=f"{username}@admin.com")
        user.is_admin = True
        return user

# Usage
print(User.get_count())
admin = User.create_admin("superuser")
```

### Static Method (@staticmethod)

```python
class User:
    @staticmethod
    def validate_email(email):  # No self or cls!
        """Utility function that doesn't need instance or class."""
        return "@" in email and "." in email

# Usage
print(User.validate_email("test@example.com"))  # True
```

### When to Use Each

| Type            | Use When                                         |
| --------------- | ------------------------------------------------ |
| Instance method | Needs access to instance data (`self`)           |
| Class method    | Needs access to class, not instance data (`cls`) |
| Static method   | Utility function, doesn't need class or instance |

---

## üì¶ Properties (@property)

Properties let you add getters/setters with clean syntax:

```python
class User:
    def __init__(self, first_name, last_name):
        self._first_name = first_name
        self._last_name = last_name

    @property
    def full_name(self):
        """Getter - called when accessing user.full_name"""
        return f"{self._first_name} {self._last_name}"

    @full_name.setter
    def full_name(self, value):
        """Setter - called when setting user.full_name = 'value'"""
        parts = value.split()
        self._first_name = parts[0]
        self._last_name = parts[-1]

user = User("John", "Doe")
print(user.full_name)        # "John Doe" (uses getter)

user.full_name = "Jane Smith"  # Uses setter
print(user.full_name)        # "Jane Smith"
```

---

## üèõÔ∏è Abstract Classes

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    """Abstract base class - cannot be instantiated."""

    @abstractmethod
    def area(self):
        """Must be implemented by subclasses."""
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

# shape = Shape()  # TypeError! Can't instantiate abstract class
rect = Rectangle(5, 3)
print(rect.area())  # 15
```

---

## üß™ Practice: Understanding Our Models

Look at `app/models/user.py`:

```python
class User(BaseModel):
    """User model inheriting common fields from BaseModel."""

    __tablename__ = 'users'
    __table_args__ = {'schema': 'users'}

    # Columns (class attributes)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)

    # Instance methods
    def set_password(self, password: str) -> None:
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        return check_password_hash(self.password_hash, password)

    def to_dict(self) -> dict:
        # Convert to dictionary (for JSON responses)
        ...

    # Dunder method
    def __repr__(self) -> str:
        return f"<User {self.username}>"
```

This demonstrates:

-   Inheritance (`BaseModel`)
-   Class attributes (columns)
-   Instance methods (set_password, check_password)
-   Dunder methods (**repr**)
-   Type hints

---

## üîú Next Steps

You now understand Python's OOP. Next, let's look at common Pythonic patterns.

**Next: [1.8_common_patterns.md](./1.8_common_patterns.md)** - Pythonic idioms and patterns.
