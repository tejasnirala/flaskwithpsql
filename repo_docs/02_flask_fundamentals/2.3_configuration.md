# âš™ï¸ Configuration in Flask

> **Managing Settings with config.py**

---

## ğŸ“‹ Overview

Flask applications need different configurations for different environments:

-   **Development** - Debug mode, local database
-   **Testing** - Test database, faster settings
-   **Production** - Secure settings, production database

Our `config.py` uses class-based configuration to manage all of this.

---

## ğŸ†š Express.js Comparison

**Express.js (typical):**

```javascript
// config/index.js
require("dotenv").config();

module.exports = {
    development: {
        DATABASE_URL: process.env.DATABASE_URL || "postgres://localhost/dev",
        DEBUG: true,
        SECRET_KEY: "dev-secret",
    },
    production: {
        DATABASE_URL: process.env.DATABASE_URL,
        DEBUG: false,
        SECRET_KEY: process.env.SECRET_KEY,
    },
};
```

**Flask (our approach):**

```python
# config.py
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY')
    DEBUG = False

class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'postgresql://localhost/dev'

class ProductionConfig(Config):
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
```

**Key difference:** Flask uses **class inheritance** for configuration, which is more powerful and Pythonic.

---

## ğŸ—ï¸ Configuration Class Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CONFIGURATION INHERITANCE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚                        Config (Base)                             â”‚
â”‚                             â”‚                                    â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚         â”‚                   â”‚                   â”‚                â”‚
â”‚         â–¼                   â–¼                   â–¼                â”‚
â”‚   Development          Testing            Production             â”‚
â”‚   Config               Config              Config                â”‚
â”‚                                                                  â”‚
â”‚   Each child class:                                              â”‚
â”‚   - Inherits all settings from Config                            â”‚
â”‚   - Can override specific settings                               â”‚
â”‚   - Can add its own settings                                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Our config.py Structure

```python
# config.py

import os
from typing import List, Optional

class Config:
    """Base configuration with shared settings."""

    # =========================================================================
    # Core Flask Settings
    # =========================================================================
    SECRET_KEY = os.environ.get('SECRET_KEY', 'dev-secret-key')

    # =========================================================================
    # Database Settings
    # =========================================================================
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ECHO = False  # Log SQL queries

    # Build database URI from environment
    @staticmethod
    def _build_database_uri():
        """Build database URI from environment variables."""
        return (
            f"postgresql://{os.environ.get('DB_USER', 'postgres')}:"
            f"{os.environ.get('DB_PASSWORD', 'postgres')}@"
            f"{os.environ.get('DB_HOST', 'localhost')}:"
            f"{os.environ.get('DB_PORT', '5432')}/"
            f"{os.environ.get('DB_NAME', 'flaskwithpsql')}"
        )

    SQLALCHEMY_DATABASE_URI = _build_database_uri()

    # =========================================================================
    # JWT Settings
    # =========================================================================
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY', SECRET_KEY)
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=15)
    JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)

    # =========================================================================
    # CORS Settings
    # =========================================================================
    CORS_ORIGINS = ['http://localhost:3000', 'http://localhost:5500']
    CORS_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']
    CORS_ALLOW_HEADERS = ['Content-Type', 'Authorization']

    # =========================================================================
    # Rate Limiting
    # =========================================================================
    RATELIMIT_ENABLED = True
    RATELIMIT_DEFAULT = "100 per minute"
    RATELIMIT_STORAGE_URL = "memory://"

    # =========================================================================
    # Logging
    # =========================================================================
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
    LOG_FORMAT = 'structured'  # 'structured' or 'simple'

    @classmethod
    def validate(cls) -> List[str]:
        """Validate configuration. Returns list of errors."""
        errors = []
        if cls.SECRET_KEY == 'dev-secret-key':
            errors.append("SECRET_KEY should be changed in production")
        return errors


class DevelopmentConfig(Config):
    """Development configuration."""

    DEBUG = True
    SQLALCHEMY_ECHO = True  # Log all SQL queries
    LOG_LEVEL = 'DEBUG'

    # Less strict rate limiting for development
    RATELIMIT_DEFAULT = "1000 per minute"


class TestingConfig(Config):
    """Testing configuration."""

    TESTING = True
    DEBUG = True

    # Use a separate test database
    SQLALCHEMY_DATABASE_URI = (
        f"postgresql://postgres:postgres@localhost:5432/flaskwithpsql_test"
    )

    # Disable rate limiting in tests
    RATELIMIT_ENABLED = False

    # Faster JWT for tests
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=5)


class ProductionConfig(Config):
    """Production configuration."""

    DEBUG = False
    TESTING = False

    # Must be set in environment
    SECRET_KEY = os.environ.get('SECRET_KEY')
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY')

    # Stricter rate limiting
    RATELIMIT_DEFAULT = "60 per minute"
    RATELIMIT_STORAGE_URL = os.environ.get('REDIS_URL', 'memory://')

    @classmethod
    def validate(cls) -> List[str]:
        """Stricter validation for production."""
        errors = super().validate()

        if not cls.SECRET_KEY:
            errors.append("SECRET_KEY must be set in production")
        if not os.environ.get('DATABASE_URL'):
            errors.append("DATABASE_URL must be set in production")

        return errors


# Configuration mapping
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
```

---

## ğŸ”§ How Configuration is Loaded

In the app factory:

```python
# app/__init__.py

def create_app(config_name="default"):
    # 1. Get the configuration class
    config_class = config[config_name]

    # 2. Validate configuration
    errors = config_class.validate()
    if errors:
        for error in errors:
            logger.error(f"CONFIG ERROR: {error}")

    # 3. Create app
    app = OpenAPI(__name__, info=info)

    # 4. Load configuration into app
    app.config.from_object(config_class)

    # Now app.config has all our settings!
    # app.config['SECRET_KEY']
    # app.config['SQLALCHEMY_DATABASE_URI']
    # etc.
```

---

## ğŸ“ Configuration Categories

### 1. Flask Core Settings

```python
SECRET_KEY = 'your-secret-key'  # For sessions, CSRF, etc.
DEBUG = True                     # Enable debug mode
TESTING = False                  # Enable testing mode
```

### 2. Database (SQLAlchemy)

```python
SQLALCHEMY_DATABASE_URI = 'postgresql://user:pass@localhost/db'
SQLALCHEMY_TRACK_MODIFICATIONS = False  # Disable event system (performance)
SQLALCHEMY_ECHO = False                 # Log SQL queries
```

### 3. JWT Authentication

```python
JWT_SECRET_KEY = 'jwt-secret'
JWT_ACCESS_TOKEN_EXPIRES = timedelta(minutes=15)
JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)
JWT_TOKEN_LOCATION = ['headers']
JWT_HEADER_TYPE = 'Bearer'
```

### 4. CORS

```python
CORS_ORIGINS = ['http://localhost:3000']
CORS_METHODS = ['GET', 'POST', 'PUT', 'DELETE']
CORS_ALLOW_HEADERS = ['Content-Type', 'Authorization']
CORS_CREDENTIALS = True
```

### 5. Rate Limiting

```python
RATELIMIT_ENABLED = True
RATELIMIT_DEFAULT = "100 per minute"
RATELIMIT_STORAGE_URL = "redis://localhost:6379"  # or "memory://"
```

---

## ğŸ” Environment Variables

Our configuration reads from environment variables:

```python
# config.py
SECRET_KEY = os.environ.get('SECRET_KEY', 'default-value')
```

**.env file:**

```env
# Core
FLASK_ENV=development
SECRET_KEY=super-secret-key-change-in-production
JWT_SECRET_KEY=another-secret-key

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=flaskwithpsql
DB_USER=postgres
DB_PASSWORD=postgres

# Optional
LOG_LEVEL=DEBUG
REDIS_URL=redis://localhost:6379
```

---

## ğŸ”„ Loading Order

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CONFIGURATION LOADING ORDER                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   1. Environment variables loaded (python-dotenv)                â”‚
â”‚      â””â”€â”€ .env file is read                                       â”‚
â”‚                                                                  â”‚
â”‚   2. Config class is selected                                    â”‚
â”‚      â””â”€â”€ config['development'] â†’ DevelopmentConfig               â”‚
â”‚                                                                  â”‚
â”‚   3. Class attributes become config values                       â”‚
â”‚      â””â”€â”€ Config.SECRET_KEY â†’ app.config['SECRET_KEY']            â”‚
â”‚                                                                  â”‚
â”‚   4. Inheritance applies                                         â”‚
â”‚      â””â”€â”€ DevelopmentConfig inherits from Config                  â”‚
â”‚      â””â”€â”€ Overrides are applied                                   â”‚
â”‚                                                                  â”‚
â”‚   5. Validation runs                                             â”‚
â”‚      â””â”€â”€ config_class.validate() checks for errors               â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§ª Accessing Configuration

```python
# In your code, access via app.config or current_app.config

from flask import current_app

# Inside a request
@app.route('/debug')
def debug():
    secret = current_app.config['SECRET_KEY']
    db_uri = current_app.config['SQLALCHEMY_DATABASE_URI']
    return f"DB: {db_uri}"

# Outside a request (need app context)
with app.app_context():
    secret = current_app.config['SECRET_KEY']
```

---

## ğŸ› ï¸ Helper Functions for Environment Variables

Environment variables are always strings, so we need helper functions to convert them to the correct Python types.

### The Problem

```python
# âŒ This doesn't work as expected!
DEBUG = os.environ.get('DEBUG', False)

# If DEBUG="false" in .env, this is TRUTHY (non-empty string)
# Only the EMPTY string is falsy in Python
```

### The Solution: Type-Safe Helper Functions

```python
# config.py

def get_env_bool(key: str, default: bool = False) -> bool:
    """
    Get a boolean from environment variable.

    Handles: 'true', 'True', 'TRUE', '1', 'yes', 'on'
    Returns default for anything else.
    """
    value = os.environ.get(key, '').lower()
    if value in ('true', '1', 'yes', 'on'):
        return True
    elif value in ('false', '0', 'no', 'off'):
        return False
    return default


def get_env_int(key: str, default: int) -> int:
    """
    Get an integer from environment variable.

    Returns default if not set or not a valid integer.
    """
    try:
        return int(os.environ.get(key, default))
    except (ValueError, TypeError):
        return default


def get_env_list(key: str, default: list = None, separator: str = ',') -> list:
    """
    Get a list from environment variable.

    Example: CORS_ORIGINS="http://localhost:3000,http://example.com"
    Returns: ['http://localhost:3000', 'http://example.com']
    """
    if default is None:
        default = []
    value = os.environ.get(key, '')
    if not value:
        return default
    return [item.strip() for item in value.split(separator) if item.strip()]
```

### Usage in Config

```python
class Config:
    # Boolean conversion
    DEBUG = get_env_bool('FLASK_DEBUG', default=False)

    # Integer conversion
    JWT_ACCESS_MINUTES = get_env_int('JWT_ACCESS_MINUTES', default=15)

    # List conversion
    CORS_ORIGINS = get_env_list('CORS_ORIGINS', default=['http://localhost:3000'])
```

### Node.js Equivalent

```javascript
// In Express, you'd do similar things:
const DEBUG = process.env.DEBUG === "true";
const JWT_ACCESS_MINUTES = parseInt(process.env.JWT_ACCESS_MINUTES, 10) || 15;
const CORS_ORIGINS = (process.env.CORS_ORIGINS || "http://localhost:3000").split(",");
```

---

## âš ï¸ The @property Pitfall

### The Problem

You might think using `@property` is elegant for building the database URI:

```python
class Config:
    @property
    def SQLALCHEMY_DATABASE_URI(self):
        return f"postgresql://{os.environ.get('DB_USER')}:..."
```

**But this doesn't work!** ğŸš«

### Why It Fails

Flask's `app.config.from_object()` reads **class attributes**, not instance properties:

```python
# What Flask does internally:
for key in dir(config_class):
    if key.isupper():  # Only uppercase names
        value = getattr(config_class, key)  # Gets class attribute
        app.config[key] = value
```

When you use `@property`, the value is only computed when accessed on an **instance**, but Flask never creates an instance of your config class!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   THE @property PROBLEM                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   class Config:                                                  â”‚
â”‚       @property                                                  â”‚
â”‚       def SQLALCHEMY_DATABASE_URI(self):                         â”‚
â”‚           return f"postgresql://..."                             â”‚
â”‚                                                                  â”‚
â”‚   What you expect:                                               â”‚
â”‚       app.config['SQLALCHEMY_DATABASE_URI'] = "postgresql://..." â”‚
â”‚                                                                  â”‚
â”‚   What actually happens:                                         â”‚
â”‚       app.config['SQLALCHEMY_DATABASE_URI'] = <property object>  â”‚
â”‚                                                                  â”‚
â”‚   Result: SQLAlchemy crashes! ğŸ’¥                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The Solution: Use @staticmethod or Direct Assignment

```python
class Config:
    # Solution 1: Direct assignment (computed at class definition time)
    SQLALCHEMY_DATABASE_URI = (
        f"postgresql://{os.environ.get('DB_USER', 'postgres')}:"
        f"{os.environ.get('DB_PASSWORD', 'postgres')}@"
        f"{os.environ.get('DB_HOST', 'localhost')}:"
        f"{os.environ.get('DB_PORT', '5432')}/"
        f"{os.environ.get('DB_NAME', 'flaskwithpsql')}"
    )

    # Solution 2: Use a helper method and call it
    @staticmethod
    def _build_database_uri():
        return f"postgresql://..."

    # Then call it explicitly:
    # SQLALCHEMY_DATABASE_URI = _build_database_uri.__func__()  # Awkward!
```

**Best practice:** Use direct assignment with f-strings or helper functions that return the value immediately.

---

## ğŸ”‘ Environment Variable Priority

Understanding the loading order helps debug configuration issues:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             ENVIRONMENT VARIABLE LOADING ORDER                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Priority (highest to lowest):                                  â”‚
â”‚                                                                  â”‚
â”‚   1. ğŸ”´ System Environment Variables                             â”‚
â”‚      â””â”€â”€ Set in shell: export SECRET_KEY=...                    â”‚
â”‚      â””â”€â”€ Set in Docker/Kubernetes                                â”‚
â”‚      â””â”€â”€ ALWAYS win!                                             â”‚
â”‚                                                                  â”‚
â”‚   2. ğŸŸ¡ .env File (loaded by python-dotenv)                      â”‚
â”‚      â””â”€â”€ Only loaded if variable NOT already set                â”‚
â”‚      â””â”€â”€ load_dotenv() does NOT override existing vars          â”‚
â”‚                                                                  â”‚
â”‚   3. ğŸŸ¢ Default Values in Code                                   â”‚
â”‚      â””â”€â”€ os.environ.get('KEY', 'default-value')                 â”‚
â”‚      â””â”€â”€ Only used if both above are missing                    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Practical Example

```bash
# .env file
SECRET_KEY=from-dotenv-file

# Shell
export SECRET_KEY=from-shell
```

```python
# config.py
from dotenv import load_dotenv
load_dotenv()  # Loads .env, but WON'T override shell variable

SECRET_KEY = os.environ.get('SECRET_KEY', 'default')
# Result: 'from-shell' (shell wins!)
```

### Forcing .env to Override (Usually Not Recommended)

```python
# Force .env to override existing variables
load_dotenv(override=True)  # Now .env wins

# Useful for: local development overrides
# Dangerous for: production where shell vars should be authoritative
```

---

## âš ï¸ Configuration Best Practices

### 1. Never Hardcode Secrets

```python
# âŒ BAD
SECRET_KEY = 'my-actual-secret-key'

# âœ… GOOD
SECRET_KEY = os.environ.get('SECRET_KEY')
```

### 2. Use Different Configs for Different Environments

```python
# Development
app = create_app('development')  # DEBUG=True, verbose logging

# Production
app = create_app('production')   # DEBUG=False, secure settings
```

### 3. Validate Production Configuration

```python
@classmethod
def validate(cls) -> List[str]:
    errors = []
    if not cls.SECRET_KEY:
        errors.append("SECRET_KEY must be set")
    return errors
```

### 4. Use Sensible Defaults

```python
# Default to safe values
DEBUG = get_env_bool('DEBUG', default=False)  # Use helper!
LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
```

### 5. Use .env.example as a Template

```bash
# .env.example (commit this to git)
SECRET_KEY=change-me-in-production
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=postgres
DB_PASSWORD=postgres

# .env (never commit this!)
SECRET_KEY=actual-super-secret-key-abc123
DB_PASSWORD=actual-database-password
```

### 6. Validate Early, Fail Fast

```python
def create_app(config_name="default"):
    config_class = config[config_name]

    # Validate before creating app
    errors = config_class.validate()
    if errors and config_name == 'production':
        # In production, fail fast on config errors
        raise RuntimeError(f"Configuration errors: {errors}")
    elif errors:
        # In development, just warn
        for error in errors:
            logger.warning(f"CONFIG WARNING: {error}")

    # ... continue with app creation
```

---

## ğŸ“Š Configuration Comparison by Environment

| Setting            | Development | Testing  | Production |
| ------------------ | ----------- | -------- | ---------- |
| DEBUG              | True        | True     | False      |
| SQLALCHEMY_ECHO    | True        | False    | False      |
| LOG_LEVEL          | DEBUG       | INFO     | WARNING    |
| RATELIMIT_DEFAULT  | 1000/min    | Disabled | 60/min     |
| JWT_ACCESS_EXPIRES | 15 min      | 5 min    | 15 min     |

---

## ğŸ”œ Next Steps

Now you understand configuration. Let's learn about Blueprints - how Flask organizes routes.

**Next: [2.4_blueprints.md](./2.4_blueprints.md)** - Organizing routes with Blueprints.
