# ğŸ”„ Request Lifecycle

> **What Happens When a Request Comes In**

---

## ğŸ“‹ Overview

Understanding the request lifecycle helps you debug issues and know where to hook into the process. Let's trace a request from start to finish.

---

## ğŸ†š Express.js Comparison

**Express.js middleware chain:**

```javascript
// Request flows through middleware in order
app.use(logger); // 1. Logging
app.use(cors()); // 2. CORS
app.use(express.json()); // 3. Body parsing
app.use(authenticate); // 4. Auth
app.use("/api", router); // 5. Routes
app.use(errorHandler); // 6. Error handling
```

**Flask request lifecycle:**

```python
# Similar concept, different mechanism
@app.before_request        # 1-4. Before handlers
def view_function():       # 5. Your code
    pass
@app.after_request         # 6. After handlers
@app.errorhandler          # 7. Error handlers
```

---

## ğŸ”„ Complete Request Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FLASK REQUEST LIFECYCLE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   CLIENT                                                         â”‚
â”‚      â”‚                                                           â”‚
â”‚      â”‚  HTTP Request: POST /api/v1/users/register                â”‚
â”‚      â”‚  Headers: Content-Type: application/json                  â”‚
â”‚      â”‚  Body: {"username": "john", ...}                          â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  1. WSGI SERVER (Werkzeug in development)               â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Receives raw HTTP request                       â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Creates environ dict                            â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  2. FLASK APP                                           â”‚    â”‚
â”‚   â”‚     â””â”€â”€ wsgi_app() is called                            â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Creates Request object                          â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Pushes application context                      â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Pushes request context                          â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  3. BEFORE_REQUEST HANDLERS                             â”‚    â”‚
â”‚   â”‚     â””â”€â”€ @app.before_request functions run               â”‚    â”‚
â”‚   â”‚     â””â”€â”€ @blueprint.before_request functions run         â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Can return early (e.g., auth failure)           â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  4. URL ROUTING                                         â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Match URL to view function                      â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Extract URL parameters (<int:user_id>)          â”‚    â”‚
â”‚   â”‚     â””â”€â”€ 404 if no match                                 â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  5. VIEW FUNCTION (Your Code!)                          â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Pydantic validation (flask-openapi3)            â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Your business logic runs                        â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Returns response data                           â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  6. AFTER_REQUEST HANDLERS                              â”‚    â”‚
â”‚   â”‚     â””â”€â”€ @app.after_request functions run                â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Add headers, modify response                    â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Logging, metrics                                â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚   â”‚  7. RESPONSE                                            â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Response object created                         â”‚    â”‚
â”‚   â”‚     â””â”€â”€ Context popped                                  â”‚    â”‚
â”‚   â”‚     â””â”€â”€ HTTP response sent to client                    â”‚    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚   CLIENT                                                         â”‚
â”‚      â”‚                                                           â”‚
â”‚      â”‚  HTTP Response: 201 Created                               â”‚
â”‚      â”‚  Body: {"success": true, "data": {...}}                   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” Detailed Breakdown

### 1. Request Object Creation

```python
# Flask creates this automatically from the HTTP request
from flask import request

# In your view function, you can access:
request.method       # 'POST'
request.path         # '/api/v1/users/register'
request.args         # Query parameters (dict-like)
request.form         # Form data (dict-like)
request.get_json()   # JSON body (dict)
request.headers      # HTTP headers
request.cookies      # Cookies
request.files        # Uploaded files
```

### 2. Before Request Handlers

```python
# app/__init__.py or blueprint

@app.before_request
def before_every_request():
    """Runs before every request to the app."""
    # Log the request
    logger.info(f"{request.method} {request.path}")

    # Check maintenance mode
    if app.config.get('MAINTENANCE_MODE'):
        return jsonify({'error': 'Maintenance'}), 503

@users_bp.before_request
def before_users_request():
    """Runs before every request to users blueprint."""
    # Blueprint-specific checks
    pass
```

### 3. View Function Execution

```python
# app/routes/v1/users.py

@users_bp.post('/register')
def register(body: UserCreateSchema):
    """
    This function is called after:
    1. URL matched to this route
    2. Pydantic validated the request body
    3. before_request handlers ran
    """
    # Your code here!
    user = UserService.create_user(body)
    return success_response(data=user.to_dict(), status_code=201)
```

### 4. After Request Handlers

```python
@app.after_request
def after_every_request(response):
    """Runs after every request (success or error)."""
    # Add security headers
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'

    # Log response
    logger.info(f"Response: {response.status_code}")

    # Must return the response!
    return response
```

### 5. Error Handlers

```python
@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors."""
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(Exception)
def handle_exception(error):
    """Handle all unhandled exceptions."""
    logger.error(f"Unhandled error: {error}")
    return jsonify({'error': 'Internal server error'}), 500
```

---

## ğŸ“Š Execution Order

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EXECUTION ORDER                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Normal Request:                                                â”‚
â”‚   1. @app.before_request                                         â”‚
â”‚   2. @blueprint.before_request                                   â”‚
â”‚   3. View function                                               â”‚
â”‚   4. @blueprint.after_request                                    â”‚
â”‚   5. @app.after_request                                          â”‚
â”‚                                                                  â”‚
â”‚   Error During Request:                                          â”‚
â”‚   1. @app.before_request                                         â”‚
â”‚   2. @blueprint.before_request                                   â”‚
â”‚   3. View function â†’ EXCEPTION                                   â”‚
â”‚   4. @app.errorhandler (matching exception)                      â”‚
â”‚   5. @app.after_request (still runs!)                            â”‚
â”‚                                                                  â”‚
â”‚   Teardown (always runs, even on failure):                       â”‚
â”‚   6. @app.teardown_request                                       â”‚
â”‚   7. @app.teardown_appcontext                                    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ£ All Available Hooks

| Hook                   | When it Runs                  | Use Case                  |
| ---------------------- | ----------------------------- | ------------------------- |
| `before_first_request` | Once, before first request    | One-time initialization   |
| `before_request`       | Before every request          | Auth, logging, validation |
| `after_request`        | After every request (success) | Add headers, logging      |
| `teardown_request`     | After request, always         | Cleanup resources         |
| `teardown_appcontext`  | When app context pops         | Close connections         |
| `errorhandler`         | When exception occurs         | Error handling            |

---

## ğŸ”§ Real Example from Our App

### Request: POST /api/v1/users/register

```python
# 1. Request comes in
# POST /api/v1/users/register
# Body: {"username": "john", "email": "john@example.com", ...}

# 2. Flask creates request object
# request.method = 'POST'
# request.path = '/api/v1/users/register'

# 3. Before request handlers run
# - Rate limiter checks (Flask-Limiter)
# - Logging (our custom logging)

# 4. URL routing matches to:
# app/routes/v1/users.py â†’ register()

# 5. flask-openapi3 validates body with Pydantic
# UserCreateSchema validates the JSON body

# 6. View function runs
@users_bp.post('/register')
def register(body: UserCreateSchema):
    # body is already validated!
    user = UserService.create_user(
        username=body.username,
        email=body.email,
        password=body.password,
    )
    return success_response(
        data=user.to_dict(),
        message="User registered successfully",
        status_code=201
    )

# 7. After request handlers run
# - Add security headers
# - Log the response

# 8. Response sent to client
# HTTP/1.1 201 Created
# Content-Type: application/json
# {"success": true, "data": {"id": 1, "username": "john", ...}}
```

---

## ğŸ§° The `g` Object

Flask provides `g` (global) for storing data during a request:

```python
from flask import g, request

@app.before_request
def load_user():
    """Load current user for the request."""
    token = request.headers.get('Authorization')
    if token:
        g.user = get_user_from_token(token)
    else:
        g.user = None

@users_bp.get('/profile')
def get_profile():
    """Access g.user set in before_request."""
    if not g.user:
        return error_response("Not authenticated", 401)
    return success_response(data=g.user.to_dict())
```

`g` is:

-   Request-scoped (reset for each request)
-   Good for sharing data between hooks and views
-   Similar to `req.user` in Express

---

## ğŸ”œ Next Steps

Now you understand the request lifecycle. Let's learn about Flask extensions.

**Next: [2.6_flask_extensions.md](./2.6_flask_extensions.md)** - How Flask extensions work.
